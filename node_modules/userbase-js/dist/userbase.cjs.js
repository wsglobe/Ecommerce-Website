(function(e, a) { for(var i in a) e[i] = a[i]; }(exports, /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 6);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

module.exports = require("base64-arraybuffer");

/***/ }),
/* 1 */
/***/ (function(module, exports) {

module.exports = require("@babel/runtime/helpers/defineProperty");

/***/ }),
/* 2 */
/***/ (function(module, exports) {

module.exports = require("uuid/v4");

/***/ }),
/* 3 */
/***/ (function(module, exports) {

module.exports = require("diffie-hellman");

/***/ }),
/* 4 */
/***/ (function(module, exports) {

module.exports = require("scrypt-js");

/***/ }),
/* 5 */
/***/ (function(module, exports) {

module.exports = require("sorted-array");

/***/ }),
/* 6 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXTERNAL MODULE: external "@babel/runtime/helpers/defineProperty"
var defineProperty_ = __webpack_require__(1);
var defineProperty_default = /*#__PURE__*/__webpack_require__.n(defineProperty_);

// EXTERNAL MODULE: external "base64-arraybuffer"
var external_base64_arraybuffer_ = __webpack_require__(0);
var external_base64_arraybuffer_default = /*#__PURE__*/__webpack_require__.n(external_base64_arraybuffer_);

// CONCATENATED MODULE: ./src/statusCodes.js
/* harmony default export */ var statusCodes = ({
  'Success': 200,
  'Bad Request': 400,
  'Unauthorized': 401,
  'Payment Required': 402,
  'Forbidden': 403,
  'Not Found': 404,
  'Conflict': 409,
  'Too Many Requests': 429,
  'Internal Server Error': 500,
  'Service Unavailable': 503,
  'Gateway Timeout': 504,
  // WebSocket close event codes
  'Service Restart': 1012,
  // Custom ws close event codes
  'No Pong Received': 3000,
  'Client Already Connected': 3001
});
// CONCATENATED MODULE: ./src/errors/auth.js


class auth_UsernameAlreadyExists extends Error {
  constructor(...params) {
    super(...params);
    this.name = 'UsernameAlreadyExists';
    this.message = 'Username already exists.';
    this.status = statusCodes['Conflict'];
  }

}

class auth_UsernameMissing extends Error {
  constructor(...params) {
    super(...params);
    this.name = 'UsernameMissing';
    this.message = 'Username missing.';
    this.status = statusCodes['Bad Request'];
  }

}

class auth_UsernameCannotBeBlank extends Error {
  constructor(...params) {
    super(...params);
    this.name = 'UsernameCannotBeBlank';
    this.message = 'Username cannot be blank.';
    this.status = statusCodes['Bad Request'];
  }

}

class auth_UsernameTooLong extends Error {
  constructor(maxLen, ...params) {
    super(maxLen, ...params);
    this.name = 'UsernameTooLong';
    this.message = "Username too long. Must be a max of ".concat(maxLen, " characters.");
    this.status = statusCodes['Bad Request'];
  }

}

class auth_UsernameMustBeString extends Error {
  constructor(...params) {
    super(...params);
    this.name = 'UsernameMustBeString';
    this.message = 'Username must be a string.';
    this.status = statusCodes['Bad Request'];
  }

}

class auth_PasswordMissing extends Error {
  constructor(...params) {
    super(...params);
    this.name = 'PasswordMissing';
    this.message = 'Password missing.';
    this.status = statusCodes['Bad Request'];
  }

}

class auth_PasswordCannotBeBlank extends Error {
  constructor(...params) {
    super(...params);
    this.name = 'PasswordCannotBeBlank';
    this.message = 'Password cannot be blank.';
    this.status = statusCodes['Bad Request'];
  }

}

class auth_PasswordTooShort extends Error {
  constructor(minLen, ...params) {
    super(minLen, ...params);
    this.name = 'PasswordTooShort';
    this.message = "Password too short. Must be a minimum of ".concat(minLen, " characters.");
    this.status = statusCodes['Bad Request'];
  }

}

class auth_PasswordTooLong extends Error {
  constructor(maxLen, ...params) {
    super(maxLen, ...params);
    this.name = 'PasswordTooLong';
    this.message = "Password too long. Must be a max of ".concat(maxLen, " characters.");
    this.status = statusCodes['Bad Request'];
  }

}

class auth_PasswordMustBeString extends Error {
  constructor(...params) {
    super(...params);
    this.name = 'PasswordMustBeString';
    this.message = 'Password must be a string.';
    this.status = statusCodes['Bad Request'];
  }

}

class auth_PasswordAttemptLimitExceeded extends Error {
  constructor(delay, ...params) {
    super(delay, ...params);
    this.name = 'PasswordAttemptLimitExceeded';
    this.message = "Password attempt limit exceeded. Must wait ".concat(delay, " to attempt to use password again.");
    this.status = statusCodes['Unauthorized'];
  }

}

class auth_UsernameOrPasswordMismatch extends Error {
  constructor(...params) {
    super(...params);
    this.name = 'UsernameOrPasswordMismatch';
    this.message = 'Username or password mismatch.';
    this.status = statusCodes['Unauthorized'];
  }

}

class auth_SessionLengthMustBeNumber extends Error {
  constructor(...params) {
    super(...params);
    this.name = 'SessionLengthMustBeNumber';
    this.message = 'Session length must be a number.';
    this.status = statusCodes['Bad Request'];
  }

}

class auth_SessionLengthTooShort extends Error {
  constructor(minLen, ...params) {
    super(minLen, ...params);
    this.name = 'SessionLengthTooShort';
    this.message = "Session length cannot be shorter than ".concat(minLen, ".");
    this.status = statusCodes['Bad Request'];
  }

}

class auth_SessionLengthTooLong extends Error {
  constructor(maxLen, ...params) {
    super(maxLen, ...params);
    this.name = 'SessionLengthTooLong';
    this.message = "Session length cannot be longer than ".concat(maxLen, ".");
    this.status = statusCodes['Bad Request'];
  }

}

class auth_AllowServerSideEncryptionMustBeBoolean extends Error {
  constructor(...params) {
    super(...params);
    this.name = 'AllowServerSideEncryptionMustBeBoolean';
    this.message = 'Allow server-side encryption value must be a boolean.';
    this.status = statusCodes['Bad Request'];
  }

}

class auth_UserAlreadySignedIn extends Error {
  constructor(username, ...params) {
    super(...params);
    this.name = 'UserAlreadySignedIn';
    this.message = 'Already signed in.';
    this.status = statusCodes['Bad Request'];
    this.username = username;
  }

}

class auth_UserPendingDeletion extends Error {
  constructor(...params) {
    super(...params);
    this.name = 'UserPendingDeletion';
    this.message = 'User is pending deletion.';
    this.status = statusCodes['Forbidden'];
  }

}

class auth_AppIdNotValid extends Error {
  constructor(...params) {
    super(...params);
    this.name = 'AppIdNotValid';
    this.message = 'App ID not valid.';
    this.status = statusCodes['Unauthorized'];
  }

}

class auth_DomainNotWhitelisted extends Error {
  constructor(domain, ...params) {
    super(domain, ...params);
    this.name = 'DomainNotWhitelisted';
    this.message = "Domain not whitelisted. Whitelist the domain ".concat(domain ? "'".concat(domain, "' ") : '', "in your admin panel.");
    this.status = statusCodes['Unauthorized'];
  }

}

class auth_UserNotSignedIn extends Error {
  constructor(...params) {
    super(...params);
    this.name = 'UserNotSignedIn';
    this.message = 'Not signed in.';
    this.status = statusCodes['Bad Request'];
  }

}

class auth_UserNotFound extends Error {
  constructor(username, ...params) {
    super(username, ...params);
    if (username) this.username = username;
    this.name = 'UserNotFound';
    this.message = 'User not found.';
    this.status = statusCodes['Not Found'];
  }

}

class auth_UserEmailNotFound extends Error {
  constructor(...params) {
    super(...params);
    this.name = 'UserEmailNotFound';
    this.message = 'User does not have an email saved.';
    this.status = statusCodes['Not Found'];
  }

}

class auth_UserMustChangePassword extends Error {
  constructor(...params) {
    super(...params);
    this.name = 'UserMustChangePassword';
    this.message = 'Must change password first.';
    this.status = statusCodes['Forbidden'];
  }

}

class auth_EmailNotValid extends Error {
  constructor(...params) {
    super(...params);
    this.name = 'EmailNotValid';
    this.message = 'Email not valid.';
    this.status = statusCodes['Bad Request'];
  }

}

class auth_ProfileMustBeObject extends Error {
  constructor(...params) {
    super(...params);
    this.name = 'ProfileMustBeObject';
    this.message = 'Profile must be a flat JSON object.';
    this.status = statusCodes['Bad Request'];
  }

}

class auth_ProfileCannotBeEmpty extends Error {
  constructor(...params) {
    super(...params);
    this.name = 'ProfileCannotBeEmpty';
    this.message = 'Profile cannot be empty.';
    this.status = statusCodes['Bad Request'];
  }

}

class auth_ProfileHasTooManyKeys extends Error {
  constructor(maxKeys, ...params) {
    super(maxKeys, ...params);
    this.name = 'ProfileHasTooManyKeys';
    this.message = "Profile has too many keys. Must have a max of ".concat(maxKeys, " keys.");
    this.status = statusCodes['Bad Request'];
  }

}

class auth_ProfileKeyTooLong extends Error {
  constructor(maxLen, key, ...params) {
    super(maxLen, key, ...params);
    this.name = 'ProfileKeyTooLong';
    this.message = "Profile key too long. Must be a max of ".concat(maxLen, " characters.");
    this.status = statusCodes['Bad Request'];
    this.key = key;
  }

}

class auth_ProfileValueMustBeString extends Error {
  constructor(key, value, ...params) {
    super(key, value, ...params);
    this.name = 'ProfileValueMustBeString';
    this.message = 'Profile value must be a string.';
    this.status = statusCodes['Bad Request'];
    this.key = key;
    this.value = value;
  }

}

class auth_ProfileValueCannotBeBlank extends Error {
  constructor(key, ...params) {
    super(key, ...params);
    this.name = 'ProfileValueCannotBeBlank';
    this.message = 'Profile value cannot be blank.';
    this.status = statusCodes['Bad Request'];
    this.key = key;
  }

}

class auth_ProfileValueTooLong extends Error {
  constructor(maxLen, key, value, ...params) {
    super(maxLen, key, value, ...params);
    this.name = 'ProfileValueTooLong';
    this.message = "Profile value too long. Must be a max of ".concat(maxLen, " characters.");
    this.status = statusCodes['Bad Request'];
    this.key = key;
    this.value = value;
  }

}

class auth_RememberMeValueNotValid extends Error {
  constructor(options, ...params) {
    super(options, ...params);
    this.name = 'RememberMeValueNotValid';
    this.message = "Remember me value must be one of ".concat(JSON.stringify(Object.keys(options)), ".");
    this.status = statusCodes['Bad Request'];
  }

}

class auth_ParamsMissing extends Error {
  constructor(...params) {
    super(...params);
    this.name = 'ParamsMissing';
    this.message = 'Parameters expected are missing.';
    this.status = statusCodes['Bad Request'];
  }

}

class auth_TrialExceededLimit extends Error {
  constructor(...params) {
    super(...params);
    this.name = 'TrialExceededLimit';
    this.message = 'Trial exceeded limit of users.';
    this.status = statusCodes['Payment Required'];
  }

}

class auth_CurrentPasswordMissing extends Error {
  constructor(...params) {
    super(...params);
    this.name = 'CurrentPasswordMissing';
    this.message = 'Current password missing.';
    this.status = statusCodes['Bad Request'];
  }

}

class auth_CurrentPasswordIncorrect extends Error {
  constructor(...params) {
    super(...params);
    this.name = 'CurrentPasswordIncorrect';
    this.message = 'Current password is incorrect.';
    this.status = statusCodes['Unauthorized'];
  }

}

class auth_KeyNotFound extends Error {
  constructor(message, ...params) {
    super(message, ...params);
    this.name = 'KeyNotFound';
    this.message = message;
    this.status = statusCodes['Not Found'];
  }

}

class auth_DeleteEndToEndEncryptedDataMustBeBoolean extends Error {
  constructor(...params) {
    super(...params);
    this.name = 'DeleteEndToEndEncryptedDataMustBeBoolean';
    this.message = 'Delete end-to-end encrypted data value must be a boolean.';
    this.status = statusCodes['Bad Request'];
  }

}

/* harmony default export */ var auth = ({
  UsernameAlreadyExists: auth_UsernameAlreadyExists,
  UsernameMissing: auth_UsernameMissing,
  UsernameCannotBeBlank: auth_UsernameCannotBeBlank,
  UsernameTooLong: auth_UsernameTooLong,
  UsernameMustBeString: auth_UsernameMustBeString,
  PasswordMissing: auth_PasswordMissing,
  PasswordCannotBeBlank: auth_PasswordCannotBeBlank,
  PasswordTooShort: auth_PasswordTooShort,
  PasswordTooLong: auth_PasswordTooLong,
  PasswordMustBeString: auth_PasswordMustBeString,
  PasswordAttemptLimitExceeded: auth_PasswordAttemptLimitExceeded,
  UsernameOrPasswordMismatch: auth_UsernameOrPasswordMismatch,
  SessionLengthMustBeNumber: auth_SessionLengthMustBeNumber,
  SessionLengthTooShort: auth_SessionLengthTooShort,
  SessionLengthTooLong: auth_SessionLengthTooLong,
  AllowServerSideEncryptionMustBeBoolean: auth_AllowServerSideEncryptionMustBeBoolean,
  UserAlreadySignedIn: auth_UserAlreadySignedIn,
  UserPendingDeletion: auth_UserPendingDeletion,
  AppIdNotValid: auth_AppIdNotValid,
  DomainNotWhitelisted: auth_DomainNotWhitelisted,
  UserNotSignedIn: auth_UserNotSignedIn,
  UserNotFound: auth_UserNotFound,
  UserEmailNotFound: auth_UserEmailNotFound,
  UserMustChangePassword: auth_UserMustChangePassword,
  EmailNotValid: auth_EmailNotValid,
  ProfileMustBeObject: auth_ProfileMustBeObject,
  ProfileCannotBeEmpty: auth_ProfileCannotBeEmpty,
  ProfileHasTooManyKeys: auth_ProfileHasTooManyKeys,
  ProfileKeyTooLong: auth_ProfileKeyTooLong,
  ProfileValueMustBeString: auth_ProfileValueMustBeString,
  ProfileValueCannotBeBlank: auth_ProfileValueCannotBeBlank,
  ProfileValueTooLong: auth_ProfileValueTooLong,
  RememberMeValueNotValid: auth_RememberMeValueNotValid,
  ParamsMissing: auth_ParamsMissing,
  TrialExceededLimit: auth_TrialExceededLimit,
  CurrentPasswordMissing: auth_CurrentPasswordMissing,
  CurrentPasswordIncorrect: auth_CurrentPasswordIncorrect,
  KeyNotFound: auth_KeyNotFound,
  DeleteEndToEndEncryptedDataMustBeBoolean: auth_DeleteEndToEndEncryptedDataMustBeBoolean
});
// CONCATENATED MODULE: ./src/errors/db.js


class db_DatabaseNameMissing extends Error {
  constructor(...params) {
    super(...params);
    this.name = 'DatabaseNameMissing';
    this.message = 'Database name missing.';
    this.status = statusCodes['Bad Request'];
  }

}

class db_DatabaseNameCannotBeBlank extends Error {
  constructor(...params) {
    super(...params);
    this.name = 'DatabaseNameCannotBeBlank';
    this.message = 'Database name cannot be blank.';
    this.status = statusCodes['Bad Request'];
  }

}

class db_DatabaseNameMustBeString extends Error {
  constructor(...params) {
    super(...params);
    this.name = 'DatabaseNameMustBeString';
    this.message = 'Database name must be a string.';
    this.status = statusCodes['Bad Request'];
  }

}

class db_DatabaseNameTooLong extends Error {
  constructor(maxLength, ...params) {
    super(maxLength, ...params);
    this.name = 'DatabaseNameTooLong';
    this.message = "Database name cannot be more than ".concat(maxLength, " characters.");
    this.status = statusCodes['Bad Request'];
  }

}

class db_DatabaseNameRestricted extends Error {
  constructor(databaseName, ...params) {
    super(databaseName, ...params);
    this.name = 'DatabaseNameRestricted';
    this.message = "Database name '".concat(databaseName, "' is restricted. It is used internally by userbase-js.");
    this.status = statusCodes['Forbidden'];
  }

}

class db_DatabaseAlreadyOpening extends Error {
  constructor(...params) {
    super(...params);
    this.name = 'DatabaseAlreadyOpening';
    this.message = 'Already attempting to open database.';
    this.status = statusCodes['Bad Request'];
  }

}

class db_ChangeHandlerMissing extends Error {
  constructor(...params) {
    super(...params);
    this.name = 'ChangeHandlerMissing';
    this.message = 'Change handler missing.';
    this.status = statusCodes['Bad Request'];
  }

}

class db_ChangeHandlerMustBeFunction extends Error {
  constructor(...params) {
    super(...params);
    this.name = 'ChangeHandlerMustBeFunction';
    this.message = 'Change handler must be a function.';
    this.status = statusCodes['Bad Request'];
  }

}

class db_EncryptionModeNotValid extends Error {
  constructor(options, ...params) {
    super(options, ...params);
    this.name = 'EncryptionModeNotValid';
    this.message = "Encryption mode must be one of ".concat(JSON.stringify(Object.keys(options)), ".");
    this.status = statusCodes['Bad Request'];
  }

}

class db_ServerSideEncryptionNotEnabledInClient extends Error {
  constructor(...params) {
    super(...params);
    this.name = 'ServerSideEncryptionNotEnabledInClient';
    this.message = 'Server-side encryption must be enabled in the client to use it. To enable it, set allowServerSideEncryption to true in init().';
    this.status = statusCodes['Forbidden'];
  }

}

class db_DatabaseNotOpen extends Error {
  constructor(...params) {
    super(...params);
    this.name = 'DatabaseNotOpen';
    this.message = 'Database is not open.';
    this.status = statusCodes['Bad Request'];
  }

}

class db_DatabaseNotFound extends Error {
  constructor(...params) {
    super(...params);
    this.name = 'DatabaseNotFound';
    this.message = 'Database not found. Find available databases using getDatabases().';
    this.status = statusCodes['Not Found'];
  }

}

class db_DatabaseIsReadOnly extends Error {
  constructor(...params) {
    super(...params);
    this.name = 'DatabaseIsReadOnly';
    this.message = 'Database is read only. Must have permission to write to database.';
    this.status = statusCodes['Forbidden'];
  }

}

class db_DatabaseIdMustBeString extends Error {
  constructor(...params) {
    super(...params);
    this.name = 'DatabaseIdMustBeString';
    this.message = 'Database id must be a string.';
    this.status = statusCodes['Bad Request'];
  }

}

class db_DatabaseIdCannotBeBlank extends Error {
  constructor(...params) {
    super(...params);
    this.name = 'DatabaseIdCannotBeBlank';
    this.message = 'Database id cannot be blank.';
    this.status = statusCodes['Bad Request'];
  }

}

class db_DatabaseIdNotAllowed extends Error {
  constructor(...params) {
    super(...params);
    this.name = 'DatabaseIdNotAllowed';
    this.message = 'Database id not allowed. Cannot provide both databaseName and databaseId, can only provide one.';
    this.status = statusCodes['Bad Request'];
  }

}

class db_DatabaseIdNotAllowedForOwnDatabase extends Error {
  constructor(...params) {
    super(...params);
    this.name = 'DatabaseIdNotAllowedForOwnDatabase';
    this.message = "Tried to open the user's own database using its databaseId rather than its databaseName. The databaseId should only be used to open databases shared from other users.";
    this.status = statusCodes['Forbidden'];
  }

}

class db_DatabaseIdInvalidLength extends Error {
  constructor(length, ...params) {
    super(length, ...params);
    this.name = 'DatabaseIdInvalidLength';
    this.message = "Database id invalid length. Must be ".concat(length, " characters.");
    this.status = statusCodes['Bad Request'];
  }

}

class db_ShareTokenInvalid extends Error {
  constructor(...params) {
    super(...params);
    this.name = 'ShareTokenInvalid';
    this.message = 'Share token invalid.';
    this.status = statusCodes['Bad Request'];
  }

}

class db_ShareTokenNotFound extends Error {
  constructor(...params) {
    super(...params);
    this.name = 'ShareTokenNotFound';
    this.message = 'Share token not found. Perhaps the database owner has generated a new share token.';
    this.status = statusCodes['Not Found'];
  }

}

class db_ShareTokenNotAllowed extends Error {
  constructor(reason, ...params) {
    super(reason, ...params);
    this.name = 'ShareTokenNotAllowed';
    this.message = 'Share token not allowed.';
    this.status = statusCodes['Bad Request'];
  }

}

class db_ShareTokenNotAllowedForOwnDatabase extends Error {
  constructor(...params) {
    super(...params);
    this.name = 'ShareTokenNotAllowedForOwnDatabase';
    this.message = "Tried to open the user's own database using its shareToken rather than its databaseName. The shareToken should only be used to open databases shared from other users.";
    this.status = statusCodes['Forbidden'];
  }

}

class db_ReadOnlyMustBeBoolean extends Error {
  constructor(...params) {
    super(...params);
    this.name = 'ReadOnlyMustBeBoolean';
    this.message = 'Read only value must be a boolean.';
    this.status = statusCodes['Bad Request'];
  }

}

class db_ReadOnlyParamNotAllowed extends Error {
  constructor(...params) {
    super(...params);
    this.name = 'ReadOnlyParamNotAllowed';
    this.message = 'Read only parameter not allowed when revoking access to a database.';
    this.status = statusCodes['Bad Request'];
  }

}

class db_ResharingAllowedParamNotAllowed extends Error {
  constructor(reason, ...params) {
    super(reason, ...params);
    this.name = 'ResharingAllowedParamNotAllowed';
    this.message = "Resharing allowed parameter not allowed ".concat(reason, ".");
    this.status = statusCodes['Bad Request'];
  }

}

class db_ResharingAllowedMustBeBoolean extends Error {
  constructor(...params) {
    super(...params);
    this.name = 'ResharingAllowedMustBeBoolean';
    this.message = 'Resharing allowed value must be a boolean.';
    this.status = statusCodes['Bad Request'];
  }

}

class db_ResharingNotAllowed extends Error {
  constructor(reason, ...params) {
    super(reason, ...params);
    this.name = 'ResharingNotAllowed';
    this.message = "Resharing not allowed. ".concat(reason, ".");
    this.status = statusCodes['Forbidden'];
  }

}

class db_ResharingWithWriteAccessNotAllowed extends Error {
  constructor(...params) {
    super(...params);
    this.name = 'ResharingWithWriteAccessNotAllowed';
    this.message = 'Resharing with write access not allowed. Must have permission to write to the database to reshare the database with write access another user.';
    this.status = statusCodes['Forbidden'];
  }

}

class db_SharingWithSelfNotAllowed extends Error {
  constructor(...params) {
    super(...params);
    this.name = 'SharingWithSelfNotAllowed';
    this.message = 'Sharing database with self is not allowed. Must share database with another user.';
    this.status = statusCodes['Bad Request'];
  }

}

class db_ModifyingOwnPermissionsNotAllowed extends Error {
  constructor(...params) {
    super(...params);
    this.name = 'ModifyingOwnPermissionsNotAllowed';
    this.message = "Modifying own database permissions not allowed. Must modify another user's permissions.";
    this.status = statusCodes['Bad Request'];
  }

}

class db_ModifyingOwnerPermissionsNotAllowed extends Error {
  constructor(...params) {
    super(...params);
    this.name = 'ModifyingOwnerPermissionsNotAllowed';
    this.message = "Modifying the owner of a database's permissions is not allowed.";
    this.status = statusCodes['Forbidden'];
  }

}

class db_ModifyingPermissionsNotAllowed extends Error {
  constructor(...params) {
    super(...params);
    this.name = 'ModifyingPermissionsNotAllowed';
    this.message = "Modifying another user's permissions is not allowed. Must have permission to reshare the database with another user.";
    this.status = statusCodes['Forbidden'];
  }

}

class db_GrantingWriteAccessNotAllowed extends Error {
  constructor(...params) {
    super(...params);
    this.name = 'GrantingWriteAccessNotAllowed';
    this.message = 'Granting write access not allowed. Must have permission to write to the database to grant write access to another user.';
    this.status = statusCodes['Forbidden'];
  }

}

class db_RequireVerifiedMustBeBoolean extends Error {
  constructor(...params) {
    super(...params);
    this.name = 'RequireVerifiedMustBeBoolean';
    this.message = 'Require verified value must be a boolean.';
    this.status = statusCodes['Bad Request'];
  }

}

class db_RequireVerifiedParamNotNecessary extends Error {
  constructor(...params) {
    super(...params);
    this.name = 'RequireVerifiedParamNotNecessary';
    this.message = 'Require verified parameter not necessary when sharing database without a username.';
    this.status = statusCodes['Bad Request'];
  }

}

class db_RevokeMustBeBoolean extends Error {
  constructor(...params) {
    super(...params);
    this.name = 'RevokeMustBeBoolean';
    this.message = 'Revoke value must be a boolean.';
    this.status = statusCodes['Bad Request'];
  }

}

class db_ItemMissing extends Error {
  constructor(...params) {
    super(...params);
    this.name = 'ItemMissing';
    this.message = 'Item missing.';
    this.status = statusCodes['Bad Request'];
  }

}

class db_ItemInvalid extends Error {
  constructor(...params) {
    super(...params);
    this.name = 'ItemInvalid';
    this.message = 'Item must be serializable to JSON.';
    this.status = statusCodes['Bad Request'];
  }

}

class db_ItemTooLarge extends Error {
  constructor(maxKb, ...params) {
    super(maxKb, ...params);
    this.name = 'ItemTooLarge';
    this.message = "Item must be less than ".concat(maxKb, " KB.");
    this.status = statusCodes['Bad Request'];
  }

}

class db_ItemIdMustBeString extends Error {
  constructor(...params) {
    super(...params);
    this.name = 'ItemIdMustBeString';
    this.message = 'Item id must be a string.';
    this.status = statusCodes['Bad Request'];
  }

}

class db_ItemIdTooLong extends Error {
  constructor(maxLength, ...params) {
    super(maxLength, ...params);
    this.name = 'ItemIdTooLong';
    this.message = "Item id cannot be more than ".concat(maxLength, " characters.");
    this.status = statusCodes['Bad Request'];
  }

}

class db_ItemIdMissing extends Error {
  constructor(...params) {
    super(...params);
    this.name = 'ItemIdMissing';
    this.message = 'Item id missing.';
    this.status = statusCodes['Bad Request'];
  }

}

class db_ItemIdCannotBeBlank extends Error {
  constructor(...params) {
    super(...params);
    this.name = 'ItemIdCannotBeBlank';
    this.message = 'Item id cannot be blank.';
    this.status = statusCodes['Bad Request'];
  }

}

class db_ItemAlreadyExists extends Error {
  constructor(...params) {
    super(...params);
    this.name = 'ItemAlreadyExists';
    this.message = 'Item with the same id already exists.';
    this.status = statusCodes['Conflict'];
  }

}

class db_ItemDoesNotExist extends Error {
  constructor(...params) {
    super(...params);
    this.name = 'ItemDoesNotExist';
    this.message = 'Item with the provided id does not exist.';
    this.status = statusCodes['Not Found'];
  }

}

class db_ItemUpdateConflict extends Error {
  constructor(...params) {
    super(...params);
    this.name = 'ItemUpdateConflict';
    this.message = 'Item update conflict.';
    this.status = statusCodes['Conflict'];
  }

}

class db_FileMissing extends Error {
  constructor(...params) {
    super(...params);
    this.name = 'FileMissing';
    this.message = 'File missing.';
    this.status = statusCodes['Bad Request'];
  }

}

class db_FileMustBeFile extends Error {
  constructor(...params) {
    super(...params);
    this.name = 'FileMustBeFile';
    this.message = 'File must be a file.';
    this.status = statusCodes['Bad Request'];
  }

}

class db_FileCannotBeEmpty extends Error {
  constructor(...params) {
    super(...params);
    this.name = 'FileCannotBeEmpty';
    this.message = 'File cannot be empty.';
    this.status = statusCodes['Bad Request'];
  }

}

class db_FileUploadConflict extends Error {
  constructor(...params) {
    super(...params);
    this.name = 'FileUploadConflict';
    this.message = 'File upload conflict.';
    this.status = statusCodes['Conflict'];
  }

}

class db_FileNotFound extends Error {
  constructor(...params) {
    super(...params);
    this.name = 'FileNotFound';
    this.message = 'File not found.';
    this.status = statusCodes['Not Found'];
  }

}

class db_FileIdMissing extends Error {
  constructor(...params) {
    super(...params);
    this.name = 'FileIdMissing';
    this.message = 'File id missing.';
    this.status = statusCodes['Bad Request'];
  }

}

class db_FileIdMustBeString extends Error {
  constructor(...params) {
    super(...params);
    this.name = 'FileIdMustBeString';
    this.message = 'File id must be a string.';
    this.status = statusCodes['Bad Request'];
  }

}

class db_FileIdCannotBeBlank extends Error {
  constructor(...params) {
    super(...params);
    this.name = 'FileIdCannotBeBlank';
    this.message = 'File id cannot be blank.';
    this.status = statusCodes['Bad Request'];
  }

}

class db_FileIdTooLong extends Error {
  constructor(maxLength, ...params) {
    super(maxLength, ...params);
    this.name = 'FileIdTooLong';
    this.message = "File id cannot be more than ".concat(maxLength, " characters.");
    this.status = statusCodes['Bad Request'];
  }

}

class db_RangeMustBeObject extends Error {
  constructor(...params) {
    super(...params);
    this.name = 'RangeMustBeObject';
    this.message = 'Range param provided must be object.';
    this.status = statusCodes['Bad Request'];
  }

}

class db_RangeMissingStart extends Error {
  constructor(...params) {
    super(...params);
    this.name = 'RangeMissingStart';
    this.message = 'Range param missing start.';
    this.status = statusCodes['Bad Request'];
  }

}

class db_RangeMissingEnd extends Error {
  constructor(...params) {
    super(...params);
    this.name = 'RangeMissingEnd';
    this.message = 'Range param missing end.';
    this.status = statusCodes['Bad Request'];
  }

}

class db_RangeStartMustBeNumber extends Error {
  constructor(...params) {
    super(...params);
    this.name = 'RangeStartMustBeNumber';
    this.message = 'Range start provided must be a number.';
    this.status = statusCodes['Bad Request'];
  }

}

class db_RangeEndMustBeNumber extends Error {
  constructor(...params) {
    super(...params);
    this.name = 'RangeEndMustBeNumber';
    this.message = 'Range end provided must be a number.';
    this.status = statusCodes['Bad Request'];
  }

}

class db_RangeStartMustBeGreaterThanZero extends Error {
  constructor(...params) {
    super(...params);
    this.name = 'RangeStartMustBeGreaterThanZero';
    this.message = 'Range start provided must be greater than 0.';
    this.status = statusCodes['Bad Request'];
  }

}

class db_RangeEndMustBeGreaterThanRangeStart extends Error {
  constructor(...params) {
    super(...params);
    this.name = 'RangeEndMustBeGreaterThanRangeStart';
    this.message = 'Range end provided must be greater than range start.';
    this.status = statusCodes['Bad Request'];
  }

}

class db_RangeEndMustBeLessThanFileSize extends Error {
  constructor(...params) {
    super(...params);
    this.name = 'RangeEndMustBeLessThanFileSize';
    this.message = 'Range end provided must be less than file size.';
    this.status = statusCodes['Bad Request'];
  }

}

class db_OperationsMissing extends Error {
  constructor(...params) {
    super(...params);
    this.name = 'OperationsMissing';
    this.message = 'Operations missing.';
    this.status = statusCodes['Bad Request'];
  }

}

class db_OperationsMustBeArray extends Error {
  constructor(...params) {
    super(...params);
    this.name = 'OperationsMustBeArray';
    this.message = 'Operations provided must be an array.';
    this.status = statusCodes['Bad Request'];
  }

}

class db_CommandNotRecognized extends Error {
  constructor(command, ...params) {
    super(command, ...params);
    this.name = 'CommandNotRecognized';
    this.message = "Command '".concat(command, "' not recognized.");
    this.status = statusCodes['Bad Request'];
  }

}

class db_OperationsConflict extends Error {
  constructor(...params) {
    super(...params);
    this.name = 'OperationsConflict';
    this.message = 'Operations conflict. Only allowed 1 operation per item.';
    this.status = statusCodes['Conflict'];
  }

}

class db_OperationsExceedLimit extends Error {
  constructor(limit, ...params) {
    super(limit, ...params);
    this.name = 'OperationsExceedLimit';
    this.message = "Operations exceed limit. Only allowed ".concat(limit, " operations.");
    this.status = statusCodes['Bad Request'];
  }

}

class db_UserNotVerified extends Error {
  constructor(...params) {
    super(...params);
    this.name = 'UserNotVerified';
    this.message = 'User not verified. Either verify user before sharing database, or set requireVerified to false.';
    this.status = statusCodes['Forbidden'];
  }

}

class db_UserMustBeReverified extends Error {
  constructor(...params) {
    super(...params);
    this.name = 'UserMustBeReverified';
    this.message = 'User must be reverified.';
    this.status = statusCodes['Forbidden'];
  }

}

class db_UserUnableToReceiveDatabase extends Error {
  constructor(...params) {
    super(...params);
    this.name = 'UserUnableToReceiveDatabase';
    this.message = 'User unable to receive database. User must sign in with an updated userbase-js client to be able to receive database.';
    this.status = statusCodes['Forbidden'];
  }

}

class db_VerificationMessageMissing extends Error {
  constructor(...params) {
    super(...params);
    this.name = 'VerificationMessageMissing';
    this.message = 'Verification message missing.';
    this.status = statusCodes['Bad Request'];
  }

}

class db_VerificationMessageCannotBeBlank extends Error {
  constructor(...params) {
    super(...params);
    this.name = 'VerificationMessageCannotBeBlank';
    this.message = 'Verification message cannot be blank.';
    this.status = statusCodes['Bad Request'];
  }

}

class db_VerificationMessageMustBeString extends Error {
  constructor(...params) {
    super(...params);
    this.name = 'VerificationMessageMustBeString';
    this.message = 'Verification message must be a string.';
    this.status = statusCodes['Bad Request'];
  }

}

class db_VerificationMessageInvalid extends Error {
  constructor(maxLength, ...params) {
    super(maxLength, ...params);
    this.name = 'VerificationMessageInvalid';
    this.message = 'Verification message invalid.';
    this.status = statusCodes['Bad Request'];
  }

}

class db_VerifyingSelfNotAllowed extends Error {
  constructor(maxLength, ...params) {
    super(maxLength, ...params);
    this.name = 'VerifyingSelfNotAllowed';
    this.message = 'Verifying self not allowed. Can only verify other users.';
    this.status = statusCodes['Bad Request'];
  }

}

class db_ProgressHandlerMustBeFunction extends Error {
  constructor(...params) {
    super(...params);
    this.name = 'ProgressHandlerMustBeFunction';
    this.message = 'Progress handler must be a function.';
    this.status = statusCodes['Bad Request'];
  }

}

class db_TransactionUnauthorized extends Error {
  constructor(command, ...params) {
    super(command, ...params);
    this.name = 'TransactionUnauthorized';
    this.message = "Calling '".concat(command, "' on this item is unauthorized.");
    this.status = statusCodes['Forbidden'];
  }

}

class db_WriteAccessParamNotAllowed extends Error {
  constructor(command, ...params) {
    super(command, ...params);
    this.name = 'WriteAccessParamNotAllowed';
    this.message = "Write access parameter not allowed. Only the item creator or database owner can change an item's write access settings.";
    this.status = statusCodes['Forbidden'];
  }

}

/* harmony default export */ var errors_db = ({
  DatabaseNameMissing: db_DatabaseNameMissing,
  DatabaseNameCannotBeBlank: db_DatabaseNameCannotBeBlank,
  DatabaseNameMustBeString: db_DatabaseNameMustBeString,
  DatabaseNameTooLong: db_DatabaseNameTooLong,
  DatabaseNameRestricted: db_DatabaseNameRestricted,
  DatabaseNotFound: db_DatabaseNotFound,
  DatabaseIsReadOnly: db_DatabaseIsReadOnly,
  DatabaseAlreadyOpening: db_DatabaseAlreadyOpening,
  DatabaseIdMustBeString: db_DatabaseIdMustBeString,
  DatabaseIdCannotBeBlank: db_DatabaseIdCannotBeBlank,
  DatabaseIdNotAllowed: db_DatabaseIdNotAllowed,
  DatabaseIdNotAllowedForOwnDatabase: db_DatabaseIdNotAllowedForOwnDatabase,
  DatabaseIdInvalidLength: db_DatabaseIdInvalidLength,
  ShareTokenInvalid: db_ShareTokenInvalid,
  ShareTokenNotFound: db_ShareTokenNotFound,
  ShareTokenNotAllowed: db_ShareTokenNotAllowed,
  ShareTokenNotAllowedForOwnDatabase: db_ShareTokenNotAllowedForOwnDatabase,
  ReadOnlyMustBeBoolean: db_ReadOnlyMustBeBoolean,
  ReadOnlyParamNotAllowed: db_ReadOnlyParamNotAllowed,
  ResharingAllowedMustBeBoolean: db_ResharingAllowedMustBeBoolean,
  ResharingNotAllowed: db_ResharingNotAllowed,
  ResharingWithWriteAccessNotAllowed: db_ResharingWithWriteAccessNotAllowed,
  ResharingAllowedParamNotAllowed: db_ResharingAllowedParamNotAllowed,
  SharingWithSelfNotAllowed: db_SharingWithSelfNotAllowed,
  ModifyingOwnPermissionsNotAllowed: db_ModifyingOwnPermissionsNotAllowed,
  ModifyingOwnerPermissionsNotAllowed: db_ModifyingOwnerPermissionsNotAllowed,
  ModifyingPermissionsNotAllowed: db_ModifyingPermissionsNotAllowed,
  GrantingWriteAccessNotAllowed: db_GrantingWriteAccessNotAllowed,
  RequireVerifiedMustBeBoolean: db_RequireVerifiedMustBeBoolean,
  RequireVerifiedParamNotNecessary: db_RequireVerifiedParamNotNecessary,
  RevokeMustBeBoolean: db_RevokeMustBeBoolean,
  ChangeHandlerMissing: db_ChangeHandlerMissing,
  ChangeHandlerMustBeFunction: db_ChangeHandlerMustBeFunction,
  EncryptionModeNotValid: db_EncryptionModeNotValid,
  ServerSideEncryptionNotEnabledInClient: db_ServerSideEncryptionNotEnabledInClient,
  DatabaseNotOpen: db_DatabaseNotOpen,
  ItemMissing: db_ItemMissing,
  ItemInvalid: db_ItemInvalid,
  ItemTooLarge: db_ItemTooLarge,
  ItemIdMustBeString: db_ItemIdMustBeString,
  ItemIdTooLong: db_ItemIdTooLong,
  ItemIdMissing: db_ItemIdMissing,
  ItemIdCannotBeBlank: db_ItemIdCannotBeBlank,
  ItemAlreadyExists: db_ItemAlreadyExists,
  ItemDoesNotExist: db_ItemDoesNotExist,
  ItemUpdateConflict: db_ItemUpdateConflict,
  FileMissing: db_FileMissing,
  FileMustBeFile: db_FileMustBeFile,
  FileCannotBeEmpty: db_FileCannotBeEmpty,
  FileUploadConflict: db_FileUploadConflict,
  FileNotFound: db_FileNotFound,
  FileIdMissing: db_FileIdMissing,
  FileIdMustBeString: db_FileIdMustBeString,
  FileIdCannotBeBlank: db_FileIdCannotBeBlank,
  FileIdTooLong: db_FileIdTooLong,
  RangeMustBeObject: db_RangeMustBeObject,
  RangeMissingStart: db_RangeMissingStart,
  RangeMissingEnd: db_RangeMissingEnd,
  RangeStartMustBeNumber: db_RangeStartMustBeNumber,
  RangeEndMustBeNumber: db_RangeEndMustBeNumber,
  RangeStartMustBeGreaterThanZero: db_RangeStartMustBeGreaterThanZero,
  RangeEndMustBeGreaterThanRangeStart: db_RangeEndMustBeGreaterThanRangeStart,
  RangeEndMustBeLessThanFileSize: db_RangeEndMustBeLessThanFileSize,
  OperationsMissing: db_OperationsMissing,
  OperationsMustBeArray: db_OperationsMustBeArray,
  OperationsConflict: db_OperationsConflict,
  OperationsExceedLimit: db_OperationsExceedLimit,
  CommandNotRecognized: db_CommandNotRecognized,
  UserNotVerified: db_UserNotVerified,
  UserMustBeReverified: db_UserMustBeReverified,
  UserUnableToReceiveDatabase: db_UserUnableToReceiveDatabase,
  VerificationMessageMissing: db_VerificationMessageMissing,
  VerificationMessageMustBeString: db_VerificationMessageMustBeString,
  VerificationMessageCannotBeBlank: db_VerificationMessageCannotBeBlank,
  VerificationMessageInvalid: db_VerificationMessageInvalid,
  VerifyingSelfNotAllowed: db_VerifyingSelfNotAllowed,
  ProgressHandlerMustBeFunction: db_ProgressHandlerMustBeFunction,
  TransactionUnauthorized: db_TransactionUnauthorized,
  WriteAccessParamNotAllowed: db_WriteAccessParamNotAllowed
});
// CONCATENATED MODULE: ./src/errors/config.js


class config_AppIdAlreadySet extends Error {
  constructor(appId, ...params) {
    super(appId, ...params);
    this.name = 'AppIdAlreadySet';
    this.message = 'Application ID already set.';
    this.status = statusCodes['Conflict'];
    this.appId = appId;
  }

}

class config_AppIdMustBeString extends Error {
  constructor(...params) {
    super(...params);
    this.name = 'AppIdMustBeString';
    this.message = 'Application ID must be a string.';
    this.status = statusCodes['Bad Request'];
  }

}

class config_AppIdMissing extends Error {
  constructor(...params) {
    super(...params);
    this.name = 'AppIdMissing';
    this.message = 'Application ID missing.';
    this.status = statusCodes['Bad Request'];
  }

}

class config_AppIdCannotBeBlank extends Error {
  constructor(...params) {
    super(...params);
    this.name = 'AppIdCannotBeBlank';
    this.message = 'Application ID cannot be blank.';
    this.status = statusCodes['Bad Request'];
  }

}

class config_WebCryptoUnavailable extends Error {
  constructor(...params) {
    super(...params);
    this.name = 'WebCryptoUnavailable';
    this.message = 'The WebCrypto API is unavailable. Please make sure your website uses https.';
    this.status = statusCodes['Bad Request'];
  }

}

class config_UpdateUserHandlerMustBeFunction extends Error {
  constructor(...params) {
    super(...params);
    this.name = 'UpdateUserHandlerMustBeFunction';
    this.message = 'Update user handler must be a function.';
    this.status = statusCodes['Bad Request'];
  }

}

/* harmony default export */ var config = ({
  AppIdAlreadySet: config_AppIdAlreadySet,
  AppIdMustBeString: config_AppIdMustBeString,
  AppIdMissing: config_AppIdMissing,
  AppIdCannotBeBlank: config_AppIdCannotBeBlank,
  WebCryptoUnavailable: config_WebCryptoUnavailable,
  UpdateUserHandlerMustBeFunction: config_UpdateUserHandlerMustBeFunction
});
// CONCATENATED MODULE: ./src/errors/payments.js


class payments_SuccessUrlMissing extends Error {
  constructor(...params) {
    super(...params);
    this.name = 'SuccessUrlMissing';
    this.message = 'Success url missing to let Stripe know where to redirect users on successful payment.';
    this.status = statusCodes['Bad Request'];
  }

}

class payments_SuccessUrlMustBeString extends Error {
  constructor(...params) {
    super(...params);
    this.name = 'SuccessUrlMustBeString';
    this.message = 'Success url must be a string.';
    this.status = statusCodes['Bad Request'];
  }

}

class payments_SuccessUrlInvalid extends Error {
  constructor(invalidProtocol, ...params) {
    super(invalidProtocol, ...params);
    this.name = 'SuccessUrlInvalid';
    this.message = invalidProtocol ? 'Success url must start with http or https.' : 'Success url invalid.';
    this.status = statusCodes['Bad Request'];
  }

}

class payments_CancelUrlMissing extends Error {
  constructor(...params) {
    super(...params);
    this.name = 'CancelUrlMissing';
    this.message = 'Cancel url missing to let Stripe know where to redirect users on canceled payment.';
    this.status = statusCodes['Bad Request'];
  }

}

class payments_CancelUrlMustBeString extends Error {
  constructor(...params) {
    super(...params);
    this.name = 'CancelUrlMustBeString';
    this.message = 'Cancel url must be a string.';
    this.status = statusCodes['Bad Request'];
  }

}

class payments_CancelUrlInvalid extends Error {
  constructor(invalidProtocol, ...params) {
    super(invalidProtocol, ...params);
    this.name = 'CancelUrlInvalid';
    this.message = invalidProtocol ? 'Cancel url must start with http or https.' : 'Cancel url invalid.';
    this.status = statusCodes['Bad Request'];
  }

}

class payments_StripeJsLibraryMissing extends Error {
  constructor(...params) {
    super(...params);
    this.name = 'StripeLibraryMissing';
    this.message = 'Stripe.js library missing. Be sure to include the script in your html file (https://stripe.com/docs/stripe-js#setup).';
    this.status = statusCodes['Bad Request'];
  }

}

class payments_PaymentsDisabled extends Error {
  constructor(...params) {
    super(...params);
    this.name = 'PaymentsDisabled';
    this.message = 'Payments on this app are disabled. Enable payments in the admin panel.';
    this.status = statusCodes['Forbidden'];
  }

}

class payments_PriceIdOrPlanIdAllowed extends Error {
  constructor(...params) {
    super(...params);
    this.name = 'PriceIdOrPlanIdAllowed';
    this.message = 'Only one of priceId or planId allowed.';
    this.status = statusCodes['Bad Request'];
  }

}

class payments_PriceIdOrPlanIdMissing extends Error {
  constructor(...params) {
    super(...params);
    this.name = 'PriceIdOrPlanIdMissing';
    this.message = 'Please provide a priceId or planId. You can create a product in the Stripe dashboard and find its priceId there.';
    this.status = statusCodes['Bad Request'];
  }

}

class payments_SubscriptionPlanAlreadyPurchased extends Error {
  constructor(...params) {
    super(...params);
    this.name = 'SubscriptionPlanAlreadyPurchased';
    this.message = 'Subscription plan already purchased. Cancel subscription to purchase another.';
    this.status = statusCodes['Conflict'];
  }

}

class payments_StripeAccountNotConnected extends Error {
  constructor(...params) {
    super(...params);
    this.name = 'StripeAccountNotConnected';
    this.message = 'Stripe account not connected. Connect a Stripe account in the admin panel.';
    this.status = statusCodes['Forbidden'];
  }

}

class payments_SubscriptionNotFound extends Error {
  constructor(...params) {
    super(...params);
    this.name = 'SubscriptionNotFound';
    this.message = 'Subscription not found. User must purchase a subscription.';
    this.status = statusCodes['Payment Required'];
  }

}

class payments_SubscriptionInactive extends Error {
  constructor(subscriptionStatus, ...params) {
    super(...params);
    this.name = 'SubscriptionInactive';
    this.message = "The user's subscription is inactive.";
    this.subscriptionStatus = subscriptionStatus;
    this.status = statusCodes['Payment Required'];
  }

}

class payments_SubscriptionNotPurchased extends Error {
  constructor(...params) {
    super(...params);
    this.name = 'SubscriptionNotPurchased';
    this.message = 'Subscription not purchased. User must purchase a subscription.';
    this.status = statusCodes['Payment Required'];
  }

}

class payments_SubscriptionAlreadyCanceled extends Error {
  constructor(...params) {
    super(...params);
    this.name = 'SubscriptionAlreadyCanceled';
    this.message = 'Subscription already canceled. User must purchase a new subscription.';
    this.status = statusCodes['Bad Request'];
  }

}

class payments_TrialExpired extends Error {
  constructor(...params) {
    super(...params);
    this.name = 'TrialExpired';
    this.message = 'Trial expired. User must purchase a subscription.';
    this.status = statusCodes['Payment Required'];
  }

}

class StripeError extends Error {
  constructor(error, ...params) {
    super(error, ...params);
    const {
      status,
      type,
      message
    } = error;
    this.name = 'StripeError';
    this.message = message;
    this.type = type;
    this.status = status;
  }

}

/* harmony default export */ var payments = ({
  SuccessUrlMissing: payments_SuccessUrlMissing,
  SuccessUrlMustBeString: payments_SuccessUrlMustBeString,
  SuccessUrlInvalid: payments_SuccessUrlInvalid,
  CancelUrlMissing: payments_CancelUrlMissing,
  CancelUrlMustBeString: payments_CancelUrlMustBeString,
  CancelUrlInvalid: payments_CancelUrlInvalid,
  StripeJsLibraryMissing: payments_StripeJsLibraryMissing,
  PaymentsDisabled: payments_PaymentsDisabled,
  PriceIdOrPlanIdAllowed: payments_PriceIdOrPlanIdAllowed,
  PriceIdOrPlanIdMissing: payments_PriceIdOrPlanIdMissing,
  SubscriptionPlanAlreadyPurchased: payments_SubscriptionPlanAlreadyPurchased,
  StripeAccountNotConnected: payments_StripeAccountNotConnected,
  SubscriptionNotFound: payments_SubscriptionNotFound,
  SubscriptionInactive: payments_SubscriptionInactive,
  SubscriptionNotPurchased: payments_SubscriptionNotPurchased,
  SubscriptionAlreadyCanceled: payments_SubscriptionAlreadyCanceled,
  TrialExpired: payments_TrialExpired,
  StripeError
});
// CONCATENATED MODULE: ./src/errors/index.js


function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }







class errors_AppIdNotSet extends Error {
  constructor(...params) {
    super(...params);
    this.name = 'AppIdNotSet';
    this.message = 'App ID not set yet. Make sure to configure app ID.';
    this.status = statusCodes['Bad Request'];
  }

}

class errors_ServiceUnavailable extends Error {
  constructor(...params) {
    super(...params);
    this.name = 'ServiceUnavailable';
    this.message = 'Service unavailable.';
    this.status = statusCodes['Service Unavailable'];
  }

}

class errors_InternalServerError extends errors_ServiceUnavailable {
  constructor(...params) {
    super(...params);
    this.status = statusCodes['Internal Server Error'];
  }

}

class errors_Timeout extends errors_ServiceUnavailable {
  constructor(...params) {
    super(...params);
    this.status = statusCodes['Gateway Timeout'];
  }

}

class Reconnecting extends errors_ServiceUnavailable {
  constructor(...params) {
    super(...params);
    this.message = 'Reconnecting.';
  }

}

class UnknownServiceUnavailable extends errors_ServiceUnavailable {
  constructor(e, ...params) {
    super(e, ...params);
    console.error('Userbase error. Please report this to support@userbase.com.\n\n', e);
  }

}

class errors_ParamsMustBeObject extends Error {
  constructor(...params) {
    super(...params);
    this.name = 'ParamsMustBeObject';
    this.message = 'Parameters passed to function must be placed inside an object.';
    this.status = statusCodes['Bad Request'];
  }

}

class errors_TooManyRequests extends Error {
  constructor(retryDelay, ...params) {
    super(retryDelay, ...params);
    const retryDelaySeconds = Math.floor(retryDelay / 1000);
    this.name = 'TooManyRequests';
    this.message = "Too many requests in a row. Please try again in ".concat(retryDelaySeconds, " second").concat(retryDelaySeconds !== 1 ? 's' : '', ".");
    this.status = statusCodes['Too Many Requests'];
  }

}

/* harmony default export */ var errors = (_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread({}, auth), errors_db), config), payments), {}, {
  AppIdNotSet: errors_AppIdNotSet,
  InternalServerError: errors_InternalServerError,
  ServiceUnavailable: errors_ServiceUnavailable,
  Timeout: errors_Timeout,
  Reconnecting,
  UnknownServiceUnavailable,
  ParamsMustBeObject: errors_ParamsMustBeObject,
  TooManyRequests: errors_TooManyRequests
}));
// CONCATENATED MODULE: ./src/config.js

const USERBASE_JS_VERSION = '2.8.0';
const VERSION = '/v1';
const DEFAULT_ENDPOINT = 'https://v1.userbase.com' + VERSION;
const STRIPE_PRODUCTION_PUBLISHABLE_KEY = 'pk_live_jI6lbsAIQlu2u4uTkDXFrSEW';
const STRIPE_TEST_PUBLISHABLE_KEY = 'pk_test_rYANrLdNfdJXJ2d808wW4pqY';
let userbaseAppId = null;
let userbaseUpdateUserHandler = null;
let userbaseAllowServerSideEncryptionMode = false;

const getAppId = () => {
  if (!userbaseAppId) throw new errors.AppIdNotSet();
  return userbaseAppId;
};

const getUpdateUserHandler = () => userbaseUpdateUserHandler;

const getEndpoint = () => {
  return window._userbaseEndpoint || DEFAULT_ENDPOINT;
};

const configure = ({
  appId,
  updateUserHandler,
  allowServerSideEncryption
}) => {
  if (userbaseAppId && userbaseAppId !== appId) throw new errors.AppIdAlreadySet(userbaseAppId);
  userbaseAppId = appId;
  userbaseUpdateUserHandler = updateUserHandler;
  userbaseAllowServerSideEncryptionMode = allowServerSideEncryption;
};

const getStripePublishableKey = isProduction => {
  return isProduction ? window._USERBASE_STRIPE_PRODUCTION_PUBLISHABLE_KEY || STRIPE_PRODUCTION_PUBLISHABLE_KEY : window._USERBASE_STRIPE_TEST_PUBLISHABLE_KEY || STRIPE_TEST_PUBLISHABLE_KEY;
};

const isServerSideEncryptionModeAllowed = () => userbaseAllowServerSideEncryptionMode;

/* harmony default export */ var src_config = ({
  USERBASE_JS_VERSION,
  getAppId,
  getUpdateUserHandler,
  getEndpoint,
  configure,
  getStripePublishableKey,
  isServerSideEncryptionModeAllowed
});
// CONCATENATED MODULE: ./src/api/utils.js

const TEN_SECONDS_MS = 10 * 1000;

class RequestError extends Error {
  constructor(data, status, statusText, ...params) {
    super(data, status, statusText, ...params);
    this.response = {
      data,
      status,
      statusText
    };
    this.message = 'Request failed with status code ' + status;
  }

}

class TimeoutError extends Error {
  constructor(timeout, ...params) {
    super(timeout, ...params);
    this.message = "timeout of ".concat(timeout, "ms exceeded");
  }

}

const handleResponse = (xhr, resolve, reject) => {
  let response;

  try {
    response = JSON.parse(xhr.response);
  } catch (_unused) {
    response = xhr.response;
  }

  if (xhr.status >= 200 && xhr.status < 300) {
    resolve(response);
  } else {
    reject(new RequestError(response, xhr.status, xhr.statusText));
  }
};

const processXhr = (xhr, resolve, reject, timeout = TEN_SECONDS_MS) => {
  xhr.timeout = timeout;

  xhr.onload = () => handleResponse(xhr, resolve, reject);

  xhr.onerror = () => reject(new errors.ServiceUnavailable());

  xhr.ontimeout = () => reject(new TimeoutError(timeout));
};
// CONCATENATED MODULE: ./src/api/auth.js



const signUp = (username, passwordToken, ecKeyData, passwordSalts, keySalts, email, profile, passwordBasedBackup, sessionLength) => {
  return new Promise((resolve, reject) => {
    const xhr = new XMLHttpRequest();
    const method = 'POST';
    const url = "".concat(src_config.getEndpoint(), "/api/auth/sign-up?appId=").concat(src_config.getAppId(), "&userbaseJsVersion=").concat(src_config.USERBASE_JS_VERSION);
    const data = JSON.stringify({
      username,
      passwordToken,
      ecKeyData,
      passwordSalts,
      keySalts,
      email,
      profile,
      passwordBasedBackup,
      sessionLength
    });
    xhr.open(method, url);
    xhr.setRequestHeader('Content-Type', 'application/json');
    xhr.send(data);
    processXhr(xhr, resolve, reject);
  });
};

const getPasswordSalts = username => {
  return new Promise((resolve, reject) => {
    const xhr = new XMLHttpRequest();
    const method = 'GET';
    const url = "".concat(src_config.getEndpoint(), "/api/auth/get-password-salts?appId=").concat(src_config.getAppId(), "&username=").concat(encodeURIComponent(username), "&userbaseJsVersion=").concat(src_config.USERBASE_JS_VERSION);
    xhr.open(method, url);
    xhr.send();
    processXhr(xhr, resolve, reject);
  });
};

const signIn = async (username, passwordToken, sessionLength) => {
  return new Promise((resolve, reject) => {
    const xhr = new XMLHttpRequest();
    const method = 'POST';
    const url = "".concat(src_config.getEndpoint(), "/api/auth/sign-in?appId=").concat(src_config.getAppId(), "&userbaseJsVersion=").concat(src_config.USERBASE_JS_VERSION);
    const data = JSON.stringify({
      username,
      passwordToken,
      sessionLength
    });
    xhr.open(method, url);
    xhr.setRequestHeader('Content-Type', 'application/json');
    xhr.send(data);
    processXhr(xhr, resolve, reject);
  });
};

const signInWithSession = (sessionId, sessionLength) => {
  return new Promise((resolve, reject) => {
    const xhr = new XMLHttpRequest();
    const method = 'POST';
    const url = "".concat(src_config.getEndpoint(), "/api/auth/sign-in-with-session?appId=").concat(src_config.getAppId(), "&sessionId=").concat(sessionId, "&userbaseJsVersion=").concat(src_config.USERBASE_JS_VERSION);
    const data = JSON.stringify({
      sessionLength
    });
    xhr.open(method, url);
    xhr.setRequestHeader('Content-Type', 'application/json');
    xhr.send(data);
    processXhr(xhr, resolve, reject);
  });
};

const getServerPublicKey = async () => {
  return new Promise((resolve, reject) => {
    const xhr = new XMLHttpRequest();
    const method = 'GET';
    const url = "".concat(src_config.getEndpoint(), "/api/auth/server-public-key?&userbaseJsVersion=").concat(src_config.USERBASE_JS_VERSION);
    const responseType = 'arraybuffer';
    xhr.open(method, url);
    xhr.responseType = responseType;
    xhr.send();
    processXhr(xhr, resolve, reject);
  });
};

const getPublicKey = username => {
  return new Promise((resolve, reject) => {
    const xhr = new XMLHttpRequest();
    const method = 'GET';
    const url = "".concat(src_config.getEndpoint(), "/api/public-key?appId=").concat(src_config.getAppId(), "&username=").concat(encodeURIComponent(username), "&userbaseJsVersion=").concat(src_config.USERBASE_JS_VERSION);
    xhr.open(method, url);
    xhr.send();
    processXhr(xhr, resolve, reject);
  });
};

const uploadBundleChunk = async (chunk, token) => {
  return new Promise((resolve, reject) => {
    const xhr = new XMLHttpRequest();
    const method = 'POST';
    const url = "".concat(src_config.getEndpoint(), "/api/bundle-chunk?userbaseJsVersion=").concat(src_config.USERBASE_JS_VERSION);
    xhr.setRequestHeader('Authorization', 'Bearer ' + token);
    xhr.open(method, url);
    xhr.send(chunk);
    processXhr(xhr, resolve, reject);
  });
};

/* harmony default export */ var api_auth = ({
  signUp,
  getPasswordSalts,
  signIn,
  signInWithSession,
  getServerPublicKey,
  getPublicKey,
  uploadBundleChunk
});
// EXTERNAL MODULE: external "uuid/v4"
var v4_ = __webpack_require__(2);
var v4_default = /*#__PURE__*/__webpack_require__.n(v4_);

// CONCATENATED MODULE: ./src/localData.js


function localData_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function localData_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { localData_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { localData_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

const tryCatchWrapper = func => (...args) => {
  try {
    return func(...args);
  } catch (e) {
    // ok to swallow error
    //
    // local/sessionStorage are non-critical benefits. If they happen to be available,
    // they're helpful, but if not, the SDK functions totally fine.
    //
    // If a function fails, behavior is functionally the same as if rememberMe is 'none'.
    console.warn('Error accessing browser storage. Defaulting to memory.\n\n', e);
  }
};

const _getSeedName = (appId, username) => "userbaseSeed.".concat(appId, ".").concat(username);

const setCurrentSession = tryCatchWrapper((rememberMe, username, signedIn, sessionId, creationDate, expirationDate) => {
  const session = {
    username,
    signedIn,
    sessionId,
    creationDate,
    expirationDate
  };
  const sessionString = JSON.stringify(session);

  if (rememberMe === 'local') {
    localStorage.setItem('userbaseCurrentSession', sessionString);
  } else if (rememberMe === 'session') {
    sessionStorage.setItem('userbaseCurrentSession', sessionString);
  }
});
const getCurrentSession = tryCatchWrapper(() => {
  const sessionStorageCurrentSessionString = sessionStorage.getItem('userbaseCurrentSession');

  if (sessionStorageCurrentSessionString) {
    const currentSession = JSON.parse(sessionStorageCurrentSessionString);

    if (!currentSession.signedIn) {
      const localCurrentSessionString = localStorage.getItem('userbaseCurrentSession');

      if (localCurrentSessionString) {
        const localCurrentSession = JSON.parse(localCurrentSessionString); // allows session from localStorage to override sessionStorage if signed in
        // to localStorage session and not signed in to sessionStorage session

        if (localCurrentSession.signedIn) {
          return localData_objectSpread(localData_objectSpread({}, localCurrentSession), {}, {
            rememberMe: 'local'
          });
        }
      }
    }

    return localData_objectSpread(localData_objectSpread({}, JSON.parse(sessionStorageCurrentSessionString)), {}, {
      rememberMe: 'session'
    });
  }

  const localSessionString = localStorage.getItem('userbaseCurrentSession');
  return localSessionString && localData_objectSpread(localData_objectSpread({}, JSON.parse(localSessionString)), {}, {
    rememberMe: 'local'
  });
});
const saveSeedString = tryCatchWrapper((rememberMe, appId, username, seedString) => {
  if (rememberMe === 'local') {
    localStorage.setItem(_getSeedName(appId, username), seedString);
  } else if (rememberMe === 'session') {
    sessionStorage.setItem(_getSeedName(appId, username), seedString);
  }
});
const removeSeedString = tryCatchWrapper((appId, username) => {
  const seedName = _getSeedName(appId, username);

  sessionStorage.removeItem(seedName);
  localStorage.removeItem(seedName);
});
const getSeedString = tryCatchWrapper((appId, username) => {
  const seedName = _getSeedName(appId, username);

  return sessionStorage.getItem(seedName) || localStorage.getItem(seedName);
});

const signInSession = (rememberMe, username, sessionId, creationDate, expirationDate) => {
  const signedIn = true;
  setCurrentSession(rememberMe, username, signedIn, sessionId, creationDate, expirationDate);
};

const signOutSession = (rememberMe, username) => {
  const signedIn = false;
  setCurrentSession(rememberMe, username, signedIn);
};

const removeCurrentSession = tryCatchWrapper(() => {
  sessionStorage.removeItem('userbaseCurrentSession');
  localStorage.removeItem('userbaseCurrentSession');
});
/* harmony default export */ var localData = ({
  signInSession,
  signOutSession,
  getCurrentSession,
  saveSeedString,
  removeSeedString,
  getSeedString,
  removeCurrentSession
});
// CONCATENATED MODULE: ./src/Crypto/utils.js
const ONE_KB = 1024;
const TEN_KB = 10 * ONE_KB; // https://stackoverflow.com/a/20604561/11601853

const arrayBufferToString = (buf, minified) => {
  const bufView = minified ? new Uint8Array(buf) : new Uint16Array(buf);
  const length = bufView.length;
  let result = '';
  let chunkSize = TEN_KB; // using chunks prevents stack from blowing up

  for (var i = 0; i < length; i += chunkSize) {
    if (i + chunkSize > length) {
      chunkSize = length - i;
    }

    const chunk = bufView.subarray(i, i + chunkSize);
    result += String.fromCharCode.apply(null, chunk);
  }

  return result;
}; // https://developers.google.com/web/updates/2012/06/How-to-convert-ArrayBuffer-to-and-from-String

const stringToArrayBuffer = (str, minified = false) => {
  let buf = new ArrayBuffer(str.length * (minified ? 1 : 2)); // 2 bytes for each char, unless using minified. minified only safe for known input

  let bufView = minified ? new Uint8Array(buf) : new Uint16Array(buf);

  for (let i = 0, strLen = str.length; i < strLen; i++) {
    bufView[i] = str.charCodeAt(i);
  }

  return buf;
};
/**
* Creates a new Uint8Array based on two different ArrayBuffers
*
* Source: https://gist.github.com/72lions/4528834
*
* @param {ArrayBuffers} buffer1 The first buffer.
* @param {ArrayBuffers} buffer2 The second buffer.
* @return {ArrayBuffers} The new ArrayBuffer created out of the two.
*
*/

const appendBuffer = (buffer1, buffer2) => {
  const tmp = new Uint8Array(buffer1.byteLength + buffer2.byteLength);
  tmp.set(new Uint8Array(buffer1), 0);
  tmp.set(new Uint8Array(buffer2), buffer1.byteLength);
  return tmp.buffer;
};
const appendBuffers = buffers => {
  const bufferByteLengths = buffers.map(buffer => buffer.byteLength);
  const totalByteLength = bufferByteLengths.reduce((byteLengthSum, bufferByteLength) => byteLengthSum + bufferByteLength);
  const tmp = new Uint8Array(totalByteLength);
  let currentByteLength = 0;

  for (let i = 0; i < buffers.length; i++) {
    tmp.set(new Uint8Array(buffers[i]), currentByteLength);
    currentByteLength += bufferByteLengths[i];
  }

  return {
    buffer: tmp.buffer,
    byteLengths: bufferByteLengths
  };
};
const hexStringToArrayBuffer = hexString => {
  if (hexString.length % 2 !== 0) throw new Error('Hex string must be even length');
  const halfHexStringLen = hexString.length / 2;
  const array = [];

  for (let i = 0; i < halfHexStringLen; i++) {
    const byteStartIndex = i * 2;
    const byte = hexString.substring(byteStartIndex, byteStartIndex + 2);
    const byteAsInt = parseInt(byte, 16);
    array.push(byteAsInt);
  }

  return new Uint8Array(array);
};
// CONCATENATED MODULE: ./src/Crypto/sha-256.js


const BYTE_SIZE = 32; // 256 / 8

const HASH_ALGORITHM_NAME = 'SHA-256';
/**
 *
 * @param {ArrayBuffer} data
 */

const hash = async data => {
  const result = await window.crypto.subtle.digest({
    name: HASH_ALGORITHM_NAME
  }, data);
  return result;
};

const hashBase64String = async dataString => {
  const data = external_base64_arraybuffer_default.a.decode(dataString);
  const result = await hash(data);
  return external_base64_arraybuffer_default.a.encode(result);
};

const hashString = async dataString => {
  const data = stringToArrayBuffer(dataString);
  const result = await hash(data);
  return external_base64_arraybuffer_default.a.encode(result);
};

/* harmony default export */ var sha_256 = ({
  BYTE_SIZE,
  HASH_ALGORITHM_NAME,
  hash,
  hashBase64String,
  hashString
});
// CONCATENATED MODULE: ./src/Crypto/hkdf.js



const HKDF_ALGORITHM_NAME = 'HKDF';
const RAW_KEY_TYPE = 'raw';
const KEY_IS_NOT_EXTRACTABLE = false;
const KEY_WILL_BE_USED_TO = ['deriveKey', 'deriveBits'];

const importHkdfKeyFromString = async seedString => {
  const seed = stringToArrayBuffer(seedString);
  const hkdfKey = await importHkdfKey(seed);
  return hkdfKey;
};

const importHkdfKey = async seed => {
  const hkdfKey = await window.crypto.subtle.importKey(RAW_KEY_TYPE, seed, {
    name: HKDF_ALGORITHM_NAME
  }, KEY_IS_NOT_EXTRACTABLE, KEY_WILL_BE_USED_TO);
  return hkdfKey;
};
/**
 *  RFC 5869:
 *
 *  "the use of salt adds significantly to the strength of HKDF...
 *  Ideally, the salt value is a random (or pseudorandom) string of the
 *  length HashLen"
 *
 *  https://tools.ietf.org/html/rfc5869#section-3.1
 *
 **/


const SALT_BYTE_SIZE = sha_256.BYTE_SIZE;

const generateSalt = () => window.crypto.getRandomValues(new Uint8Array(SALT_BYTE_SIZE));

const getParams = (keyName, salt) => ({
  name: HKDF_ALGORITHM_NAME,
  info: stringToArrayBuffer(keyName),
  hash: sha_256.HASH_ALGORITHM_NAME,
  salt
});

const PASSWORD_TOKEN_NAME = 'password-token';
const PASSWORD_TOKEN_NUM_BITS = 256;

const getPasswordToken = async (hkdfKey, salt) => {
  const passwordTokenBits = await window.crypto.subtle.deriveBits(getParams(PASSWORD_TOKEN_NAME, salt), hkdfKey, PASSWORD_TOKEN_NUM_BITS);
  return external_base64_arraybuffer_default.a.encode(passwordTokenBits);
};

/* harmony default export */ var hkdf = ({
  importHkdfKeyFromString,
  importHkdfKey,
  generateSalt,
  getParams,
  getPasswordToken
});
// CONCATENATED MODULE: ./src/Crypto/aes-gcm.js



const ENCRYPTION_ALGORITHM_NAME = 'AES-GCM';
const BIT_SIZE = 256;
const KEY_IS_EXTRACTABLE = true;
const aes_gcm_KEY_WILL_BE_USED_TO = ['encrypt', 'decrypt'];
const aes_gcm_RAW_KEY_TYPE = 'raw';
const ENCRYPTION_KEY_NAME = 'encryption';
const PASSWORD_BASED_ENCRYPTION_KEY = 'password-based-encryption';
/**
 * NIST recommendation:
 *
 * "For  IVs,  it  is  recommended  that  implementations  restrict  support  to
 * the  length  of  96  bits,  to  promote interoperability, efficiency, and
 * simplicity of design."
 *
 * Pg. 8
 * https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-38d.pdf
 *
 **/

const RECOMMENDED_IV_BYTE_SIZE = 12; // 96 / 8

/**
 * Source on tag length:
 * https://crypto.stackexchange.com/questions/26783/ciphertext-and-tag-size-and-iv-transmission-with-aes-in-gcm-mode/26787
 */

const RECOMMENDED_AUTHENTICATION_TAG_LENGTH = 128;

const windowOrSelfObject = () => {
  return typeof window !== 'undefined' ? window : self;
};

const getEncryptionKeyParams = () => ({
  name: ENCRYPTION_ALGORITHM_NAME,
  length: BIT_SIZE
});

const getCiphertextParams = iv => ({
  name: ENCRYPTION_ALGORITHM_NAME,
  tagLength: RECOMMENDED_AUTHENTICATION_TAG_LENGTH,
  iv
});

const generateIv = () => window.crypto.getRandomValues(new Uint8Array(RECOMMENDED_IV_BYTE_SIZE));

const sliceEncryptedArrayBuffer = encryptedArrayBuffer => {
  const ivStartIndex = encryptedArrayBuffer.byteLength - RECOMMENDED_IV_BYTE_SIZE;
  const ciphertextArrayBuffer = encryptedArrayBuffer.slice(0, ivStartIndex);
  const iv = encryptedArrayBuffer.slice(ivStartIndex);
  return {
    ciphertextArrayBuffer,
    iv
  };
};

const importKeyFromMaster = async (masterKey, salt, encryptionKeyName = ENCRYPTION_KEY_NAME) => {
  const encryptionKey = await window.crypto.subtle.deriveKey(hkdf.getParams(encryptionKeyName, salt), masterKey, getEncryptionKeyParams(), KEY_IS_EXTRACTABLE, aes_gcm_KEY_WILL_BE_USED_TO);
  return encryptionKey;
};

const generateKey = async () => {
  const key = await window.crypto.subtle.generateKey(getEncryptionKeyParams(), KEY_IS_EXTRACTABLE, aes_gcm_KEY_WILL_BE_USED_TO);
  return key;
};

const getKeyStringFromKey = async key => {
  const rawKey = await window.crypto.subtle.exportKey(aes_gcm_RAW_KEY_TYPE, key);
  const keyString = external_base64_arraybuffer_default.a.encode(rawKey);
  return keyString;
};

const getKeyFromKeyString = async keyString => {
  const rawKey = external_base64_arraybuffer_default.a.decode(keyString);
  const key = await getKeyFromRawKey(rawKey);
  return key;
};

const getKeyFromRawKey = async rawKey => {
  const key = await windowOrSelfObject().crypto.subtle.importKey(aes_gcm_RAW_KEY_TYPE, rawKey, {
    name: ENCRYPTION_ALGORITHM_NAME
  }, KEY_IS_EXTRACTABLE, aes_gcm_KEY_WILL_BE_USED_TO);
  return key;
};

const getRawKeyFromKey = async key => {
  const rawKey = await windowOrSelfObject().crypto.subtle.exportKey(aes_gcm_RAW_KEY_TYPE, key);
  return rawKey;
};
/**
 *
 * @param {CryptoKey} key
 * @param {ArrayBuffer} plaintext
 * @returns {ArrayBuffer} encrypted Array Buffer
 *
 *     encrypted is a concatentation of Array Buffers [ciphertext, auth tag, IV]
 *
 *     The Authentication Tag is a hash of the plaintext to ensure the same data that
 *     is ecncrypted is the resulting data when decrypted. Note that the browser crypto
 *     library's result is the concatenation of Array Buffers [ciphertext, auth tag]
 *
 *     The IV is a random intialization vector that prevents an attacker
 *     from determining a user's key. It can be exposed alongside the ciphertext safely.
 *
 */


const encrypt = async (key, plaintext) => {
  const iv = generateIv(); // this result is the concatenation of Array Buffers [ciphertext, auth tag]

  const ciphertextArrayBuffer = await windowOrSelfObject().crypto.subtle.encrypt(getCiphertextParams(iv), key, plaintext);
  return appendBuffer(ciphertextArrayBuffer, iv);
};

const encryptJson = async (key, plaintextJson) => {
  const plaintextString = JSON.stringify(plaintextJson);
  const encrypted = await encryptString(key, plaintextString);
  return encrypted;
};

const encryptString = async (key, plaintextString) => {
  const plaintextArrayBuffer = stringToArrayBuffer(plaintextString);
  const encrypted = await encrypt(key, plaintextArrayBuffer);
  return external_base64_arraybuffer_default.a.encode(encrypted);
};
/**
 *
 * @param {CryptoKey} key
 * @param {ArrayBuffer} encrypted - the encrypted Array Buffer
 * @returns {object} plaintext
 */


const decrypt = async (key, encrypted) => {
  const {
    ciphertextArrayBuffer,
    iv
  } = sliceEncryptedArrayBuffer(encrypted);
  const plaintextArrayBuffer = await windowOrSelfObject().crypto.subtle.decrypt(getCiphertextParams(iv), key, ciphertextArrayBuffer);
  return plaintextArrayBuffer;
};

const decryptJson = async (key, encryptedJsonString) => {
  const plaintextString = await decryptString(key, encryptedJsonString);
  return JSON.parse(plaintextString);
};

const decryptString = async (key, encryptedString) => {
  const encryptedArrayBuffer = external_base64_arraybuffer_default.a.decode(encryptedString);
  const plaintextArrayBuffer = await decrypt(key, encryptedArrayBuffer);
  const plaintextString = arrayBufferToString(plaintextArrayBuffer);
  return plaintextString;
};

const getPasswordBasedEncryptionKey = async (hkdfKey, salt) => {
  const encryptionKey = await window.crypto.subtle.deriveKey(hkdf.getParams(PASSWORD_BASED_ENCRYPTION_KEY, salt), hkdfKey, getEncryptionKeyParams(), !KEY_IS_EXTRACTABLE, aes_gcm_KEY_WILL_BE_USED_TO);
  return encryptionKey;
};

const generateAndEncryptKeyEncryptionKey = async key => {
  const keyEncryptionKey = await generateKey();
  const keyEncryptionKeyRaw = await getRawKeyFromKey(keyEncryptionKey);
  const encryptedKeyEncryptionKey = await encrypt(key, keyEncryptionKeyRaw);
  return [keyEncryptionKey, encryptedKeyEncryptionKey];
};

/* harmony default export */ var aes_gcm = ({
  getEncryptionKeyParams,
  getCiphertextParams,
  generateIv,
  sliceEncryptedArrayBuffer,
  importKeyFromMaster,
  generateKey,
  getKeyStringFromKey,
  getKeyFromKeyString,
  getRawKeyFromKey,
  getKeyFromRawKey,
  encrypt,
  encryptJson,
  encryptString,
  decrypt,
  decryptJson,
  decryptString,
  getPasswordBasedEncryptionKey,
  generateAndEncryptKeyEncryptionKey,
  RAW_KEY_TYPE: aes_gcm_RAW_KEY_TYPE,
  KEY_WILL_BE_USED_TO: aes_gcm_KEY_WILL_BE_USED_TO
});
// EXTERNAL MODULE: external "diffie-hellman"
var external_diffie_hellman_ = __webpack_require__(3);
var external_diffie_hellman_default = /*#__PURE__*/__webpack_require__.n(external_diffie_hellman_);

// CONCATENATED MODULE: ./src/Crypto/diffie-hellman.js






const diffie_hellman_KEY_IS_EXTRACTABLE = true;
const diffie_hellman_KEY_WILL_BE_USED_TO = ['encrypt']; // unused

const DIFFIE_HELLMAN_KEY_NAME = 'diffie-hellman'; // RFC 3526 detailing publicly known 2048 bit safe prime: https://www.ietf.org/rfc/rfc3526.txt

const PRIME = hexStringToArrayBuffer('ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aacaa68ffffffffffffffff');
const GENERATOR = [2]; // get public key from the server to allow developers to easily swap out default server with their own
// server running userbase-server

let serverPublicKey = null;

const diffie_hellman_getServerPublicKey = async () => {
  if (serverPublicKey) {
    return serverPublicKey;
  } else {
    serverPublicKey = await api_auth.getServerPublicKey(); // eslint-disable-line require-atomic-updates

    return serverPublicKey;
  }
};

const setPrivateKeyAndGenerateKeys = (diffieHellman, privateKey) => {
  diffieHellman.setPrivateKey(privateKey);
  diffieHellman.generateKeys();
  return diffieHellman;
};

const createDiffieHellman = privateKey => {
  const diffieHellman = external_diffie_hellman_default.a.createDiffieHellman(PRIME, GENERATOR);
  return setPrivateKeyAndGenerateKeys(diffieHellman, privateKey);
};

const getSharedKey = async (privateKey, otherPublicKey) => {
  const diffieHellman = createDiffieHellman(privateKey);
  const sharedSecret = diffieHellman.computeSecret(otherPublicKey);
  const sharedRawKey = await sha_256.hash(sharedSecret);
  const sharedKey = await aes_gcm.getKeyFromRawKey(sharedRawKey);
  return sharedKey;
};

const diffie_hellman_getPublicKey = privateKey => {
  const diffieHellman = createDiffieHellman(privateKey);
  return diffieHellman.getPublicKey();
};

const getSharedKeyWithServer = async privateKey => {
  const sharedKey = await getSharedKey(privateKey, new Uint8Array(await diffie_hellman_getServerPublicKey()));
  return sharedKey;
};

const diffie_hellman_importKeyFromMaster = async (masterKey, salt) => {
  const privateKey = await window.crypto.subtle.deriveKey(hkdf.getParams(DIFFIE_HELLMAN_KEY_NAME, salt), masterKey, aes_gcm.getEncryptionKeyParams(), // DH not supported, using raw AES key as secret instead
  diffie_hellman_KEY_IS_EXTRACTABLE, diffie_hellman_KEY_WILL_BE_USED_TO);
  const rawPrivateKey = await aes_gcm.getRawKeyFromKey(privateKey);
  return rawPrivateKey;
};

/* harmony default export */ var diffie_hellman = ({
  getPublicKey: diffie_hellman_getPublicKey,
  getSharedKey,
  getSharedKeyWithServer,
  importKeyFromMaster: diffie_hellman_importKeyFromMaster
});
// CONCATENATED MODULE: ./src/Crypto/ecdsa.js





const ECDSA_ALGORITHM_NAME = 'ECDSA';
const ecdsa_KEY_IS_EXTRACTABLE = true;
const KEY_PAIR_WILL_BE_USED_TO = ['sign', 'verify'];
const PRIVATE_KEY_WILL_BE_USED_TO = ['sign'];
const PRIVATE_KEY_TYPE = 'jwk'; // pkcs8 not supported in firefox, must use jwk

const PUBLIC_KEY_WILL_BE_USED_TO = ['verify'];
const PUBLIC_KEY_TYPE = 'spki';
const ECDSA_KEY_ENCRYPTION_KEY = 'ecdsa-key-encryption-key';
/**
 * NIST recommendation:
 *
 * 128-bit security provided with 256-bit key size
 *
 * Pg. 55
 * https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-57pt1r5.pdf
 *
 **/

const NAMED_CURVE = 'P-256';
const ECDSA_PARAMS = {
  name: ECDSA_ALGORITHM_NAME,
  namedCurve: NAMED_CURVE
};
const ECDSA_SIGNING_PARAMS = {
  name: ECDSA_ALGORITHM_NAME,
  hash: {
    name: sha_256.HASH_ALGORITHM_NAME
  }
};

const generateKeyPair = async () => {
  const keyPair = await window.crypto.subtle.generateKey(ECDSA_PARAMS, ecdsa_KEY_IS_EXTRACTABLE, KEY_PAIR_WILL_BE_USED_TO);
  return keyPair;
};

const getRawPrivateKeyFromPrivateKey = async privateKey => {
  const jwkPrivateKey = await window.crypto.subtle.exportKey(PRIVATE_KEY_TYPE, privateKey);
  const rawPrivateKey = stringToArrayBuffer(JSON.stringify(jwkPrivateKey));
  return rawPrivateKey;
};

const getPrivateKeyFromRawPrivateKey = async rawPrivateKey => {
  const jwkPrivateKey = JSON.parse(arrayBufferToString(rawPrivateKey));
  const privateKey = await window.crypto.subtle.importKey(PRIVATE_KEY_TYPE, jwkPrivateKey, ECDSA_PARAMS, ecdsa_KEY_IS_EXTRACTABLE, PRIVATE_KEY_WILL_BE_USED_TO);
  return privateKey;
};

const getPublicKeyFromRawPublicKey = async rawPublicKey => {
  const publicKey = await window.crypto.subtle.importKey(PUBLIC_KEY_TYPE, rawPublicKey, ECDSA_PARAMS, ecdsa_KEY_IS_EXTRACTABLE, PUBLIC_KEY_WILL_BE_USED_TO);
  return publicKey;
};

const getRawPublicKeyFromPublicKey = async publicKey => {
  const rawPublicKey = await window.crypto.subtle.exportKey(PUBLIC_KEY_TYPE, publicKey);
  return rawPublicKey;
};

const getPublicKeyStringFromPublicKey = async publicKey => {
  const rawPublicKey = await getRawPublicKeyFromPublicKey(publicKey);
  const publicKeyString = external_base64_arraybuffer_default.a.encode(rawPublicKey);
  return publicKeyString;
};

const getPublicKeyFromPrivateKey = async privateKey => {
  const jwkPrivateKey = await window.crypto.subtle.exportKey('jwk', privateKey); // delete private key data

  delete jwkPrivateKey.d; // set public key key_ops to enable import as public key

  jwkPrivateKey.key_ops = PUBLIC_KEY_WILL_BE_USED_TO;
  const publicKey = await window.crypto.subtle.importKey('jwk', jwkPrivateKey, // technically this now has same values as the public key would
  ECDSA_PARAMS, ecdsa_KEY_IS_EXTRACTABLE, PUBLIC_KEY_WILL_BE_USED_TO);
  return publicKey;
};

const importEcdsaKeyEncryptionKeyFromMaster = async (masterKey, salt) => {
  const keyEncryptionKey = await aes_gcm.importKeyFromMaster(masterKey, salt, ECDSA_KEY_ENCRYPTION_KEY);
  return keyEncryptionKey;
};

const generateEcdsaKeyData = async masterKey => {
  // need to generate new key pair because cannot derive ECDSA key pair using HKDF in WebCrypto
  const ecdsaKeyPair = await generateKeyPair(); // derive a key encryption key using HKDF to encrypt the ECDSA private key and store it on server

  const ecdsaKeyEncryptionKeySalt = hkdf.generateSalt();
  const ecdsaKeyEncryptionKey = await importEcdsaKeyEncryptionKeyFromMaster(masterKey, ecdsaKeyEncryptionKeySalt);
  const ecdsaRawPrivateKey = await getRawPrivateKeyFromPrivateKey(ecdsaKeyPair.privateKey);
  const encryptedEcdsaPrivateKey = await aes_gcm.encrypt(ecdsaKeyEncryptionKey, ecdsaRawPrivateKey);
  return {
    ecdsaPrivateKey: ecdsaKeyPair.privateKey,
    ecdsaPublicKey: await getPublicKeyStringFromPublicKey(ecdsaKeyPair.publicKey),
    encryptedEcdsaPrivateKey: external_base64_arraybuffer_default.a.encode(encryptedEcdsaPrivateKey),
    ecdsaKeyEncryptionKeySalt: external_base64_arraybuffer_default.a.encode(ecdsaKeyEncryptionKeySalt)
  };
};

const sign = async (privateKey, data) => {
  const signature = await window.crypto.subtle.sign(ECDSA_SIGNING_PARAMS, privateKey, data);
  return signature;
};

const signString = async (privateKey, dataString) => {
  const data = stringToArrayBuffer(dataString);
  const signature = await sign(privateKey, data);
  const signatureString = external_base64_arraybuffer_default.a.encode(signature);
  return signatureString;
};

const verify = async (publicKey, signature, data) => {
  const isVerified = await window.crypto.subtle.verify(ECDSA_SIGNING_PARAMS, publicKey, signature, data);
  return isVerified;
};

const verifyString = async (publicKey, signatureString, dataString) => {
  const data = stringToArrayBuffer(dataString);
  const signature = external_base64_arraybuffer_default.a.decode(signatureString);
  const isVerified = await verify(publicKey, signature, data);
  return isVerified;
};

/* harmony default export */ var ecdsa = ({
  generateEcdsaKeyData,
  importEcdsaKeyEncryptionKeyFromMaster,
  getPrivateKeyFromRawPrivateKey,
  getPublicKeyFromRawPublicKey,
  getRawPublicKeyFromPublicKey,
  getPublicKeyStringFromPublicKey,
  getPublicKeyFromPrivateKey,
  sign,
  signString,
  verify,
  verifyString
});
// CONCATENATED MODULE: ./src/Crypto/ecdh.js





const ECDH_ALGORITHM_NAME = 'ECDH';
const ecdh_KEY_IS_EXTRACTABLE = true;
const ecdh_KEY_WILL_BE_USED_TO = ['deriveKey', 'deriveBits'];
const ecdh_PRIVATE_KEY_TYPE = 'jwk'; // pkcs8 not supported in firefox, must use jwk

const ecdh_PUBLIC_KEY_TYPE = 'spki';
const ECDH_KEY_ENCRYPTION_KEY = 'ecdh-key-encryption-key';
/**
 * NIST recommendation:
 *
 * 128-bit security provided with 256-bit key size
 *
 * Pg. 55
 * https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-57pt1r5.pdf
 *
 **/

const ecdh_NAMED_CURVE = 'P-256';
const ECDH_PARAMS = {
  name: ECDH_ALGORITHM_NAME,
  namedCurve: ecdh_NAMED_CURVE
};

const ecdh_generateKeyPair = async () => {
  const keyPair = await window.crypto.subtle.generateKey(ECDH_PARAMS, ecdh_KEY_IS_EXTRACTABLE, ecdh_KEY_WILL_BE_USED_TO);
  return keyPair;
};

const ecdh_getRawPrivateKeyFromPrivateKey = async privateKey => {
  const jwkPrivateKey = await window.crypto.subtle.exportKey(ecdh_PRIVATE_KEY_TYPE, privateKey);
  const rawPrivateKey = stringToArrayBuffer(JSON.stringify(jwkPrivateKey));
  return rawPrivateKey;
};

const ecdh_getPrivateKeyFromRawPrivateKey = async rawPrivateKey => {
  const jwkPrivateKey = JSON.parse(arrayBufferToString(rawPrivateKey));
  const privateKey = await window.crypto.subtle.importKey(ecdh_PRIVATE_KEY_TYPE, jwkPrivateKey, ECDH_PARAMS, ecdh_KEY_IS_EXTRACTABLE, ecdh_KEY_WILL_BE_USED_TO);
  return privateKey;
};

const ecdh_getRawPublicKeyFromPublicKey = async publicKey => {
  const rawPublicKey = await window.crypto.subtle.exportKey(ecdh_PUBLIC_KEY_TYPE, publicKey);
  return rawPublicKey;
};

const ecdh_getPublicKeyFromRawPublicKey = async rawPublicKey => {
  const publicKey = await window.crypto.subtle.importKey(ecdh_PUBLIC_KEY_TYPE, rawPublicKey, ECDH_PARAMS, ecdh_KEY_IS_EXTRACTABLE, [] // empty list ok
  );
  return publicKey;
};

const importEcdhKeyEncryptionKeyFromMaster = async (masterKey, salt) => {
  const keyEncryptionKey = await aes_gcm.importKeyFromMaster(masterKey, salt, ECDH_KEY_ENCRYPTION_KEY);
  return keyEncryptionKey;
};

const generateEcdhKeyData = async (masterKey, ecdsaPrivateKey) => {
  // need to generate new key pair because cannot derive ECDH key pair using HKDF in WebCrypto
  const ecdhKeyPair = await ecdh_generateKeyPair(); // derive a key encryption key using HKDF to encrypt the ECDH private key and store it on server

  const ecdhKeyEncryptionKeySalt = hkdf.generateSalt();
  const ecdhKeyEncryptionKey = await importEcdhKeyEncryptionKeyFromMaster(masterKey, ecdhKeyEncryptionKeySalt);
  const ecdhRawPrivateKey = await ecdh_getRawPrivateKeyFromPrivateKey(ecdhKeyPair.privateKey);
  const encryptedEcdhPrivateKey = await aes_gcm.encrypt(ecdhKeyEncryptionKey, ecdhRawPrivateKey);
  const ecdhPublicKey = await ecdh_getRawPublicKeyFromPublicKey(ecdhKeyPair.publicKey);
  const signedEcdhPublicKey = await ecdsa.sign(ecdsaPrivateKey, ecdhPublicKey);
  return {
    ecdhPrivateKey: ecdhKeyPair.privateKey,
    ecdhPublicKey: external_base64_arraybuffer_default.a.encode(ecdhPublicKey),
    encryptedEcdhPrivateKey: external_base64_arraybuffer_default.a.encode(encryptedEcdhPrivateKey),
    signedEcdhPublicKey: external_base64_arraybuffer_default.a.encode(signedEcdhPublicKey),
    ecdhKeyEncryptionKeySalt: external_base64_arraybuffer_default.a.encode(ecdhKeyEncryptionKeySalt)
  };
};

const computeSharedKeyEncryptionKey = async (otherEcdhPublicKey, ecdhPrivateKey) => {
  const sharedKeyEncryptionKey = await window.crypto.subtle.deriveKey({
    name: ECDH_ALGORITHM_NAME,
    namedCurve: ecdh_NAMED_CURVE,
    public: otherEcdhPublicKey
  }, ecdhPrivateKey, aes_gcm.getEncryptionKeyParams(), !ecdh_KEY_IS_EXTRACTABLE, aes_gcm.KEY_WILL_BE_USED_TO);
  return sharedKeyEncryptionKey;
};

/* harmony default export */ var ecdh = ({
  generateKeyPair: ecdh_generateKeyPair,
  generateEcdhKeyData,
  importEcdhKeyEncryptionKeyFromMaster,
  getPrivateKeyFromRawPrivateKey: ecdh_getPrivateKeyFromRawPrivateKey,
  getRawPublicKeyFromPublicKey: ecdh_getRawPublicKeyFromPublicKey,
  getPublicKeyFromRawPublicKey: ecdh_getPublicKeyFromRawPublicKey,
  computeSharedKeyEncryptionKey
});
// CONCATENATED MODULE: ./src/Crypto/hmac.js




const HMAC_KEY_NAME = 'authentication';
const ALGORITHM_NAME = 'HMAC';
const hmac_KEY_IS_EXTRACTABLE = false;
const KEY_WILL_BE_USED_TO_SIGN = ['sign'];
const KEY_WILL_BE_USED_TO_SIGN_AND_VERIFY = ['sign', 'verify'];

const hmac_importKeyFromMaster = async (masterKey, salt) => {
  const hmacKey = await window.crypto.subtle.deriveKey(hkdf.getParams(HMAC_KEY_NAME, salt), masterKey, {
    name: ALGORITHM_NAME,
    hash: {
      name: sha_256.HASH_ALGORITHM_NAME
    },
    length: 512 // need to explicitly set length for WebCrypto node polyfill (see: https://github.com/PeculiarVentures/webcrypto-core/issues/31)

  }, hmac_KEY_IS_EXTRACTABLE, KEY_WILL_BE_USED_TO_SIGN);
  return hmacKey;
};

const importKeyFromRawBits = async rawBits => {
  const hmacKey = await window.crypto.subtle.importKey('raw', rawBits, {
    name: ALGORITHM_NAME,
    hash: {
      name: sha_256.HASH_ALGORITHM_NAME
    },
    length: 256 // need to explicitly set length for WebCrypto node polyfill (see: https://github.com/PeculiarVentures/webcrypto-core/issues/31)

  }, hmac_KEY_IS_EXTRACTABLE, KEY_WILL_BE_USED_TO_SIGN_AND_VERIFY);
  return hmacKey;
};
/**
 *
 * @param {CryptoKey} key
 * @param {String} data
 */


const hmac_sign = async (key, data) => {
  const result = await window.crypto.subtle.sign({
    name: ALGORITHM_NAME
  }, key, data);
  return result;
};
/**
 *
 * @param {CryptoKey} key
 * @param {String} data
 */


const hmac_signString = async (key, data) => {
  const result = await hmac_sign(key, stringToArrayBuffer(data));
  return external_base64_arraybuffer_default.a.encode(result);
};

/* harmony default export */ var hmac = ({
  importKeyFromMaster: hmac_importKeyFromMaster,
  importKeyFromRawBits,
  sign: hmac_sign,
  signString: hmac_signString
});
// EXTERNAL MODULE: external "scrypt-js"
var external_scrypt_js_ = __webpack_require__(4);
var external_scrypt_js_default = /*#__PURE__*/__webpack_require__.n(external_scrypt_js_);

// CONCATENATED MODULE: ./src/Crypto/scrypt.js



/**
 *
 * From the Scrypt paper:
 *
 * "100ms is a reasonable upper bound on the delay which should be
 * cryptographically imposed on interactive logins"
 *
 * Pg. 13
 * https://www.tarsnap.com/scrypt/scrypt.pdf
 *
 * With an optimized Scrypt algorithm running on a 3.1 GHz Intel Core i5,
 * N = 32768 is the highest work factor that takes <100ms for the
 * algorithm to run. Thus, it's the latest recommended work factor.
 *
 * Source: https://blog.filippo.io/the-scrypt-parameters/
 *
 * However, we are not running an optimized version of the algorithm on a
 * single machine. Users are running a pure js version written for the browser.
 * Safari, for example, takes >6 seconds to run when N = 32768 on a 2.5 GHz
 * Intel Core i5. A higher end CPU can only shave around 1 second off that time.
 * Further, it takes over 1s to run in Firefox, and over 500ms to run in Chrome.
 * This is an unacceptably slow interactive login delay to impose on users.
 *
 * Thus, we are going with N = 16384 to ensure interactive logins
 * are closer to the reasonable delay the function will impose on users,
 * while still maintaining a high level of security.
 *
 **/

const N = 16384; // 16mb

const r = 8;
const p = 1;
const dkLen = 32;
/**
 * NIST recommendation:
 *
 * "The length of the randomly-generated portion of the salt shall be at least 128 bits."
 *
 * Section 5.1
 * https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-132.pdf
 *
 **/

const SALT_LENGTH = 16;

const scrypt_generateSalt = () => window.crypto.getRandomValues(new Uint8Array(SALT_LENGTH));

const scrypt_hash = async (passwordString, salt, passwordHashAlgo = external_scrypt_js_default.a.scrypt) => {
  const passwordArrayBuffer = new Uint8Array(stringToArrayBuffer(passwordString));
  const passwordHash = await passwordHashAlgo(passwordArrayBuffer, salt, N, r, p, dkLen);
  return external_base64_arraybuffer_default.a.encode(passwordHash);
};

/* harmony default export */ var scrypt = ({
  generateSalt: scrypt_generateSalt,
  hash: scrypt_hash
});
// CONCATENATED MODULE: ./src/Crypto/index.js








const SEED_BYTE_SIZE = 32; // 256 / 8

const generateSeed = () => window.crypto.getRandomValues(new Uint8Array(SEED_BYTE_SIZE));

/* harmony default export */ var Crypto = ({
  generateSeed,
  aesGcm: aes_gcm,
  diffieHellman: diffie_hellman,
  ecdsa: ecdsa,
  ecdh: ecdh,
  sha256: sha_256,
  hmac: hmac,
  hkdf: hkdf,
  scrypt: scrypt
});
// CONCATENATED MODULE: ./src/utils.js
const readArrayBufferAsString = arrayBuffer => {
  return new Promise(resolve => {
    let reader = new FileReader();

    reader.onload = () => resolve(reader.result);

    reader.readAsText(new Blob([arrayBuffer]));
  });
};

const removeProtocolFromEndpoint = endpoint => {
  const http = 'http://';
  const https = 'https://';

  if (endpoint.substring(0, http.length) === http) {
    return endpoint.substring(http.length);
  } else if (endpoint.substring(0, https.length) === https) {
    return endpoint.substring(https.length);
  } else {
    return endpoint;
  }
};

const getProtocolFromEndpoint = endpoint => {
  return endpoint.split(':')[0];
};
const getWsUrl = endpoint => {
  const host = removeProtocolFromEndpoint(endpoint);
  const protocol = getProtocolFromEndpoint(endpoint);
  return (protocol === 'https' ? 'wss://' : 'ws://') + host;
};
const byteSizeOfString = string => {
  return string.length * 2;
};
const objectHasOwnProperty = (object, property) => {
  return Object.prototype.hasOwnProperty.call(object, property);
}; // source: http://code.iamkate.com/javascript/queues

function Queue() {
  let queue = [];
  let offset = 0;

  this.getLength = () => queue.length - offset;

  this.isEmpty = () => queue.length === 0;

  this.enqueue = item => {
    queue.push(item);
    return this.getLength();
  };

  this.dequeue = () => {
    // get item from front of the queue
    const item = queue[offset];
    offset += 1; // garbage collect unused space in queue when it grows large

    if (offset * 2 > queue.length) {
      queue = queue.slice(offset);
      offset = 0;
    }

    return item;
  };

  this.peek = () => queue[offset];
}
// CONCATENATED MODULE: ./src/worker.js
// load the worker using inline JS so clients can avoid needing to load worker from a separate file
// https://stackoverflow.com/a/19201292
const newWorker = () => {
  const workerFunction = function workerFunction() {
    self.onmessage = function (e) {
      const {
        compress,
        decompress,
        data
      } = e.data; // copied from LZString, since can't load module from inside web worker without loading a separate file
      // https://github.com/pieroxy/lz-string/blob/b2e0b270a9f3cf330b778b777385fcba384a1a02/libs/lz-string.min.js

      const LZString = function () {
        function o(o, r) {
          if (!t[o]) {
            t[o] = {};

            for (var n = 0; n < o.length; n++) t[o][o.charAt(n)] = n;
          }

          return t[o][r];
        }

        var r = String.fromCharCode,
            n = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
            e = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+-$",
            t = {},
            i = {
          compressToBase64: function compressToBase64(o) {
            if (null == o) return "";

            var r = i._compress(o, 6, function (o) {
              return n.charAt(o);
            });

            switch (r.length % 4) {
              default:
              case 0:
                return r;

              case 1:
                return r + "===";

              case 2:
                return r + "==";

              case 3:
                return r + "=";
            }
          },
          decompressFromBase64: function decompressFromBase64(r) {
            return null == r ? "" : "" == r ? null : i._decompress(r.length, 32, function (e) {
              return o(n, r.charAt(e));
            });
          },
          compressToUTF16: function compressToUTF16(o) {
            return null == o ? "" : i._compress(o, 15, function (o) {
              return r(o + 32);
            }) + " ";
          },
          decompressFromUTF16: function decompressFromUTF16(o) {
            return null == o ? "" : "" == o ? null : i._decompress(o.length, 16384, function (r) {
              return o.charCodeAt(r) - 32;
            });
          },
          compressToUint8Array: function compressToUint8Array(o) {
            for (var r = i.compress(o), n = new Uint8Array(2 * r.length), e = 0, t = r.length; t > e; e++) {
              var s = r.charCodeAt(e);
              n[2 * e] = s >>> 8, n[2 * e + 1] = s % 256;
            }

            return n;
          },
          decompressFromUint8Array: function decompressFromUint8Array(o) {
            if (null === o || void 0 === o) return i.decompress(o);

            for (var n = new Array(o.length / 2), e = 0, t = n.length; t > e; e++) n[e] = 256 * o[2 * e] + o[2 * e + 1];

            var s = [];
            return n.forEach(function (o) {
              s.push(r(o));
            }), i.decompress(s.join(""));
          },
          compressToEncodedURIComponent: function compressToEncodedURIComponent(o) {
            return null == o ? "" : i._compress(o, 6, function (o) {
              return e.charAt(o);
            });
          },
          decompressFromEncodedURIComponent: function decompressFromEncodedURIComponent(r) {
            return null == r ? "" : "" == r ? null : (r = r.replace(/ /g, "+"), i._decompress(r.length, 32, function (n) {
              return o(e, r.charAt(n));
            }));
          },
          compress: function compress(o) {
            return i._compress(o, 16, function (o) {
              return r(o);
            });
          },
          _compress: function _compress(o, r, n) {
            if (null == o) return "";
            var e,
                t,
                i,
                s = {},
                p = {},
                u = "",
                c = "",
                a = "",
                l = 2,
                f = 3,
                h = 2,
                d = [],
                m = 0,
                v = 0;

            for (i = 0; i < o.length; i += 1) if (u = o.charAt(i), Object.prototype.hasOwnProperty.call(s, u) || (s[u] = f++, p[u] = !0), c = a + u, Object.prototype.hasOwnProperty.call(s, c)) a = c;else {
              if (Object.prototype.hasOwnProperty.call(p, a)) {
                if (a.charCodeAt(0) < 256) {
                  for (e = 0; h > e; e++) m <<= 1, v == r - 1 ? (v = 0, d.push(n(m)), m = 0) : v++;

                  for (t = a.charCodeAt(0), e = 0; 8 > e; e++) m = m << 1 | 1 & t, v == r - 1 ? (v = 0, d.push(n(m)), m = 0) : v++, t >>= 1;
                } else {
                  for (t = 1, e = 0; h > e; e++) m = m << 1 | t, v == r - 1 ? (v = 0, d.push(n(m)), m = 0) : v++, t = 0;

                  for (t = a.charCodeAt(0), e = 0; 16 > e; e++) m = m << 1 | 1 & t, v == r - 1 ? (v = 0, d.push(n(m)), m = 0) : v++, t >>= 1;
                }

                l--, 0 == l && (l = Math.pow(2, h), h++), delete p[a];
              } else for (t = s[a], e = 0; h > e; e++) m = m << 1 | 1 & t, v == r - 1 ? (v = 0, d.push(n(m)), m = 0) : v++, t >>= 1;

              l--, 0 == l && (l = Math.pow(2, h), h++), s[c] = f++, a = String(u);
            }

            if ("" !== a) {
              if (Object.prototype.hasOwnProperty.call(p, a)) {
                if (a.charCodeAt(0) < 256) {
                  for (e = 0; h > e; e++) m <<= 1, v == r - 1 ? (v = 0, d.push(n(m)), m = 0) : v++;

                  for (t = a.charCodeAt(0), e = 0; 8 > e; e++) m = m << 1 | 1 & t, v == r - 1 ? (v = 0, d.push(n(m)), m = 0) : v++, t >>= 1;
                } else {
                  for (t = 1, e = 0; h > e; e++) m = m << 1 | t, v == r - 1 ? (v = 0, d.push(n(m)), m = 0) : v++, t = 0;

                  for (t = a.charCodeAt(0), e = 0; 16 > e; e++) m = m << 1 | 1 & t, v == r - 1 ? (v = 0, d.push(n(m)), m = 0) : v++, t >>= 1;
                }

                l--, 0 == l && (l = Math.pow(2, h), h++), delete p[a];
              } else for (t = s[a], e = 0; h > e; e++) m = m << 1 | 1 & t, v == r - 1 ? (v = 0, d.push(n(m)), m = 0) : v++, t >>= 1;

              l--, 0 == l && (l = Math.pow(2, h), h++);
            }

            for (t = 2, e = 0; h > e; e++) m = m << 1 | 1 & t, v == r - 1 ? (v = 0, d.push(n(m)), m = 0) : v++, t >>= 1;

            for (;;) {
              if (m <<= 1, v == r - 1) {
                d.push(n(m));
                break;
              }

              v++;
            }

            return d.join("");
          },
          decompress: function decompress(o) {
            return null == o ? "" : "" == o ? null : i._decompress(o.length, 32768, function (r) {
              return o.charCodeAt(r);
            });
          },
          _decompress: function _decompress(o, n, e) {
            var t,
                i,
                s,
                p,
                u,
                c,
                a,
                l,
                f = [],
                h = 4,
                d = 4,
                m = 3,
                v = "",
                w = [],
                A = {
              val: e(0),
              position: n,
              index: 1
            };

            for (i = 0; 3 > i; i += 1) f[i] = i;

            for (p = 0, c = Math.pow(2, 2), a = 1; a != c;) u = A.val & A.position, A.position >>= 1, 0 == A.position && (A.position = n, A.val = e(A.index++)), p |= (u > 0 ? 1 : 0) * a, a <<= 1;

            switch (t = p) {
              case 0:
                for (p = 0, c = Math.pow(2, 8), a = 1; a != c;) u = A.val & A.position, A.position >>= 1, 0 == A.position && (A.position = n, A.val = e(A.index++)), p |= (u > 0 ? 1 : 0) * a, a <<= 1;

                l = r(p);
                break;

              case 1:
                for (p = 0, c = Math.pow(2, 16), a = 1; a != c;) u = A.val & A.position, A.position >>= 1, 0 == A.position && (A.position = n, A.val = e(A.index++)), p |= (u > 0 ? 1 : 0) * a, a <<= 1;

                l = r(p);
                break;

              case 2:
                return "";
            }

            for (f[3] = l, s = l, w.push(l);;) {
              if (A.index > o) return "";

              for (p = 0, c = Math.pow(2, m), a = 1; a != c;) u = A.val & A.position, A.position >>= 1, 0 == A.position && (A.position = n, A.val = e(A.index++)), p |= (u > 0 ? 1 : 0) * a, a <<= 1;

              switch (l = p) {
                case 0:
                  for (p = 0, c = Math.pow(2, 8), a = 1; a != c;) u = A.val & A.position, A.position >>= 1, 0 == A.position && (A.position = n, A.val = e(A.index++)), p |= (u > 0 ? 1 : 0) * a, a <<= 1;

                  f[d++] = r(p), l = d - 1, h--;
                  break;

                case 1:
                  for (p = 0, c = Math.pow(2, 16), a = 1; a != c;) u = A.val & A.position, A.position >>= 1, 0 == A.position && (A.position = n, A.val = e(A.index++)), p |= (u > 0 ? 1 : 0) * a, a <<= 1;

                  f[d++] = r(p), l = d - 1, h--;
                  break;

                case 2:
                  return w.join("");
              }

              if (0 == h && (h = Math.pow(2, m), m++), f[l]) v = f[l];else {
                if (l !== d) return null;
                v = s + s.charAt(0);
              }
              w.push(v), f[d++] = s + v.charAt(0), h--, s = v, 0 == h && (h = Math.pow(2, m), m++);
            }
          }
        };
        return i;
      }();

      if (compress) postMessage(LZString.compress(data));else if (decompress) postMessage(LZString.decompress(data));
    };
  };

  const blobURL = URL.createObjectURL(new Blob(['(', workerFunction.toString(), ')()'], {
    type: 'application/javascript'
  }));
  const worker = new Worker(blobURL);
  URL.revokeObjectURL(blobURL);
  return worker;
}; // compress and decompress inside a worker because large amounts of data freeze the DOM


const compress = async data => {
  const worker = newWorker();
  return new Promise(resolve => {
    worker.onmessage = e => {
      resolve(e.data);
      worker.terminate();
    };

    worker.postMessage({
      compress: true,
      data
    });
  });
};
const decompress = async data => {
  const worker = newWorker();
  return new Promise(resolve => {
    worker.onmessage = e => {
      resolve(e.data);
      worker.terminate();
    };

    worker.postMessage({
      decompress: true,
      data
    });
  });
};
// CONCATENATED MODULE: ./src/api/db.js


const TIMEOUT = 30 * 1000;
const db_uploadBundleChunk = async (userId, databaseId, seqNo, bundleId, chunkNo, chunk) => {
  return new Promise((resolve, reject) => {
    const xhr = new XMLHttpRequest();
    const method = 'POST';
    const url = "".concat(src_config.getEndpoint(), "/api/bundle-chunk?userbaseJsVersion=").concat(src_config.USERBASE_JS_VERSION, "&") + "userId=".concat(userId, "&") + "databaseId=".concat(databaseId, "&") + "seqNo=".concat(seqNo, "&") + "bundleId=".concat(bundleId, "&") + "chunkNumber=".concat(chunkNo);
    xhr.open(method, url);
    xhr.send(new Uint8Array(chunk)); // Uint8Array view prevents deprecation warning in Safari

    processXhr(xhr, resolve, reject, TIMEOUT);
  });
};
// CONCATENATED MODULE: ./src/ws.js


function ws_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function ws_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ws_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ws_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }












const wsAlreadyConnected = 'Web Socket already connected';
const BACKOFF_RETRY_DELAY = 1000;
const MAX_RETRY_DELAY = 1000 * 30;
const BUNDLE_CHUNK_SIZE = 1024 * 512; // 512kb

const BUNDLE_CHUNKS_PER_BATCH = 10;
const WS_REQUEST_TIMEOUT = 30 * 1000;
const clientId = v4_default()(); // only 1 client ID per browser tab (assumes code does not reload)

class ws_RequestFailed extends Error {
  constructor(action, e, ...params) {
    super(...params);
    this.name = "RequestFailed: ".concat(action);
    this.message = e.message;
    this.status = e.status || e.message === 'timeout' && statusCodes['Gateway Timeout'];
    this.response = e.status && e;
  }

}

class WebSocketError extends Error {
  constructor(message, username, e, ...params) {
    super(...params);
    this.name = 'WebSocket error';
    this.message = message;
    this.username = username;
    this.e = e;
  }

}

class ws_Connection {
  constructor() {
    this.init();
  }

  init(resolveConnection, rejectConnection, session, seedString, rememberMe, changePassword, state, encryptionMode) {
    if (this.pingTimeout) clearTimeout(this.pingTimeout);

    for (const property of Object.keys(this)) {
      delete this[property];
    }

    this.ws = null;
    this.connected = false;
    this.resolveConnection = resolveConnection;
    this.rejectConnection = rejectConnection;
    this.connectionResolved = false;
    this.session = {
      username: session && session.username,
      sessionId: session && session.sessionId,
      creationDate: session && session.creationDate,
      expirationDate: session && session.expirationDate,
      userId: session && session.userId,
      authToken: session && session.authToken
    };
    this.seedString = seedString;
    this.changePassword = changePassword;
    this.keys = {
      init: false,
      salts: {}
    };
    this.userData = {
      stripeData: {}
    };
    this.rememberMe = rememberMe;
    this.requests = {};
    this.state = state || {
      dbNameToHash: {},
      databases: {},
      // used when openDatabase is called with databaseName
      databasesByDbId: {},
      // used when openDatabase is called with databaseId
      shareTokenIdToDbId: {} // used when openDatabase is called with shareToken

    };
    this.encryptionMode = encryptionMode;
  }

  connect(session, seedString = null, rememberMe, changePassword, reconnectDelay, state) {
    if (this.connected) throw new WebSocketError(wsAlreadyConnected, this.session.username);
    return new Promise((resolve, reject) => {
      let timeout = false;
      const timeoutToOpenWebSocket = setTimeout(() => {
        if (!this.connected && !this.reconnecting) {
          timeout = true;
          reject(new WebSocketError('timeout'));
        }
      }, 10000);
      const url = "".concat(getWsUrl(src_config.getEndpoint()), "/api?appId=").concat(src_config.getAppId(), "&sessionId=").concat(session.sessionId, "&clientId=").concat(clientId, "&userbaseJsVersion=").concat(src_config.USERBASE_JS_VERSION);
      const ws = new WebSocket(url);

      ws.onopen = async () => {
        if (timeout) return;
        clearTimeout(timeoutToOpenWebSocket);
      };

      ws.onmessage = async e => {
        if (timeout) return;

        try {
          const message = JSON.parse(e.data);
          const route = message.route;

          switch (route) {
            case 'Ping':
              {
                this.heartbeat();
                const action = 'Pong';
                this.ws.send(JSON.stringify({
                  action
                }));
                break;
              }

            case 'Connection':
              {
                const {
                  encryptionMode
                } = message;
                this.init(resolve, reject, session, seedString, rememberMe, changePassword, state, encryptionMode);
                this.ws = ws;
                this.heartbeat();
                this.connected = true; // seedString not present on initial connection when still need to change password

                if (seedString) {
                  const {
                    keySalts,
                    validationMessage,
                    ecKeyData,
                    encryptedValidationMessage
                  } = message;
                  this.keys.salts = keySalts;
                  this.validationMessage = validationMessage;
                  this.ecKeyData = ecKeyData; // provided by userbase-server for users who have not yet generated their ECDSA key and
                  // still only have a DH key

                  if (encryptedValidationMessage) this.encryptedValidationMessage = new Uint8Array(encryptedValidationMessage.data);

                  try {
                    await this.setKeys(this.seedString);
                    const userData = await this.validateKey();
                    this.userData = userData;
                  } catch (e) {
                    if (e && e.name === 'OperationError' || e instanceof DOMException) throw new Error('Invalid seed');else throw e;
                  }

                  this.keys.init = true;
                }

                this.resolveConnection();
                this.connectionResolved = true;
                break;
              }

            case 'ApplyTransactions':
              {
                const dbId = message.dbId;
                const dbNameHash = message.dbNameHash; // if owner, must have opened the database via databaseName

                const database = message.isOwner ? this.state.databases[dbNameHash] : this.state.databasesByDbId[dbId];
                if (!database) throw new Error('Missing database'); // queue guarantees transactions will be applied in the order they are received from the server

                if (database.applyTransactionsQueue.isEmpty()) {
                  // take a spot in the queue and proceed applying so the next caller knows queue is not empty
                  database.applyTransactionsQueue.enqueue(null);
                } else {
                  // wait until prior batch in queue finishes applying successfully
                  await new Promise(resolve => {
                    const startApplyingThisBatchOfTransactions = resolve;
                    database.applyTransactionsQueue.enqueue(startApplyingThisBatchOfTransactions);
                  });
                }

                const openingDatabase = message.dbNameHash && (message.dbKey || message.plaintextDbKey) || message.shareTokenEncryptedDbKey;

                if (openingDatabase && (!database.dbKeyString || !database.dbKey)) {
                  const dbKeyString = message.plaintextDbKey || (message.dbKey ? await Crypto.aesGcm.decryptString(this.keys.encryptionKey, message.dbKey) : await database.decryptShareTokenEncryptedDbKey(message.shareTokenEncryptedDbKey, message.shareTokenEncryptionKeySalt));
                  database.dbKeyString = dbKeyString;
                  database.dbKey = await Crypto.aesGcm.getKeyFromKeyString(dbKeyString);
                }

                if (!database.dbKey) throw new Error('Missing db key');

                if (message.writers) {
                  database.attributionEnabled = true;

                  for (const {
                    userId,
                    username
                  } of message.writers) {
                    database.usernamesByUserId.set(userId, username);
                  }
                } // server is sending bundle in chunks, wait until it sends the entire bundle and client applies it


                if (message.waitForFullBundle) {
                  if (!database.finishedWaitingForBundle) {
                    await new Promise(resolve => database.finishedWaitingForBundle = resolve);
                  } // rebuild bundle from the chunks


                  try {
                    const bundle = await this.rebuildBundle(database, message.bundleSeqNo, message.encryptedBundleEncryptionKey);
                    await database.applyBundle(bundle, message.bundleSeqNo);
                  } catch (e) {
                    window.alert("Oops! Something went wrong. Please contact the site administrator with this issue (".concat(dbId, ").\n\n") + e);
                    throw e;
                  }
                }

                const newTransactions = message.transactionLog;
                await database.applyTransactions(newTransactions, message.ownerId, dbId, dbNameHash);

                if (message.buildBundle) {
                  this.buildBundle(database);
                } // start applying next batch in queue when this one is finished applying successfully


                database.applyTransactionsQueue.dequeue();

                if (!database.applyTransactionsQueue.isEmpty()) {
                  const startApplyingNextBatchInQueue = database.applyTransactionsQueue.peek();
                  startApplyingNextBatchInQueue();
                }

                break;
              }

            case 'DownloadBundleChunk':
              {
                const {
                  dbId,
                  dbNameHash,
                  isOwner,
                  bundleSeqNo,
                  isFirstChunk,
                  isLastChunk,
                  chunk
                } = message; // if owner, must have opened the database via databaseName

                const database = isOwner ? this.state.databases[dbNameHash] : this.state.databasesByDbId[dbId];
                if (!database) throw new Error('Missing database'); // assumes server will always send first chunk first, and last chunk last

                if (isFirstChunk) database.bundleChunks[bundleSeqNo] = [];
                database.bundleChunks[bundleSeqNo].push(chunk);

                if (isLastChunk) {
                  if (database.finishedWaitingForBundle) database.finishedWaitingForBundle();else database.finishedWaitingForBundle = true;
                }

                break;
              }

            case 'UpdatedUser':
              {
                this.handleUpdateUser(message.updatedUser);
                break;
              }

            case 'SignOut':
            case 'UpdateUser':
            case 'DeleteUser':
            case 'CreateDatabase':
            case 'OpenDatabase':
            case 'OpenDatabaseByDatabaseId':
            case 'GetDatabases':
            case 'GetDatabaseUsers':
            case 'Insert':
            case 'Update':
            case 'Delete':
            case 'BatchTransaction':
            case 'InitBundleUpload':
            case 'CompleteBundleUpload':
            case 'GenerateFileId':
            case 'UploadFileChunk':
            case 'CompleteFileUpload':
            case 'GetChunk':
            case 'ValidateKey':
            case 'GetPasswordSalts':
            case 'PurchaseSubscription':
            case 'CancelSubscription':
            case 'ResumeSubscription':
            case 'UpdatePaymentMethod':
            case 'ShareDatabase':
            case 'ShareDatabaseToken':
            case 'AuthenticateShareToken':
            case 'SaveDatabase':
            case 'ModifyDatabasePermissions':
            case 'VerifyUser':
              {
                const requestId = message.requestId;
                if (!requestId) return console.warn('Missing request id');
                const request = this.requests[requestId];
                if (!request) return console.warn("Request ".concat(requestId, " no longer exists!"));else if (!request.promiseResolve || !request.promiseReject) return;
                const response = message.response;
                const successfulResponse = response && response.status === statusCodes['Success'];
                if (!successfulResponse) return request.promiseReject(response);else return request.promiseResolve(response);
              }

            default:
              {
                console.log('Received unknown message from backend:' + JSON.stringify(message));
                break;
              }
          }
        } catch (e) {
          if (!this.connectionResolved) {
            this.close();
            reject(new WebSocketError(e.message, session.username, e));
          } else {
            console.warn('Error handling message: ', e);
          }
        }
      };

      ws.onclose = async e => {
        if (timeout) return;
        const serviceRestart = e.code === statusCodes['Service Restart'];
        const clientDisconnected = e.code === statusCodes['No Pong Received'];
        const attemptToReconnect = serviceRestart || clientDisconnected || !e.wasClean; // closed without explicit call to ws.close()

        if (attemptToReconnect) {
          const delay = serviceRestart && !reconnectDelay ? 0 : reconnectDelay ? reconnectDelay + BACKOFF_RETRY_DELAY : 1000;
          this.reconnecting = true;
          await this.reconnect(resolve, reject, session, this.seedString || seedString, rememberMe, changePassword, delay, !this.reconnected && state);
        } else if (e.code === statusCodes['Client Already Connected']) {
          reject(new WebSocketError(wsAlreadyConnected, session.username, e));
        } else {
          this.init();
        }
      };

      ws.onerror = () => {}; // no-op so node WS implementation doesn't throw not found

    });
  }

  async reconnect(resolveConnection, rejectConnection, session, seedString, rememberMe, changePassword, reconnectDelay, currentState) {
    try {
      const retryDelay = Math.min(reconnectDelay, MAX_RETRY_DELAY);
      console.log("Connection to server lost. Attempting to reconnect in ".concat(retryDelay / 1000, " second").concat(retryDelay !== 1000 ? 's' : '', "..."));
      const dbsToReopen = [];
      const dbsToReopenById = []; // as soon as one reconnect succeeds, resolves all the way up the stack and all reconnects succeed

      resolveConnection(await new Promise((resolve, reject) => setTimeout(async () => {
        try {
          // get copy of currently opened databases' memory references to reopen WebSocket with same databases
          const state = currentState || {
            dbNameToHash: ws_objectSpread({}, this.state.dbNameToHash),
            databases: ws_objectSpread({}, this.state.databases),
            databasesByDbId: ws_objectSpread({}, this.state.databasesByDbId),
            shareTokenIdToDbId: ws_objectSpread({}, this.state.shareTokenIdToDbId)
          }; // mark databases as uninitialized to prevent client from using them until they are reopened

          for (const dbNameHash in state.databases) {
            state.databases[dbNameHash].init = false;
            state.databases[dbNameHash].finishedWaitingForBundle = false;
            dbsToReopen.push(dbNameHash);
          }

          for (const dbId in state.databasesByDbId) {
            state.databasesByDbId[dbId].init = false;
            state.databasesByDbId[dbId].finishedWaitingForBundle = false;
            dbsToReopenById.push(dbId);
          }

          this.init();
          this.reconnecting = true;
          const result = await this.connect(session, seedString, rememberMe, changePassword, reconnectDelay, state);
          this.reconnected = true; // only reopen databases on the first call to reconnect()

          if (!currentState) {
            await this.reopenDatabases(dbsToReopen, dbsToReopenById, 1000);
            console.log('Reconnected!');
          }

          resolve(result);
        } catch (e) {
          reject(e);
        }
      }, retryDelay)));
    } catch (e) {
      rejectConnection(e);
    }
  }

  async reopenDatabases(dbsToReopen, dbsToReopenById, retryDelay) {
    try {
      const openDatabasePromises = []; // open databases by database name hash

      for (const dbNameHash of dbsToReopen) {
        const database = this.state.databases[dbNameHash];

        if (!database.init) {
          const action = 'OpenDatabase';
          const params = {
            dbNameHash,
            reopenAtSeqNo: database.lastSeqNo
          };
          openDatabasePromises.push(this.request(action, params));
        }
      } // open databases by database ID


      for (const databaseId of dbsToReopenById) {
        const database = this.state.databasesByDbId[databaseId];

        if (!database.init) {
          const shareTokenHkdfKey = database.shareTokenHkdfKey; // if opened with shareToken, need to reauthenticate it

          const shareTokenAuthData = shareTokenHkdfKey ? await this.authenticateShareToken(database.shareTokenId, shareTokenHkdfKey) : {};
          const action = 'OpenDatabaseByDatabaseId';

          const params = ws_objectSpread({
            databaseId,
            reopenAtSeqNo: database.lastSeqNo
          }, shareTokenAuthData);

          openDatabasePromises.push(this.request(action, params));
        }
      }

      await Promise.all(openDatabasePromises);
    } catch (e) {
      // keep attempting to reopen on failure
      await new Promise(resolve => setTimeout(async () => {
        await this.reopenDatabases(dbsToReopen, dbsToReopenById, retryDelay + BACKOFF_RETRY_DELAY);
        resolve();
      }, Math.min(retryDelay, MAX_RETRY_DELAY)));
    }
  }

  heartbeat() {
    clearTimeout(this.pingTimeout);
    const LATENCY_BUFFER = 3000;
    this.pingTimeout = setTimeout(() => {
      if (this.ws) this.ws.close(statusCodes['No Pong Received']);
    }, 30000 + LATENCY_BUFFER);
  }

  close(code) {
    this.ws ? this.ws.close(code) : this.init();
  }

  async signOut() {
    const username = this.session.username;
    const connectionResolved = this.connectionResolved;
    const rejectConnection = this.rejectConnection;

    try {
      localData.signOutSession(this.rememberMe, username);
      const sessionId = this.session.sessionId;
      if (this.reconnecting) throw new errors.Reconnecting();
      const action = 'SignOut';
      const params = {
        sessionId
      };
      await this.request(action, params);
      this.close();

      if (!connectionResolved && rejectConnection) {
        rejectConnection(new WebSocketError('Canceled', username));
      }
    } catch (e) {
      if (!connectionResolved && rejectConnection) {
        rejectConnection(new WebSocketError('Canceled', username));
      }

      throw e;
    }
  }

  async setKeys(seedString) {
    if (this.keys.init) return;
    if (!seedString) throw new WebSocketError('Missing seed', this.session.username);
    if (!this.keys.salts) throw new WebSocketError('Missing salts', this.session.username);
    if (!this.seedString) this.seedString = seedString;
    const seed = external_base64_arraybuffer_default.a.decode(seedString);
    const masterKey = await Crypto.hkdf.importHkdfKey(seed);
    const salts = this.keys.salts;
    this.keys.encryptionKey = await Crypto.aesGcm.importKeyFromMaster(masterKey, external_base64_arraybuffer_default.a.decode(salts.encryptionKeySalt));
    this.keys.hmacKey = await Crypto.hmac.importKeyFromMaster(masterKey, external_base64_arraybuffer_default.a.decode(salts.hmacKeySalt));

    if (salts.ecdsaKeyEncryptionKeySalt) {
      const ecdsaKeyEncryptionKey = await Crypto.ecdsa.importEcdsaKeyEncryptionKeyFromMaster(masterKey, external_base64_arraybuffer_default.a.decode(salts.ecdsaKeyEncryptionKeySalt));
      const encryptedEcdsaPrivateKey = external_base64_arraybuffer_default.a.decode(this.ecKeyData.encryptedEcdsaPrivateKey);
      const rawEcdsaPrivateKey = await Crypto.aesGcm.decrypt(ecdsaKeyEncryptionKey, encryptedEcdsaPrivateKey);
      this.keys.ecdsaPrivateKey = await Crypto.ecdsa.getPrivateKeyFromRawPrivateKey(rawEcdsaPrivateKey);
      const ecdhKeyEncryptionKey = await Crypto.ecdh.importEcdhKeyEncryptionKeyFromMaster(masterKey, external_base64_arraybuffer_default.a.decode(salts.ecdhKeyEncryptionKeySalt));
      const encryptedEcdhPrivateKey = external_base64_arraybuffer_default.a.decode(this.ecKeyData.encryptedEcdhPrivateKey);
      const rawEcdhPrivateKey = await Crypto.aesGcm.decrypt(ecdhKeyEncryptionKey, encryptedEcdhPrivateKey);
      this.keys.ecdhPrivateKey = await Crypto.ecdh.getPrivateKeyFromRawPrivateKey(rawEcdhPrivateKey);
    } else if (salts.dhKeySalt) {
      // must be an old user created with userbase-js < v2.0.0. Need to prove access to DH key to server
      this.keys.dhPrivateKey = await Crypto.diffieHellman.importKeyFromMaster(masterKey, external_base64_arraybuffer_default.a.decode(salts.dhKeySalt));
    }

    if (salts.dhKeySalt || salts.ecdsaKeyWrapperSalt) {
      // must be an old user created with userbase-js <= v2.0.0. Update EC key data for future logins
      const ecdsaKeyData = await Crypto.ecdsa.generateEcdsaKeyData(masterKey);
      const ecdhKeyData = await Crypto.ecdh.generateEcdhKeyData(masterKey, ecdsaKeyData.ecdsaPrivateKey);
      this.keys.ecdsaPrivateKey = ecdsaKeyData.ecdsaPrivateKey;
      this.keys.ecdhPrivateKey = ecdhKeyData.ecdhPrivateKey;
      delete ecdsaKeyData.ecdsaPrivateKey;
      delete ecdhKeyData.ecdhPrivateKey;
      this.newEcKeyData = {
        ecdsaKeyData,
        ecdhKeyData
      };
    }
  }

  async validateKey() {
    let validationMessage;

    if (this.keys.ecdsaPrivateKey && !this.keys.dhPrivateKey) {
      // need to sign the validation message with ECDSA private key
      validationMessage = await Crypto.ecdsa.sign(this.keys.ecdsaPrivateKey, external_base64_arraybuffer_default.a.decode(this.validationMessage));
    } else if (this.keys.dhPrivateKey) {
      // need to decrypt the encrypted validation emssage with DH shared key
      const sharedKey = await Crypto.diffieHellman.getSharedKeyWithServer(this.keys.dhPrivateKey);
      validationMessage = await Crypto.aesGcm.decrypt(sharedKey, this.encryptedValidationMessage);
      delete this.keys.dhPrivateKey;
    }

    const action = 'ValidateKey';
    const params = {
      validationMessage: external_base64_arraybuffer_default.a.encode(validationMessage),
      ecKeyData: this.newEcKeyData
    };
    const response = await this.request(action, params);
    const userData = response.data;
    return userData;
  }

  async request(action, params) {
    // generate a new requestId
    const requestId = v4_default()();
    this.requests[requestId] = {}; // get a promise that is resolved when the WebSocket
    // receives a response for this requestId  the promise
    // would time out of x seconds

    const responseWatcher = this.watch(requestId); // send the request on the WebSocket

    this.ws.send(JSON.stringify({
      requestId,
      action,
      params
    })); // wait for the response to arrive

    try {
      const response = await responseWatcher;
      return response;
    } catch (e) {
      // process any errors and re-throw them
      if (e.status === statusCodes['Too Many Requests']) throw new errors.TooManyRequests(e.data.retryDelay);else throw new ws_RequestFailed(action, e);
    }
  }

  async watch(requestId) {
    const response = await new Promise((resolve, reject) => {
      this.requests[requestId].promiseResolve = resolve;
      this.requests[requestId].promiseReject = reject;
      setTimeout(() => {
        reject(new Error('timeout'));
      }, WS_REQUEST_TIMEOUT);
    });
    delete this.requests[requestId];
    return response;
  }

  async rebuildBundle(database, bundleSeqNo, encryptedBundleEncryptionKey) {
    const bundleChunks = [];

    for (let i = 0; i < database.bundleChunks[bundleSeqNo].length; i++) {
      const chunk = database.bundleChunks[bundleSeqNo][i];
      const chunkArrayBuffer = stringToArrayBuffer(chunk);
      bundleChunks.push(chunkArrayBuffer);
    }

    const bundleArrayBuffer = appendBuffers(bundleChunks).buffer;
    const {
      encrypted,
      plaintextMetadata
    } = JSON.parse(arrayBufferToString(bundleArrayBuffer));
    const bundleEncryptionKeyRaw = await Crypto.aesGcm.decrypt(database.dbKey, external_base64_arraybuffer_default.a.decode(encryptedBundleEncryptionKey));
    const bundleEncryptionKey = await Crypto.aesGcm.getKeyFromRawKey(bundleEncryptionKeyRaw);
    const decrypted = await Crypto.aesGcm.decrypt(bundleEncryptionKey, stringToArrayBuffer(encrypted));
    const decryptedString = arrayBufferToString(decrypted);
    const [decompressedEncrypted, decompressedPlaintextMetdata] = await Promise.all([decompress(decryptedString), decompress(plaintextMetadata)]);

    const bundle = ws_objectSpread(ws_objectSpread({}, JSON.parse(decompressedEncrypted)), JSON.parse(decompressedPlaintextMetdata));

    delete database.bundleChunks[bundleSeqNo];
    return bundle;
  }

  async uploadBundle(userId, dbId, seqNo, bundleId, bundleArrayBuffer) {
    let position = 0;
    let chunkNumber = 0;
    let batch = []; // will use this to send chunks to server in batches of BUNDLE_CHUNKS_PER_BATCH

    while (position < bundleArrayBuffer.byteLength) {
      const chunk = bundleArrayBuffer.slice(position, position + BUNDLE_CHUNK_SIZE); // using XHR to send binary data because Safari has trouble with string encoding over WebSocket

      batch.push(db_uploadBundleChunk(userId, dbId, seqNo, bundleId, chunkNumber, chunk));

      if (batch.length === BUNDLE_CHUNKS_PER_BATCH) {
        try {
          await Promise.all(batch);
        } catch (_unused) {
          // ok to fail - bundling is just an optimization
          return 0;
        }

        batch = [];
      }

      chunkNumber += 1;
      position += BUNDLE_CHUNK_SIZE;
    }

    try {
      await Promise.all(batch);
    } catch (_unused2) {
      // ok to fail - bundling is just an optimization
      return 0;
    }

    return chunkNumber;
  }

  async initBundleUpload(dbId, seqNo, dbKey) {
    const action = 'InitBundleUpload';
    const params = {
      dbId,
      seqNo
    };
    let initResponse;

    try {
      initResponse = await this.request(action, params);
    } catch (_unused3) {
      // ok to fail - bundling is just an optimization
      return {};
    }

    const {
      bundleId
    } = initResponse.data;
    const [bundleEncryptionKey, encryptedBundleEncryptionKey] = await Crypto.aesGcm.generateAndEncryptKeyEncryptionKey(dbKey);
    return {
      bundleId,
      bundleEncryptionKey,
      encryptedBundleEncryptionKey: external_base64_arraybuffer_default.a.encode(encryptedBundleEncryptionKey)
    };
  }

  orderedItems(items, itemsIndex) {
    const orderedItemsArray = [];

    for (let i = 0; i < itemsIndex.array.length; i++) {
      const itemId = itemsIndex.array[i].itemId;
      orderedItemsArray.push(items[itemId]);
    }

    return orderedItemsArray;
  }

  prepareBundle(database) {
    const {
      items,
      itemsIndex,
      itemsPlaintextMetadata
    } = database;
    const bundle = {
      // these values are all provided as input values to SDK, or generated by SDK - will compress, then encrypt
      encrypted: JSON.stringify({
        items: this.orderedItems(items, itemsIndex),
        itemsIndex: itemsIndex.array
      }),
      // these are values the server has access to and can modify - will compress, but no need to encrypt and risk CRIME
      plaintextMetadata: JSON.stringify({
        itemsPlaintextMetadata: this.orderedItems(itemsPlaintextMetadata, itemsIndex)
      })
    };
    return bundle;
  }

  async buildBundle(database) {
    const dbId = database.dbId;
    const lastSeqNo = database.lastSeqNo;
    const dbKey = database.dbKey;
    const userId = this.session.userId; // Client will only attempt to bundle at a particular seqNo a single time. This prevents server from spamming
    // client with buildBundle to maliciously get the client to re-use an IV in AES-GCM and reveal the dbKey

    if (database.bundledAtSeqNo && database.bundledAtSeqNo >= lastSeqNo) return;else database.bundledAtSeqNo = lastSeqNo;
    const bundle = this.prepareBundle(database);
    const writers = database.attributionEnabled ? [...database.usernamesByUserId.keys()].join(',') : undefined;
    const {
      bundleId,
      bundleEncryptionKey,
      encryptedBundleEncryptionKey
    } = await this.initBundleUpload(dbId, lastSeqNo, dbKey);
    if (!bundleId) return;
    const [compressedBeforeEncryption, compressedPlaintextMetadataString] = await Promise.all([compress(bundle.encrypted), compress(bundle.plaintextMetadata)]);
    const compressedArrayBufferBeforeEncryption = stringToArrayBuffer(compressedBeforeEncryption);
    const encryptedItems = await Crypto.aesGcm.encrypt(bundleEncryptionKey, compressedArrayBufferBeforeEncryption);
    bundle.encrypted = arrayBufferToString(encryptedItems);
    bundle.plaintextMetadata = compressedPlaintextMetadataString;
    const bundleArrayBuffer = stringToArrayBuffer(JSON.stringify(bundle));
    const numChunks = await this.uploadBundle(userId, dbId, lastSeqNo, bundleId, bundleArrayBuffer);
    if (!numChunks) return;
    const action = 'CompleteBundleUpload';
    const params = {
      dbId,
      seqNo: lastSeqNo,
      bundleId,
      writers,
      numChunks,
      encryptedBundleEncryptionKey
    };

    try {
      await this.request(action, params);
    } catch (_unused4) {
      // ok to fail - bundling is just an optimization
      return;
    }
  }

  buildUserResult({
    username,
    userId,
    authToken,
    email,
    profile,
    protectedProfile,
    usedTempPassword,
    changePassword,
    passwordChanged,
    userData
  }) {
    const result = {
      username,
      userId,
      authToken
    };
    if (email) result.email = email;
    if (profile) result.profile = profile;
    if (protectedProfile) result.protectedProfile = protectedProfile;
    if (usedTempPassword) result.usedTempPassword = usedTempPassword;
    if (changePassword) result.changePassword = changePassword;
    if (passwordChanged) result.passwordChanged = passwordChanged;

    if (userData) {
      const {
        creationDate,
        stripeData
      } = userData;
      if (creationDate) result.creationDate = creationDate;

      if (stripeData) {
        const {
          paymentsMode,
          subscriptionStatus,
          cancelSubscriptionAt,
          subscriptionPlanId,
          trialExpirationDate
        } = stripeData;
        if (paymentsMode) result.paymentsMode = paymentsMode;
        if (subscriptionStatus) result.subscriptionStatus = subscriptionStatus;
        if (cancelSubscriptionAt) result.cancelSubscriptionAt = cancelSubscriptionAt;
        if (subscriptionPlanId) result.subscriptionPlanId = subscriptionPlanId;
        if (trialExpirationDate) result.trialExpirationDate = trialExpirationDate;
      }
    }

    return result;
  }

  handleUpdateUser(updatedUser) {
    // make sure WebSocket session matches provided user
    if (this.session && this.session.userId === updatedUser['userId']) {
      this.session.username = updatedUser['username'];
      this.userData = updatedUser.userData;
      const updateUserHandler = src_config.getUpdateUserHandler();

      if (updateUserHandler) {
        updateUserHandler({
          user: this.buildUserResult(ws_objectSpread({
            authToken: this.session.authToken
          }, updatedUser))
        });
      }
    }
  }

  async rotateKeys(newSeedString, newKeyData) {
    // re-arrange object to fit expected structure for setKeys() function
    const {
      keySalts,
      ecKeyData
    } = newKeyData;
    const {
      ecdsaKeyData,
      ecdhKeyData
    } = ecKeyData;
    keySalts.ecdsaKeyEncryptionKeySalt = ecdsaKeyData.ecdsaKeyEncryptionKeySalt;
    keySalts.ecdhKeyEncryptionKeySalt = ecdhKeyData.ecdhKeyEncryptionKeySalt;
    this.keys.salts = keySalts;
    this.ecKeyData = ws_objectSpread(ws_objectSpread({}, ecdsaKeyData), ecdhKeyData);
    await this.setKeys(newSeedString);
    this.keys.init = true;
  }

  async authenticateShareToken(shareTokenId, shareTokenHkdfKey) {
    // retrieve shareToken auth key data in order to prove access to shareToken to server
    const action = 'AuthenticateShareToken';
    const params = {
      shareTokenId
    };
    let response;

    try {
      response = await this.request(action, params);
    } catch (e) {
      if (e.response && e.response.data === 'ShareTokenNotFound') throw new errors.ShareTokenNotFound();
      throw e;
    }

    const {
      databaseId,
      shareTokenAuthKeyData,
      validationMessage
    } = response.data; // decrypt ECDSA private key. if it fails, not using the correct shareToken

    let shareTokenEcdsaPrivateKey;

    try {
      const shareTokenEcdsaKeyEncryptionKeySalt = external_base64_arraybuffer_default.a.decode(shareTokenAuthKeyData.shareTokenEcdsaKeyEncryptionKeySalt);
      const shareTokenEcdsaKeyEncryptionKey = await Crypto.ecdsa.importEcdsaKeyEncryptionKeyFromMaster(shareTokenHkdfKey, shareTokenEcdsaKeyEncryptionKeySalt);
      const shareTokenEncryptedEcdsaPrivateKey = external_base64_arraybuffer_default.a.decode(shareTokenAuthKeyData.shareTokenEncryptedEcdsaPrivateKey);
      const shareTokenEcdsaPrivateKeyRaw = await Crypto.aesGcm.decrypt(shareTokenEcdsaKeyEncryptionKey, shareTokenEncryptedEcdsaPrivateKey);
      shareTokenEcdsaPrivateKey = await Crypto.ecdsa.getPrivateKeyFromRawPrivateKey(shareTokenEcdsaPrivateKeyRaw);
    } catch (_unused5) {
      throw new errors.ShareTokenInvalid();
    } // sign validation message sent by the server


    const signedValidationMessage = await Crypto.ecdsa.sign(shareTokenEcdsaPrivateKey, external_base64_arraybuffer_default.a.decode(validationMessage));
    return {
      databaseId,
      validationMessage,
      signedValidationMessage: external_base64_arraybuffer_default.a.encode(signedValidationMessage)
    };
  }

}

/* harmony default export */ var src_ws = (new ws_Connection());
// CONCATENATED MODULE: ./src/auth.js


function auth_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function auth_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { auth_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { auth_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }










const MAX_PASSWORD_CHAR_LENGTH = 1000;
const MIN_PASSWORD_CHAR_LENGTH = 6;
const REMEMBER_ME_OPTIONS = {
  local: true,
  session: true,
  none: true
};
const KEY_NOT_FOUND_ON_SIGN_IN = "Device not recognized. This temporary password can only be used to sign in from a device you've signed in from before.";
const KEY_NOT_FOUND_ON_FORGOT_PASSWORD = "Device not recognized. Forgot password only works from a device you've signed in from before.";

const _checkSignedInState = () => {
  if (src_ws.reconnecting) throw new errors.Reconnecting();
  if (!src_ws.keys.init && src_ws.changePassword) throw new errors.UserMustChangePassword();
  if (!src_ws.keys.init) throw new errors.UserNotSignedIn();
};

const _parseGenericErrors = e => {
  if (e.response) {
    if (e.response.data === 'Domain not whitelisted') {
      throw new errors.DomainNotWhitelisted(window.location.origin);
    } else if (e.response.data === 'App ID not valid') {
      throw new errors.AppIdNotValid();
    } else if (e.response.data === 'UserNotFound') {
      throw new errors.UserNotFound();
    } else if (e.response.status === statusCodes['Internal Server Error']) {
      throw new errors.InternalServerError();
    } else if (e.response.status === statusCodes['Gateway Timeout']) {
      throw new errors.Timeout();
    }
  } else if (e.message && e.message.indexOf('timeout') !== -1) {
    throw new errors.Timeout();
  }
};

const _connectWebSocket = async (session, seed, rememberMe, changePassword) => {
  try {
    await src_ws.connect(session, seed, rememberMe, changePassword);
  } catch (e) {
    _parseGenericErrors(e);

    if (e.message === 'Web Socket already connected') {
      throw new errors.UserAlreadySignedIn(e.username);
    }

    throw e;
  }
};

const _parseGenericUsernamePasswordError = e => {
  if (e.response && e.response.data.error === 'UsernameTooLong') {
    throw new errors.UsernameTooLong(e.response.data.maxLen);
  } else if (e.response && e.response.data.error === 'PasswordAttemptLimitExceeded') {
    throw new errors.PasswordAttemptLimitExceeded(e.response.data.delay);
  }
};

const _parseSessionLengthError = e => {
  if (e.response && e.response.data) {
    const data = e.response.data;

    switch (data.error) {
      case 'SessionLengthTooShort':
        throw new errors.SessionLengthTooShort(data.minLen);

      case 'SessionLengthTooLong':
        throw new errors.SessionLengthTooLong(data.maxLen);
    }
  }
};

const _parseUserResponseError = (e, username) => {
  _parseGenericErrors(e);

  _parseGenericUsernamePasswordError(e);

  if (e.response) {
    const data = e.response.data;

    switch (data) {
      case 'UsernameAlreadyExists':
        throw new errors.UsernameAlreadyExists(username);

      case 'TrialExceededLimit':
        throw new errors.TrialExceededLimit();

      case 'CurrentPasswordIncorrect':
        throw new errors.CurrentPasswordIncorrect();

      default: // continue

    }

    switch (data.error) {
      case 'EmailNotValid':
        throw new errors.EmailNotValid();

      case 'ProfileMustBeObject':
        throw new errors.ProfileMustBeObject();

      case 'ProfileKeyTooLong':
        throw new errors.ProfileKeyTooLong(data.maxLen, data.key);

      case 'ProfileValueMustBeString':
        throw new errors.ProfileValueMustBeString(data.key, data.value);

      case 'ProfileValueCannotBeBlank':
        throw new errors.ProfileValueCannotBeBlank(data.key);

      case 'ProfileValueTooLong':
        throw new errors.ProfileValueTooLong(data.maxLen, data.key, data.value);

      case 'ProfileHasTooManyKeys':
        throw new errors.ProfileHasTooManyKeys(data.maxKeys);

      case 'ProfileCannotBeEmpty':
        throw new errors.ProfileCannotBeEmpty();
    }
  }

  throw e;
};

const _calculateSessionLengthMs = sessionLength => sessionLength && sessionLength * 60 * 60 * 1000;

const _validateUsername = username => {
  if (typeof username !== 'string') throw new errors.UsernameMustBeString();
  if (username.length === 0) throw new errors.UsernameCannotBeBlank();
};

const _validatePassword = password => {
  if (typeof password !== 'string') throw new errors.PasswordMustBeString();
  if (password.length === 0) throw new errors.PasswordCannotBeBlank();
  if (password.length < MIN_PASSWORD_CHAR_LENGTH) throw new errors.PasswordTooShort(MIN_PASSWORD_CHAR_LENGTH);
  if (password.length > MAX_PASSWORD_CHAR_LENGTH) throw new errors.PasswordTooLong(MAX_PASSWORD_CHAR_LENGTH);
};

const _validateSignUpOrSignInInput = params => {
  if (typeof params !== 'object') throw new errors.ParamsMustBeObject();
  if (!objectHasOwnProperty(params, 'username')) throw new errors.UsernameMissing();
  if (!objectHasOwnProperty(params, 'password')) throw new errors.PasswordMissing();

  _validateUsername(params.username);

  _validatePassword(params.password);

  if (objectHasOwnProperty(params, 'rememberMe') && !REMEMBER_ME_OPTIONS[params.rememberMe]) {
    throw new errors.RememberMeValueNotValid(REMEMBER_ME_OPTIONS);
  }

  if (objectHasOwnProperty(params, 'sessionLength') && typeof params.sessionLength !== 'number') {
    throw new errors.SessionLengthMustBeNumber();
  }
};

const _generatePasswordToken = async (password, seed, passwordHashAlgo) => {
  const passwordSalt = Crypto.scrypt.generateSalt();
  const passwordHash = await Crypto.scrypt.hash(password, passwordSalt, passwordHashAlgo);
  const passwordHkdfKey = await Crypto.hkdf.importHkdfKeyFromString(passwordHash);
  const passwordTokenSalt = Crypto.hkdf.generateSalt();
  const passwordToken = await Crypto.hkdf.getPasswordToken(passwordHkdfKey, passwordTokenSalt);
  const passwordBasedEncryptionKeySalt = Crypto.hkdf.generateSalt();
  const passwordBasedEncryptionKey = await Crypto.aesGcm.getPasswordBasedEncryptionKey(passwordHkdfKey, passwordBasedEncryptionKeySalt);
  const passwordEncryptedSeed = await Crypto.aesGcm.encrypt(passwordBasedEncryptionKey, seed);
  const passwordSalts = {
    passwordSalt: external_base64_arraybuffer_default.a.encode(passwordSalt),
    passwordTokenSalt: external_base64_arraybuffer_default.a.encode(passwordTokenSalt)
  };
  const passwordBasedBackup = {
    passwordBasedEncryptionKeySalt: external_base64_arraybuffer_default.a.encode(passwordBasedEncryptionKeySalt),
    passwordEncryptedSeed: external_base64_arraybuffer_default.a.encode(passwordEncryptedSeed)
  };
  return {
    passwordToken,
    passwordSalts,
    passwordBasedBackup
  };
};

const _generateKeys = async seed => {
  const masterKey = await Crypto.hkdf.importHkdfKey(seed);
  const encryptionKeySalt = Crypto.hkdf.generateSalt();
  const hmacKeySalt = Crypto.hkdf.generateSalt();
  const keySalts = {
    encryptionKeySalt: external_base64_arraybuffer_default.a.encode(encryptionKeySalt),
    hmacKeySalt: external_base64_arraybuffer_default.a.encode(hmacKeySalt)
  };
  const ecdsaKeyData = await Crypto.ecdsa.generateEcdsaKeyData(masterKey);
  const ecdhKeyData = await Crypto.ecdh.generateEcdhKeyData(masterKey, ecdsaKeyData.ecdsaPrivateKey);
  delete ecdsaKeyData.ecdsaPrivateKey;
  delete ecdhKeyData.ecdhPrivateKey;
  const ecKeyData = {
    ecdsaKeyData,
    ecdhKeyData
  };
  return {
    ecKeyData,
    keySalts
  };
};

const _generateKeysAndSignUp = async (username, password, seed, passwordHashAlgo, email, profile, sessionLength) => {
  const {
    passwordToken,
    passwordSalts,
    passwordBasedBackup
  } = await _generatePasswordToken(password, seed, passwordHashAlgo);
  const {
    ecKeyData,
    keySalts
  } = await _generateKeys(seed);

  try {
    const session = await api_auth.signUp(username, passwordToken, ecKeyData, passwordSalts, keySalts, email, profile, passwordBasedBackup, sessionLength);
    return session;
  } catch (e) {
    _parseSessionLengthError(e);

    _parseUserResponseError(e, username);
  }
};

const _validateProfile = profile => {
  if (typeof profile !== 'object') throw new errors.ProfileMustBeObject();
  let keyExists = false;

  for (const key in profile) {
    keyExists = true;
    const value = profile[key];
    if (typeof value !== 'string') throw new errors.ProfileValueMustBeString(key, value);
    if (!value) throw new errors.ProfileValueCannotBeBlank(key);
  }

  if (!keyExists) throw new errors.ProfileCannotBeEmpty();
};

const _validateSignUpInput = params => {
  _validateSignUpOrSignInInput(params);

  if (params.profile) _validateProfile(params.profile);
  if (params.email && typeof params.email !== 'string') throw new errors.EmailNotValid();
};

const auth_signUp = async params => {
  try {
    _validateSignUpInput(params);

    const {
      password,
      profile,
      passwordHashAlgo,
      rememberMe = 'session'
    } = params;
    const username = params.username.toLowerCase();
    const email = params.email && params.email.toLowerCase();
    const appId = src_config.getAppId();
    const seed = await Crypto.generateSeed();

    const sessionLength = _calculateSessionLengthMs(params.sessionLength);

    const {
      sessionId,
      creationDate,
      expirationDate,
      userId,
      authToken
    } = await _generateKeysAndSignUp(username, password, seed, passwordHashAlgo, email, profile, sessionLength);
    const session = {
      username,
      userId,
      sessionId,
      creationDate,
      expirationDate,
      authToken
    };
    const seedString = external_base64_arraybuffer_default.a.encode(seed);
    localData.saveSeedString(rememberMe, appId, username, seedString);
    localData.signInSession(rememberMe, username, sessionId, creationDate, expirationDate);
    await _connectWebSocket(session, seedString, rememberMe);
    return src_ws.buildUserResult({
      username,
      userId,
      authToken,
      email,
      profile,
      userData: src_ws.userData
    });
  } catch (e) {
    switch (e.name) {
      case 'ParamsMustBeObject':
      case 'UsernameMissing':
      case 'UsernameAlreadyExists':
      case 'UsernameCannotBeBlank':
      case 'UsernameMustBeString':
      case 'UsernameTooLong':
      case 'PasswordMissing':
      case 'PasswordCannotBeBlank':
      case 'PasswordTooShort':
      case 'PasswordTooLong':
      case 'PasswordMustBeString':
      case 'EmailNotValid':
      case 'ProfileMustBeObject':
      case 'ProfileCannotBeEmpty':
      case 'ProfileHasTooManyKeys':
      case 'ProfileKeyTooLong':
      case 'ProfileValueMustBeString':
      case 'ProfileValueCannotBeBlank':
      case 'ProfileValueTooLong':
      case 'RememberMeValueNotValid':
      case 'SessionLengthMustBeNumber':
      case 'SessionLengthTooShort':
      case 'SessionLengthTooLong':
      case 'TrialExceededLimit':
      case 'AppIdNotSet':
      case 'AppIdNotValid':
      case 'DomainNotWhitelisted':
      case 'UserAlreadySignedIn':
      case 'ServiceUnavailable':
        throw e;

      default:
        throw new errors.UnknownServiceUnavailable(e);
    }
  }
};

const signOut = async () => {
  try {
    if (!src_ws.session.username) throw new errors.UserNotSignedIn();

    try {
      await src_ws.signOut();
    } catch (e) {
      _parseGenericErrors(e);

      throw e;
    }
  } catch (e) {
    switch (e.name) {
      case 'UserNotSignedIn':
      case 'ServiceUnavailable':
        throw e;

      default:
        throw new errors.UnknownServiceUnavailable(e);
    }
  }
};

const _getSeedStringFromPasswordBasedBackup = async (passwordHkdfKey, passwordBasedBackup) => {
  const {
    passwordBasedEncryptionKeySalt,
    passwordEncryptedSeed
  } = passwordBasedBackup;
  const passwordBasedEncryptionKey = await Crypto.aesGcm.getPasswordBasedEncryptionKey(passwordHkdfKey, external_base64_arraybuffer_default.a.decode(passwordBasedEncryptionKeySalt));
  const seedFromBackup = await Crypto.aesGcm.decrypt(passwordBasedEncryptionKey, external_base64_arraybuffer_default.a.decode(passwordEncryptedSeed));
  const seedStringFromBackup = external_base64_arraybuffer_default.a.encode(seedFromBackup);
  return seedStringFromBackup;
};

const _signInWrapper = async (username, passwordToken, sessionLength) => {
  try {
    const apiSignInResult = await api_auth.signIn(username, passwordToken, sessionLength);
    return apiSignInResult;
  } catch (e) {
    _parseGenericErrors(e);

    _parseGenericUsernamePasswordError(e);

    _parseSessionLengthError(e);

    if (e.response && e.response.data === 'Invalid password') {
      throw new errors.UsernameOrPasswordMismatch();
    } else if (e.response && e.response.data === 'User pending deletion') {
      throw new errors.UserPendingDeletion();
    }

    throw e;
  }
};

const _getPasswordSaltsOverRestEndpoint = async username => {
  try {
    const passwordSalts = await api_auth.getPasswordSalts(username);
    return passwordSalts;
  } catch (e) {
    _parseGenericErrors(e);

    _parseGenericUsernamePasswordError(e);

    if (e.response && e.response.data === 'User not found') {
      throw new errors.UsernameOrPasswordMismatch();
    }

    throw e;
  }
};

const _getPasswordSaltsOverWebSocket = async () => {
  try {
    const action = 'GetPasswordSalts';
    const passwordSaltsResponse = await src_ws.request(action);
    return passwordSaltsResponse.data;
  } catch (e) {
    _parseGenericErrors(e);

    throw e;
  }
};

const _rebuildPasswordToken = async (password, passwordSalts, passwordHashAlgo) => {
  const {
    passwordSalt,
    passwordTokenSalt
  } = passwordSalts;
  const passwordHash = await Crypto.scrypt.hash(password, new Uint8Array(external_base64_arraybuffer_default.a.decode(passwordSalt)), passwordHashAlgo);
  const passwordHkdfKey = await Crypto.hkdf.importHkdfKeyFromString(passwordHash);
  const passwordToken = await Crypto.hkdf.getPasswordToken(passwordHkdfKey, external_base64_arraybuffer_default.a.decode(passwordTokenSalt));
  return {
    passwordHkdfKey,
    passwordToken
  };
};

const auth_signIn = async params => {
  try {
    _validateSignUpOrSignInInput(params);

    const username = params.username.toLowerCase();
    const {
      password,
      passwordHashAlgo,
      rememberMe = 'session'
    } = params;
    const appId = src_config.getAppId();
    const passwordSalts = await _getPasswordSaltsOverRestEndpoint(username);
    const {
      passwordHkdfKey,
      passwordToken
    } = await _rebuildPasswordToken(password, passwordSalts, passwordHashAlgo);

    const sessionLength = _calculateSessionLengthMs(params.sessionLength);

    const apiSignInResult = await _signInWrapper(username, passwordToken, sessionLength);
    const {
      userId,
      email,
      profile,
      passwordBasedBackup,
      protectedProfile,
      usedTempPassword,
      changePassword
    } = apiSignInResult;

    const session = auth_objectSpread(auth_objectSpread({}, apiSignInResult.session), {}, {
      username,
      userId
    });

    let seedString;

    if (!changePassword) {
      const savedSeedString = localData.getSeedString(appId, username);
      let seedStringFromBackup;

      if (!savedSeedString && usedTempPassword) {
        throw new errors.KeyNotFound(KEY_NOT_FOUND_ON_SIGN_IN);
      } else if (!usedTempPassword) {
        // always use seed from backup in case it's changed and local copy is out of date
        seedStringFromBackup = await _getSeedStringFromPasswordBasedBackup(passwordHkdfKey, passwordBasedBackup);
        localData.saveSeedString(rememberMe, appId, username, seedStringFromBackup);
      }

      seedString = seedStringFromBackup || savedSeedString;
    }

    localData.signInSession(rememberMe, username, session.sessionId, session.creationDate, session.expirationDate);

    try {
      await _connectWebSocket(session, seedString, rememberMe, changePassword);
    } catch (e) {
      if (usedTempPassword && e.message === 'Invalid seed') throw new errors.KeyNotFound(KEY_NOT_FOUND_ON_SIGN_IN);
      throw e;
    }

    return src_ws.buildUserResult({
      username,
      userId,
      authToken: session.authToken,
      email,
      profile,
      protectedProfile,
      usedTempPassword,
      changePassword,
      userData: src_ws.userData
    });
  } catch (e) {
    switch (e.name) {
      case 'ParamsMustBeObject':
      case 'UsernameMissing':
      case 'UsernameOrPasswordMismatch':
      case 'UserPendingDeletion':
      case 'UsernameCannotBeBlank':
      case 'UsernameTooLong':
      case 'UsernameMustBeString':
      case 'PasswordMissing':
      case 'PasswordCannotBeBlank':
      case 'PasswordTooShort':
      case 'PasswordTooLong':
      case 'PasswordMustBeString':
      case 'PasswordAttemptLimitExceeded':
      case 'RememberMeValueNotValid':
      case 'SessionLengthMustBeNumber':
      case 'SessionLengthTooShort':
      case 'SessionLengthTooLong':
      case 'KeyNotFound':
      case 'AppIdNotSet':
      case 'AppIdNotValid':
      case 'DomainNotWhitelisted':
      case 'UserAlreadySignedIn':
      case 'ServiceUnavailable':
        throw e;

      default:
        throw new errors.UnknownServiceUnavailable(e);
    }
  }
};

const init = async params => {
  try {
    if (!window.crypto.subtle) throw new errors.WebCryptoUnavailable();
    if (typeof params !== 'object') throw new errors.ParamsMustBeObject();
    if (!objectHasOwnProperty(params, 'appId')) throw new errors.AppIdMissing();
    if (typeof params.appId !== 'string') throw new errors.AppIdMustBeString();
    if (params.appId.length === 0) throw new errors.AppIdCannotBeBlank();

    if (objectHasOwnProperty(params, 'updateUserHandler') && typeof params.updateUserHandler !== 'function') {
      throw new errors.UpdateUserHandlerMustBeFunction();
    }

    if (objectHasOwnProperty(params, 'sessionLength') && typeof params.sessionLength !== 'number') {
      throw new errors.SessionLengthMustBeNumber();
    }

    if (objectHasOwnProperty(params, 'allowServerSideEncryption') && typeof params.allowServerSideEncryption !== 'boolean') {
      throw new errors.AllowServerSideEncryptionMustBeBoolean();
    }

    src_config.configure(params);
    const session = await auth_signInWithSession(params.appId, _calculateSessionLengthMs(params.sessionLength));
    return session;
  } catch (e) {
    switch (e.name) {
      case 'WebCryptoUnavailable':
      case 'ParamsMustBeObject':
      case 'AppIdMissing':
      case 'AppIdAlreadySet':
      case 'AppIdMustBeString':
      case 'AppIdCannotBeBlank':
      case 'AppIdNotValid':
      case 'DomainNotWhitelisted':
      case 'UpdateUserHandlerMustBeFunction':
      case 'SessionLengthMustBeNumber':
      case 'SessionLengthTooShort':
      case 'SessionLengthTooLong':
      case 'AllowServerSideEncryptionMustBeBoolean':
      case 'UserAlreadySignedIn':
      case 'ServiceUnavailable':
        throw e;

      default:
        throw new errors.UnknownServiceUnavailable(e);
    }
  }
};

const auth_signInWithSession = async (appId, sessionLength) => {
  let lastUsedUsername;

  try {
    const currentSession = localData.getCurrentSession();
    if (!currentSession) return {};
    const {
      signedIn,
      sessionId,
      creationDate,
      expirationDate,
      rememberMe
    } = currentSession;
    lastUsedUsername = currentSession.username;
    const savedSeedString = localData.getSeedString(appId, lastUsedUsername);

    if (!signedIn || !savedSeedString || new Date() > new Date(expirationDate)) {
      return {
        lastUsedUsername
      };
    }

    let apiSignInWithSessionResult;

    try {
      apiSignInWithSessionResult = await api_auth.signInWithSession(sessionId, sessionLength);
    } catch (e) {
      _parseGenericErrors(e);

      _parseSessionLengthError(e);

      if (e.response && e.response.data === 'Session invalid') {
        return {
          lastUsedUsername
        };
      }

      throw e;
    }

    const {
      userId,
      authToken,
      username,
      email,
      profile,
      protectedProfile
    } = apiSignInWithSessionResult; // overwrite local data if username has been changed on server

    if (username !== lastUsedUsername) {
      localData.saveSeedString(rememberMe, appId, username, savedSeedString);
      localData.removeSeedString(appId, lastUsedUsername);
    } // expirationDate should have been extended


    localData.signInSession(rememberMe, username, sessionId, creationDate, apiSignInWithSessionResult.expirationDate); // enable idempotent calls to init()

    if (src_ws.connectionResolved) {
      if (src_ws.session.sessionId === sessionId) {
        return {
          user: src_ws.buildUserResult({
            username,
            userId,
            authToken: src_ws.session.authToken,
            email,
            profile,
            protectedProfile,
            userData: src_ws.userData
          })
        };
      } else {
        throw new errors.UserAlreadySignedIn(src_ws.session.username);
      }
    }

    const session = auth_objectSpread(auth_objectSpread({}, currentSession), {}, {
      username,
      userId,
      authToken
    });

    await _connectWebSocket(session, savedSeedString, rememberMe);
    return {
      user: src_ws.buildUserResult({
        username,
        userId,
        authToken,
        email,
        profile,
        protectedProfile,
        userData: src_ws.userData
      })
    };
  } catch (e) {
    if (e.message === 'Invalid seed') return {
      lastUsedUsername
    };

    _parseGenericErrors(e);

    throw e;
  }
};

const _validateUpdatedUserInput = params => {
  if (!objectHasOwnProperty(params, 'username') && !objectHasOwnProperty(params, 'newPassword') && !objectHasOwnProperty(params, 'email') && !objectHasOwnProperty(params, 'profile')) {
    throw new errors.ParamsMissing();
  }

  const {
    username,
    currentPassword,
    newPassword,
    email,
    profile
  } = params;
  if (objectHasOwnProperty(params, 'username')) _validateUsername(username);

  if (objectHasOwnProperty(params, 'newPassword')) {
    if (!objectHasOwnProperty(params, 'currentPassword')) throw new errors.CurrentPasswordMissing();

    _validatePassword(currentPassword);

    _validatePassword(newPassword);
  } // if email or profile are falsey, will be set to false


  if (email && typeof email !== 'string') throw new errors.EmailNotValid();
  if (profile) _validateProfile(profile);
};

const _buildUpdateUserParams = async (params, newSeed) => {
  if (params.username) params.username = params.username.toLowerCase();

  if (params.newPassword) {
    const [currentPasswordSalts, newPasswordPromise, newKeyData] = await Promise.all([_getPasswordSaltsOverWebSocket(), _generatePasswordToken(params.newPassword, newSeed || external_base64_arraybuffer_default.a.decode(src_ws.seedString)), newSeed && _generateKeys(newSeed)]); // current password

    const {
      passwordToken
    } = await _rebuildPasswordToken(params.currentPassword, currentPasswordSalts, params.passwordHashAlgo);
    params.currentPasswordToken = passwordToken;
    delete params.currentPassword; // new password

    params.passwordToken = newPasswordPromise.passwordToken;
    params.passwordSalts = newPasswordPromise.passwordSalts;
    params.passwordBasedBackup = newPasswordPromise.passwordBasedBackup;
    delete params.newPassword;
    if (newKeyData) params.newKeyData = newKeyData;
  }

  if (params.email) params.email = params.email.toLowerCase();else if (objectHasOwnProperty(params, 'email')) params.email = false; // marks email for deletion

  if (!params.profile && objectHasOwnProperty(params, 'profile')) params.profile = false; // marks profile for deletion

  return params;
};

const updateUser = async params => {
  try {
    if (typeof params !== 'object') throw new errors.ParamsMustBeObject();

    _validateUpdatedUserInput(params);

    if (src_ws.reconnecting) throw new errors.Reconnecting();
    if (!src_ws.connectionResolved) throw new errors.UserNotSignedIn();
    const startingUserId = src_ws.session.userId; // need to generate new seed to rotate keys if user signed in with temp password to delete private data

    const newSeed = params.newPassword && !src_ws.keys.init && src_ws.changePassword && (await Crypto.generateSeed());
    const action = 'UpdateUser';
    const finalParams = await _buildUpdateUserParams(auth_objectSpread({}, params), newSeed);
    if (src_ws.reconnecting) throw new errors.Reconnecting();
    if (!src_ws.connectionResolved) throw new errors.UserNotSignedIn(); // ensures same user still attempting to update

    if (!src_ws.session || startingUserId !== src_ws.session.userId) throw new errors.ServiceUnavailable();

    try {
      if (finalParams.username) {
        localData.saveSeedString(src_ws.rememberMe, src_config.getAppId(), finalParams.username, src_ws.seedString);
      }

      const response = await src_ws.request(action, finalParams);
      const updatedUser = response.data.updatedUser;
      src_ws.handleUpdateUser(updatedUser); // must have rotated keys successfully

      if (newSeed && src_ws.session && startingUserId === src_ws.session.userId) {
        const newSeedString = external_base64_arraybuffer_default.a.encode(newSeed);
        await src_ws.rotateKeys(newSeedString, finalParams.newKeyData);
        localData.saveSeedString(src_ws.rememberMe, src_config.getAppId(), updatedUser.username, newSeedString);
        const {
          sessionId,
          creationDate,
          expirationDate
        } = src_ws.session;
        localData.signInSession(src_ws.rememberMe, updatedUser.username, sessionId, creationDate, expirationDate);
      }
    } catch (e) {
      _parseUserResponseError(e, finalParams.username);
    }
  } catch (e) {
    switch (e.name) {
      case 'ParamsMustBeObject':
      case 'ParamsMissing':
      case 'UsernameAlreadyExists':
      case 'UsernameMustBeString':
      case 'UsernameCannotBeBlank':
      case 'UsernameTooLong':
      case 'CurrentPasswordMissing':
      case 'CurrentPasswordIncorrect':
      case 'PasswordAttemptLimitExceeded':
      case 'PasswordMustBeString':
      case 'PasswordCannotBeBlank':
      case 'PasswordTooShort':
      case 'PasswordTooLong':
      case 'EmailNotValid':
      case 'ProfileMustBeObject':
      case 'ProfileCannotBeEmpty':
      case 'ProfileHasTooManyKeys':
      case 'ProfileKeyTooLong':
      case 'ProfileValueMustBeString':
      case 'ProfileValueCannotBeBlank':
      case 'ProfileValueTooLong':
      case 'AppIdNotSet':
      case 'AppIdNotValid':
      case 'UserNotFound':
      case 'UserNotSignedIn':
      case 'TooManyRequests':
      case 'ServiceUnavailable':
        throw e;

      default:
        throw new errors.UnknownServiceUnavailable(e);
    }
  }
};

const deleteUser = async () => {
  try {
    _checkSignedInState();

    const username = src_ws.session.username;
    localData.removeSeedString(src_config.getAppId(), username);
    localData.removeCurrentSession();

    try {
      const action = 'DeleteUser';
      await src_ws.request(action);
    } catch (e) {
      _parseGenericErrors(e);

      throw e;
    }

    src_ws.close();
  } catch (e) {
    switch (e.name) {
      case 'UserMustChangePassword':
      case 'UserNotSignedIn':
      case 'UserNotFound':
      case 'TooManyRequests':
      case 'ServiceUnavailable':
        throw e;

      default:
        throw new errors.UnknownServiceUnavailable(e);
    }
  }
};

const _getMasterKeyAndKeyNotFoundMessage = async (appId, username) => {
  const seedString = localData.getSeedString(appId, username);
  if (!seedString) throw new errors.KeyNotFound(KEY_NOT_FOUND_ON_FORGOT_PASSWORD);
  const seed = external_base64_arraybuffer_default.a.decode(seedString);
  const masterKey = await Crypto.hkdf.importHkdfKey(seed);
  return masterKey;
};

const forgotPassword = async params => {
  try {
    if (typeof params !== 'object') throw new errors.ParamsMustBeObject();

    if (objectHasOwnProperty(params, 'deleteEndToEndEncryptedData') && typeof params.deleteEndToEndEncryptedData !== 'boolean') {
      throw new errors.DeleteEndToEndEncryptedDataMustBeBoolean();
    }

    if (!objectHasOwnProperty(params, 'username')) throw new errors.UsernameMissing();

    _validateUsername(params.username);

    const username = params.username.toLowerCase();
    const appId = src_config.getAppId();
    const url = "".concat(getWsUrl(src_config.getEndpoint()), "/api/auth/forgot-password?appId=").concat(appId, "&username=").concat(encodeURIComponent(username), "&userbaseJsVersion=").concat(src_config.USERBASE_JS_VERSION);
    const forgotPasswordWs = new WebSocket(url + (objectHasOwnProperty(params, 'deleteEndToEndEncryptedData') ? "&deleteEndToEndEncryptedData=".concat(params.deleteEndToEndEncryptedData) : ''));
    await new Promise((resolve, reject) => {
      setTimeout(() => reject(new errors.Timeout()), 15000);

      forgotPasswordWs.onerror = () => reject(new errors.ServiceUnavailable());

      forgotPasswordWs.onmessage = async e => {
        try {
          const message = JSON.parse(e.data);

          switch (message.route) {
            // users created with userbase-js < v2.0.0 that have not signed in yet will need to prove access to DH key by decrypting token
            case 'ReceiveEncryptedToken':
              {
                const masterKey = await _getMasterKeyAndKeyNotFoundMessage(appId, username); // if client decrypts encrypted token successfully, proves to server it has the user's key

                const encryptedForgotPasswordToken = new Uint8Array(message.encryptedForgotPasswordToken.data);
                const dhPrivateKey = await Crypto.diffieHellman.importKeyFromMaster(masterKey, external_base64_arraybuffer_default.a.decode(message.dhKeySalt));
                const sharedKey = await Crypto.diffieHellman.getSharedKeyWithServer(dhPrivateKey);
                let forgotPasswordToken;

                try {
                  // if it fails to decrypt, it's almost certainly because key is incorrect
                  forgotPasswordToken = external_base64_arraybuffer_default.a.encode(await Crypto.aesGcm.decrypt(sharedKey, encryptedForgotPasswordToken));
                } catch (_unused) {
                  throw new errors.KeyNotFound(KEY_NOT_FOUND_ON_FORGOT_PASSWORD);
                }

                forgotPasswordWs.send(JSON.stringify({
                  action: 'ForgotPassword',
                  params: {
                    forgotPasswordToken
                  }
                }));
                break;
              }
            // users signed in with userbase-js >= v2.0.1 will need to prove access to ECDSA key by signing token

            case 'ReceiveToken':
              {
                const masterKey = await _getMasterKeyAndKeyNotFoundMessage(appId, username);
                const {
                  ecdsaKeyEncryptionKeySalt,
                  encryptedEcdsaPrivateKey,
                  forgotPasswordToken
                } = message;
                const ecdsaKeyEncryptionKey = await Crypto.ecdsa.importEcdsaKeyEncryptionKeyFromMaster(masterKey, external_base64_arraybuffer_default.a.decode(ecdsaKeyEncryptionKeySalt));
                let ecdsaPrivateKey;

                try {
                  // if it fails to decrypt, it's almost certainly because key is incorrect
                  const rawEcdsaPrivateKey = await Crypto.aesGcm.decrypt(ecdsaKeyEncryptionKey, external_base64_arraybuffer_default.a.decode(encryptedEcdsaPrivateKey));
                  ecdsaPrivateKey = await Crypto.ecdsa.getPrivateKeyFromRawPrivateKey(rawEcdsaPrivateKey);
                } catch (_unused2) {
                  throw new errors.KeyNotFound(KEY_NOT_FOUND_ON_FORGOT_PASSWORD);
                }

                const signedForgotPasswordToken = external_base64_arraybuffer_default.a.encode(await Crypto.ecdsa.sign(ecdsaPrivateKey, external_base64_arraybuffer_default.a.decode(forgotPasswordToken)));
                forgotPasswordWs.send(JSON.stringify({
                  action: 'ForgotPassword',
                  params: {
                    signedForgotPasswordToken
                  }
                }));
                break;
              }

            case 'SuccessfullyForgotPassword':
              {
                // server has sent the email
                resolve();
                break;
              }

            case 'Error':
              {
                const data = message.data;

                switch (data.name) {
                  case 'UsernameTooLong':
                    throw new errors.UsernameTooLong(data.maxLen);

                  case 'AppIdNotValid':
                    throw new errors.AppIdNotValid();

                  case 'UserNotFound':
                    throw new errors.UserNotFound();

                  case 'UserEmailNotFound':
                    throw new errors.UserEmailNotFound();

                  default:
                    {
                      if (message.status === statusCodes['Internal Server Error']) throw new errors.ServiceUnavailable();else throw new errors.UnknownServiceUnavailable(data);
                    }
                }
              }

            case 'Ping':
              {
                // ignore -- websocket connection should only exist for the life of the forgot password request
                break;
              }

            default:
              reject(new Error("Received unknown message from userbase-server: ".concat(e.data)));
          }
        } catch (e) {
          reject(e);
        }
      };
    });
    forgotPasswordWs.close();
  } catch (e) {
    switch (e.name) {
      case 'ParamsMustBeObject':
      case 'UsernameMissing':
      case 'UsernameMustBeString':
      case 'UsernameCannotBeBlank':
      case 'UsernameTooLong':
      case 'AppIdNotSet':
      case 'AppIdNotValid':
      case 'KeyNotFound':
      case 'UserNotFound':
      case 'UserEmailNotFound':
      case 'ServiceUnavailable':
        throw e;

      default:
        throw new errors.UnknownServiceUnavailable(e);
    }
  }
};

/* harmony default export */ var src_auth = ({
  signUp: auth_signUp,
  signOut,
  signIn: auth_signIn,
  init,
  updateUser,
  deleteUser,
  forgotPassword
});
// EXTERNAL MODULE: external "sorted-array"
var external_sorted_array_ = __webpack_require__(5);
var external_sorted_array_default = /*#__PURE__*/__webpack_require__.n(external_sorted_array_);

// CONCATENATED MODULE: ./src/db.js


function db_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function db_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { db_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { db_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }












const success = 'Success';
const MAX_DB_NAME_CHAR_LENGTH = 100;
const MAX_ITEM_ID_CHAR_LENGTH = 100;
const MAX_ITEM_KB = 10;
const db_TEN_KB = MAX_ITEM_KB * 1024;
const MAX_ITEM_BYTES = db_TEN_KB;
const UUID_CHAR_LENGTH = 36;
const FILE_CHUNK_SIZE = 1024 * 512; // 512kb

const FILE_CHUNKS_PER_BATCH = 10;
const VERIFIED_USERS_DATABASE_NAME = '__userbase_verified_users';
const ENCRYPTION_MODE_OPTIONS = {
  'end-to-end': true,
  'server-side': true
};
const TX_TIMEOUT = 30 * 1000;

const db_checkSignedInState = () => {
  if (src_ws.reconnecting) throw new errors.Reconnecting();
  if (!src_ws.keys.init && src_ws.changePassword) throw new errors.UserMustChangePassword();
  if (!src_ws.keys.init || !ENCRYPTION_MODE_OPTIONS[src_ws.encryptionMode]) throw new errors.UserNotSignedIn();
};

const db_parseGenericErrors = e => {
  if (e.response) {
    if (e.response.data === 'UserNotFound') {
      throw new errors.UserNotFound();
    } else if (e.response.status === statusCodes['Internal Server Error']) {
      throw new errors.InternalServerError();
    } else if (e.response.status === statusCodes['Gateway Timeout']) {
      throw new errors.Timeout();
    }
  } else if (e.message && e.message.indexOf('timeout') !== -1) {
    throw new errors.Timeout();
  }
};

class UnverifiedTransaction {
  constructor(startSeqNo) {
    this.startSeqNo = startSeqNo;
    this.txSeqNo = null;
    this.transactions = {};
    this.promiseResolve = null;
    this.promiseReject = null;
    this.index = null;
  }

  getStartSeqNo() {
    return this.startSeqNo;
  }

  getIndex() {
    return this.index;
  }

  setIndex(index) {
    this.index = index;
  }

  async getResult(seqNo) {
    this.txSeqNo = seqNo;
    const promise = new Promise((resolve, reject) => {
      this.promiseResolve = resolve;
      this.promiseReject = reject;
      setTimeout(() => {
        reject(new Error('timeout'));
      }, TX_TIMEOUT);
    });
    this.verifyPromise();
    return promise;
  }

  verifyPromise() {
    if (!this.txSeqNo && this.txSeqNo != 0) {
      return;
    }

    if (!this.promiseResolve || !this.promiseReject) {
      return;
    }

    if (this.transactions[this.txSeqNo]) {
      if (this.transactions[this.txSeqNo] == 'Success') {
        this.promiseResolve();
      } else {
        this.promiseReject(this.transactions[this.txSeqNo]);
      }
    }
  }

  addTransaction(transaction, code) {
    if (this.transactions[transaction.seqNo]) return;
    this.transactions[transaction.seqNo] = code;
    this.verifyPromise();
  }

}

class db_Database {
  constructor(changeHandler, receivedMessage, shareTokenId, shareTokenHkdfKey) {
    this.onChange = _setChangeHandler(changeHandler);
    this.items = {};
    this.itemsPlaintextMetadata = {};
    this.fileIds = {};

    const compareItems = (a, b) => {
      if (a.seqNo < b.seqNo || a.seqNo === b.seqNo && a.operationIndex < b.operationIndex) {
        return -1;
      }

      if (a.seqNo > b.seqNo || a.seqNo === b.seqNo && a.operationIndex > b.operationIndex) {
        return 1;
      }

      return 0;
    };

    this.itemsIndex = new external_sorted_array_default.a([], compareItems);
    this.unverifiedTransactions = [];
    this.lastSeqNo = 0;
    this.init = false;
    this.dbKey = null;
    this.receivedMessage = receivedMessage;
    this.usernamesByUserId = new Map();
    this.attributionEnabled = false;
    this.shareTokenId = shareTokenId;
    this.shareTokenHkdfKey = shareTokenHkdfKey; // Queue that ensures 'ApplyTransactions' executes one at a time

    this.applyTransactionsQueue = new Queue();
    this.bundleChunks = {};
  }

  async applyTransactions(transactions, ownerId, dbId, dbNameHash) {
    for (let i = 0; i < transactions.length; i++) {
      const transaction = transactions[i];
      const seqNo = transaction.seqNo; // client must only apply transcations in sequence

      if (seqNo !== this.lastSeqNo + 1) {
        console.warn("Client attempted to apply transaction with seq no ".concat(seqNo, " when last seq no is ").concat(this.lastSeqNo));
        continue;
      }

      const transactionCode = await this.applyTransaction(this.dbKey, transaction, ownerId);
      this.lastSeqNo = seqNo;

      for (let j = 0; j < this.unverifiedTransactions.length; j++) {
        if (!this.unverifiedTransactions[j] || seqNo < this.unverifiedTransactions[j].getStartSeqNo()) {
          continue;
        }

        this.unverifiedTransactions[j].addTransaction(transactions[i], transactionCode);
      }

      if (this.init && transactionCode === 'Success') {
        this.onChange(this.getItems());
      }
    }

    if (!this.init) {
      this.init = true; // allows triggers and loaders to be called from within client's changeHandler on database load

      this.dbId = dbId;
      this.dbNameHash = dbNameHash;
      this.onChange(this.getItems());
      this.receivedMessage(); // wait to resolve openDatabase() until changeHandler has received all data
    }
  }

  async applyBundle(bundle, bundleSeqNo) {
    // client must only apply bundle when opening state
    if (this.lastSeqNo !== 0) {
      console.warn("Client attempted to apply bundle when last seq no is ".concat(this.lastSeqNo));
      return;
    }

    for (let i = 0; i < bundle.itemsIndex.length; i++) {
      const itemIndex = bundle.itemsIndex[i];
      const itemId = bundle.itemsIndex[i].itemId;
      const item = bundle.items[i];
      const itemsPlaintextMetadata = bundle.itemsPlaintextMetadata[i];

      if (item.file && item.file.fileEncryptionKeyString) {
        item.file.fileEncryptionKey = await Crypto.aesGcm.getKeyFromKeyString(item.file.fileEncryptionKeyString);
        this.fileIds[item.file.fileId] = itemId;
      }

      this.items[itemId] = item;
      this.itemsPlaintextMetadata[itemId] = itemsPlaintextMetadata;
      this.itemsIndex.insert(itemIndex);
    }

    this.lastSeqNo = bundleSeqNo;
  }

  async applyTransaction(key, transaction, ownerId) {
    const seqNo = transaction.seqNo;
    const command = transaction.command;

    switch (command) {
      case 'Insert':
        {
          try {
            const record = await Crypto.aesGcm.decryptJson(key, transaction.record);
            const itemId = record.id;
            const item = record.item;
            const createdBy = this.attributionFromTransaction(transaction);
            const writeAccess = transaction.writeAccess;
            this.validateInsert(itemId);
            return this.applyInsert(itemId, seqNo, item, createdBy, writeAccess);
          } catch (transactionCode) {
            return transactionCode;
          }
        }

      case 'Update':
        {
          try {
            const record = await Crypto.aesGcm.decryptJson(key, transaction.record);
            const itemId = record.id;
            const item = record.item;
            const updatedBy = this.attributionFromTransaction(transaction);
            const __v = record.__v;
            const writeAccess = transaction.writeAccess;
            this.validateUpdate(itemId, __v, updatedBy, ownerId, writeAccess, 'updateItem');
            return this.applyUpdate(itemId, item, __v, updatedBy, writeAccess);
          } catch (transactionCode) {
            return transactionCode;
          }
        }

      case 'Delete':
        {
          try {
            const record = await Crypto.aesGcm.decryptJson(key, transaction.record);
            const itemId = record.id;
            const deletedBy = this.attributionFromTransaction(transaction);
            const __v = record.__v;
            this.validateUpdateOrDelete(itemId, __v, deletedBy, ownerId, 'deleteItem');
            return this.applyDelete(itemId);
          } catch (transactionCode) {
            return transactionCode;
          }
        }

      case 'BatchTransaction':
        {
          try {
            const batch = transaction.operations;
            const attribution = this.attributionFromTransaction(transaction);
            const recordPromises = [];

            for (const operation of batch) {
              recordPromises.push(operation.record && Crypto.aesGcm.decryptJson(key, operation.record));
            }

            const records = await Promise.all(recordPromises);
            this.validateBatchTransaction(batch, records, attribution, ownerId);
            return this.applyBatchTransaction(seqNo, batch, records, attribution);
          } catch (transactionCode) {
            return transactionCode;
          }
        }

      case 'UploadFile':
        {
          try {
            const fileEncryptionKeyRaw = await Crypto.aesGcm.decrypt(key, external_base64_arraybuffer_default.a.decode(transaction.fileEncryptionKey));
            const fileEncryptionKey = await Crypto.aesGcm.getKeyFromRawKey(fileEncryptionKeyRaw);
            const fileEncryptionKeyString = await Crypto.aesGcm.getKeyStringFromKey(fileEncryptionKey);
            const fileMetadata = await Crypto.aesGcm.decryptJson(fileEncryptionKey, transaction.fileMetadata);
            const itemId = fileMetadata.itemId;
            const fileVersion = fileMetadata.__v;
            const {
              fileName,
              fileSize,
              fileType
            } = fileMetadata;
            const fileId = transaction.fileId;
            const fileUploadedBy = this.attributionFromTransaction(transaction);
            this.validateUploadFile(itemId, fileVersion, fileUploadedBy, ownerId, 'uploadFile');
            return this.applyUploadFile(itemId, fileUploadedBy, fileVersion, fileEncryptionKey, fileEncryptionKeyString, fileName, fileId, fileSize, fileType);
          } catch (transactionCode) {
            return transactionCode;
          }
        }

      case 'Rollback':
        {
          // no-op
          return;
        }

      default:
        {
          console.warn("Unknown command: ".concat(command));
          return;
        }
    }
  }

  attributionFromTransaction(transaction) {
    if (!this.attributionEnabled) return undefined;
    return {
      timestamp: transaction.timestamp,
      userId: transaction.userId
    };
  }

  validateInsert(itemId) {
    if (this.items[itemId]) {
      throw new errors.ItemAlreadyExists();
    }
  }

  validateUpdate(itemId, __v, updatedBy, ownerId, writeAccess, command) {
    this.validateUpdateOrDelete(itemId, __v, updatedBy, ownerId, command); // writeAccess can only be set or removed by either the item creator or database owner

    const {
      createdBy
    } = this.itemsPlaintextMetadata[itemId];

    if (writeAccess || writeAccess === false) {
      if (!createdBy) return; // if no attribution on item set, can't set write access

      const createdByUserId = createdBy.userId;
      const updatedByUserId = updatedBy.userId;

      if (createdByUserId !== updatedByUserId && updatedByUserId !== ownerId) {
        throw new errors.WriteAccessParamNotAllowed();
      }
    }
  }

  validateUpdateOrDelete(itemId, __v, attribution, ownerId, command) {
    const item = this.items[itemId];
    if (!item) throw new errors.ItemDoesNotExist();
    const currentVersion = this.getItemVersionNumber(itemId);

    if (__v <= currentVersion) {
      throw new errors.ItemUpdateConflict();
    }

    this.validateAccessPermissions(itemId, attribution, ownerId, command);
  }

  validateUploadFile(itemId, __v, fileUploadedBy, ownerId, command) {
    const item = this.items[itemId];
    if (!item) throw new errors.ItemDoesNotExist();
    const currentVersion = this.getFileVersionNumber(itemId);

    if (__v <= currentVersion) {
      throw new errors.FileUploadConflict();
    }

    this.validateAccessPermissions(itemId, fileUploadedBy, ownerId, command);
  }

  validateAccessPermissions(itemId, attribution, ownerId, command) {
    const {
      createdBy,
      writeAccess
    } = this.itemsPlaintextMetadata[itemId];

    if (createdBy && attribution && writeAccess) {
      const createdByUserId = createdBy.userId;
      const modifiedByUserId = attribution.userId;
      let userIsAuthorized = false;
      const {
        onlyCreator,
        users
      } = writeAccess;

      if (modifiedByUserId === ownerId || modifiedByUserId === createdByUserId) {
        userIsAuthorized = true;
      } else if (!onlyCreator && users) {
        for (const {
          userId
        } of users) {
          userIsAuthorized = modifiedByUserId === userId;
          if (userIsAuthorized) break;
        }
      }

      if (!userIsAuthorized) throw new errors.TransactionUnauthorized(command);
    }
  }

  itemExists(itemId) {
    return objectHasOwnProperty(this.items, itemId);
  }

  applyInsert(itemId, seqNo, record, createdBy, writeAccess, operationIndex) {
    const item = {
      seqNo
    };
    if (typeof operationIndex === 'number') item.operationIndex = operationIndex;
    this.items[itemId] = db_objectSpread(db_objectSpread({}, item), {}, {
      record,
      __v: 0
    });
    this.itemsPlaintextMetadata[itemId] = {
      createdBy,
      writeAccess
    };
    this.itemsIndex.insert(db_objectSpread(db_objectSpread({}, item), {}, {
      itemId
    }));

    if (writeAccess && writeAccess.users) {
      for (const {
        userId,
        username
      } of writeAccess.users) {
        this.usernamesByUserId.set(userId, username);
      }
    }

    return success;
  }

  applyUpdate(itemId, record, __v, updatedBy, writeAccess) {
    this.items[itemId].record = record;
    this.items[itemId].__v = __v;
    this.itemsPlaintextMetadata[itemId].updatedBy = updatedBy;

    if (writeAccess === false) {
      delete this.itemsPlaintextMetadata[itemId].writeAccess;
    } else if (writeAccess) {
      this.itemsPlaintextMetadata[itemId].writeAccess = writeAccess;

      if (writeAccess.users) {
        for (const {
          userId,
          username
        } of writeAccess.users) {
          this.usernamesByUserId.set(userId, username);
        }
      }
    }

    return success;
  }

  applyUploadFile(itemId, fileUploadedBy, __v, fileEncryptionKey, fileEncryptionKeyString, fileName, fileId, fileSize, fileType) {
    const existingFile = this.items[itemId].file;
    if (existingFile) delete this.fileIds[existingFile.fileId];
    this.items[itemId].file = {
      fileName,
      fileId,
      fileSize,
      fileType,
      fileEncryptionKey,
      fileEncryptionKeyString,
      __v
    };
    this.itemsPlaintextMetadata[itemId].fileUploadedBy = fileUploadedBy;
    this.fileIds[fileId] = itemId;
    return success;
  }

  applyDelete(itemId) {
    this.itemsIndex.remove(this.items[itemId]);
    delete this.items[itemId];
    delete this.itemsPlaintextMetadata[itemId];
    return success;
  }

  validateBatchTransaction(batch, records, attribution, ownerId) {
    const uniqueItemIds = {};

    for (let i = 0; i < batch.length; i++) {
      const operation = batch[i];
      const {
        command,
        writeAccess
      } = operation;
      const itemId = records[i].id;
      const __v = records[i].__v;
      if (uniqueItemIds[itemId]) throw new errors.OperationsConflict();
      uniqueItemIds[itemId] = true;

      switch (command) {
        case 'Insert':
          this.validateInsert(itemId);
          break;

        case 'Update':
          this.validateUpdate(itemId, __v, attribution, ownerId, writeAccess, command);
          break;

        case 'Delete':
          this.validateUpdateOrDelete(itemId, __v, attribution, ownerId, command);
          break;
      }
    }
  }

  applyBatchTransaction(seqNo, batch, records, attribution) {
    for (let i = 0; i < batch.length; i++) {
      const operation = batch[i];
      const itemId = records[i].id;
      const item = records[i].item;
      const __v = records[i].__v;
      const writeAccess = operation.writeAccess;

      switch (operation.command) {
        case 'Insert':
          this.applyInsert(itemId, seqNo, item, attribution, writeAccess, i);
          break;

        case 'Update':
          this.applyUpdate(itemId, item, __v, attribution, writeAccess);
          break;

        case 'Delete':
          this.applyDelete(itemId, __v);
          break;
      }
    }

    return success;
  }

  registerUnverifiedTransaction() {
    const unverifiedTransaction = new UnverifiedTransaction(this.lastSeqNo);
    const i = this.unverifiedTransactions.push(unverifiedTransaction);
    unverifiedTransaction.setIndex(i - 1);
    return unverifiedTransaction;
  }

  unregisterUnverifiedTransaction(pendingTransaction) {
    delete this.unverifiedTransactions[pendingTransaction.getIndex()];
  }

  getItems() {
    const result = [];

    for (let i = 0; i < this.itemsIndex.array.length; i++) {
      const itemId = this.itemsIndex.array[i].itemId;
      const record = this.items[itemId].record;
      const item = {
        itemId,
        item: record
      }; // set file metadata

      if (this.items[itemId].file) {
        const {
          fileId,
          fileName,
          fileSize
        } = this.items[itemId].file;
        item.fileId = fileId;
        item.fileName = fileName;
        item.fileSize = fileSize;
      } // set attribution metadata


      for (const prop of ['createdBy', 'updatedBy', 'fileUploadedBy']) {
        if (this.itemsPlaintextMetadata[itemId][prop]) {
          const {
            timestamp,
            userId
          } = this.itemsPlaintextMetadata[itemId][prop];
          const attribution = {
            timestamp
          };
          const username = this.usernamesByUserId.get(userId);

          if (username == null) {
            attribution.userDeleted = true;
          } else {
            attribution.username = username;
          }

          item[prop] = attribution;
        }
      } // set write access permissions


      if (this.itemsPlaintextMetadata[itemId].writeAccess) {
        const {
          onlyCreator,
          users
        } = this.itemsPlaintextMetadata[itemId].writeAccess;
        const writeAccess = {};
        if (onlyCreator) writeAccess.onlyCreator = onlyCreator;

        if (users) {
          writeAccess.users = [];

          for (const {
            userId
          } of users) {
            const username = this.usernamesByUserId.get(userId);
            if (username) writeAccess.users.push({
              username
            });
          }
        }

        item.writeAccess = writeAccess;
      }

      result.push(item);
    }

    return result;
  }

  getItemVersionNumber(itemId) {
    return this.items[itemId].__v;
  }

  getFileVersionNumber(itemId) {
    return this.items[itemId].file && this.items[itemId].file.__v;
  }

  async decryptShareTokenEncryptedDbKey(shareTokenEncryptedDbKey, shareTokenEncryptionKeySalt) {
    const shareTokenEncryptionKey = await Crypto.aesGcm.importKeyFromMaster(this.shareTokenHkdfKey, external_base64_arraybuffer_default.a.decode(shareTokenEncryptionKeySalt));
    const dbKeyString = await Crypto.aesGcm.decryptString(shareTokenEncryptionKey, shareTokenEncryptedDbKey);
    return dbKeyString;
  }

}

const _setChangeHandler = changeHandler => {
  return items => {
    try {
      changeHandler(items);
    } catch (e) {
      console.error('There was an error in your changeHandler.\n\n', e);
    }
  };
};

const _idempotentOpenDatabase = (database, changeHandler, receivedMessage) => {
  // safe to replace -- enables idempotent calls to openDatabase
  database.onChange = _setChangeHandler(changeHandler); // if 1 call succeeds, all idempotent calls succeed

  const currentReceivedMessage = database.receivedMessage;

  database.receivedMessage = () => {
    currentReceivedMessage();
    receivedMessage();
  }; // database is already open, can return successfully


  if (database.init) {
    database.onChange(database.getItems());
    database.receivedMessage();
    return true;
  }

  return false;
};

const _getShareTokenIdFromShareToken = shareTokenArrayBuffer => {
  const shareTokenIdArrayBuffer = shareTokenArrayBuffer.slice(0, UUID_CHAR_LENGTH);
  const shareTokenId = arrayBufferToString(shareTokenIdArrayBuffer, true);
  if (!shareTokenId || shareTokenId.length !== UUID_CHAR_LENGTH) throw new errors.ShareTokenInvalid();
  return shareTokenId;
};

const _getShareTokenIdAndShareTokenSeed = shareTokenResult => {
  const shareTokenArrayBuffer = external_base64_arraybuffer_default.a.decode(shareTokenResult);

  const shareTokenId = _getShareTokenIdFromShareToken(shareTokenArrayBuffer);

  const shareTokenSeed = shareTokenArrayBuffer.slice(UUID_CHAR_LENGTH);
  return {
    shareTokenId,
    shareTokenSeed
  };
};

const _openDatabaseByShareToken = async (shareToken, changeHandler, receivedMessage) => {
  let shareTokenIdAndShareTokenSeed, shareTokenHkdfKey;

  try {
    shareTokenIdAndShareTokenSeed = _getShareTokenIdAndShareTokenSeed(shareToken);
    shareTokenHkdfKey = await Crypto.hkdf.importHkdfKey(shareTokenIdAndShareTokenSeed.shareTokenSeed);
  } catch (_unused) {
    throw new errors.ShareTokenInvalid();
  }

  const {
    shareTokenId
  } = shareTokenIdAndShareTokenSeed;
  const {
    databaseId,
    validationMessage,
    signedValidationMessage
  } = await src_ws.authenticateShareToken(shareTokenId, shareTokenHkdfKey);
  src_ws.state.shareTokenIdToDbId[shareTokenId] = databaseId;
  await _openDatabaseByDatabaseId(databaseId, changeHandler, receivedMessage, shareTokenId, shareTokenHkdfKey, validationMessage, signedValidationMessage);
};

const _openDatabaseByDatabaseId = async (databaseId, changeHandler, receivedMessage, shareTokenId, shareTokenHkdfKey, validationMessage, signedValidationMessage) => {
  const database = src_ws.state.databasesByDbId[databaseId];

  if (!database) {
    src_ws.state.databasesByDbId[databaseId] = new db_Database(changeHandler, receivedMessage, shareTokenId, shareTokenHkdfKey);
  } else {
    if (_idempotentOpenDatabase(database, changeHandler, receivedMessage)) return;
  }

  const action = 'OpenDatabaseByDatabaseId';
  const params = {
    databaseId,
    validationMessage,
    signedValidationMessage
  };
  await src_ws.request(action, params);
};

const _openDatabaseByNameHash = async (dbNameHash, newDatabaseParams, changeHandler, receivedMessage) => {
  const database = src_ws.state.databases[dbNameHash];

  if (!database) {
    src_ws.state.databases[dbNameHash] = new db_Database(changeHandler, receivedMessage);
  } else {
    if (_idempotentOpenDatabase(database, changeHandler, receivedMessage)) return;
  }

  const action = 'OpenDatabase';
  const params = {
    dbNameHash,
    newDatabaseParams
  };
  await src_ws.request(action, params);
};

const _openDatabase = async (changeHandler, params) => {
  try {
    let receivedMessage;
    let timeout;
    const firstMessageFromWebSocket = new Promise((resolve, reject) => {
      receivedMessage = resolve;
      timeout = setTimeout(() => reject(new Error('timeout')), TX_TIMEOUT);
    });
    const {
      dbNameHash,
      newDatabaseParams,
      databaseId,
      shareToken
    } = params;

    try {
      if (dbNameHash) await _openDatabaseByNameHash(dbNameHash, newDatabaseParams, changeHandler, receivedMessage);else if (databaseId) await _openDatabaseByDatabaseId(databaseId, changeHandler, receivedMessage);else if (shareToken) await _openDatabaseByShareToken(shareToken, changeHandler, receivedMessage);
      await firstMessageFromWebSocket;
    } catch (e) {
      clearTimeout(timeout);

      if (e.response && e.response.data) {
        const data = e.response.data;

        if (data === 'Database already creating') {
          throw new errors.DatabaseAlreadyOpening();
        } else if (data === 'Database is owned by user') {
          if (databaseId) throw new errors.DatabaseIdNotAllowedForOwnDatabase();else if (shareToken) throw new errors.ShareTokenNotAllowedForOwnDatabase();
        } else if (data === 'Database key not found' || data === 'Database not found') {
          throw new errors.DatabaseNotFound();
        }

        switch (data.name) {
          case 'SubscriptionNotFound':
            throw new errors.SubscriptionNotFound();

          case 'SubscriptionInactive':
            throw new errors.SubscriptionInactive(data.subscriptionStatus);

          case 'TrialExpired':
            throw new errors.TrialExpired();
        }
      }

      throw e;
    }
  } catch (e) {
    db_parseGenericErrors(e);

    throw e;
  }
};

const _createDatabase = async (dbName, encryptionMode) => {
  const dbId = v4_default()();
  const dbKey = await Crypto.aesGcm.generateKey();
  const dbKeyString = await Crypto.aesGcm.getKeyStringFromKey(dbKey);
  const [encryptedDbKey, encryptedDbName] = await Promise.all([Crypto.aesGcm.encryptString(src_ws.keys.encryptionKey, dbKeyString), Crypto.aesGcm.encryptString(dbKey, dbName)]);
  const newDatabaseParams = {
    dbId,
    encryptedDbKey,
    encryptedDbName,
    attribution: true
  };
  if (encryptionMode === 'server-side') newDatabaseParams.plaintextDbKey = dbKeyString; // tie database to user's fingerprint at time of creation

  newDatabaseParams.fingerprint = await _getMyFingerprint();
  return newDatabaseParams;
};

const _validateEncryptionMode = encryptionMode => {
  if (encryptionMode === 'server-side' && !src_config.isServerSideEncryptionModeAllowed()) {
    throw new errors.ServerSideEncryptionNotEnabledInClient();
  }
};

const _validateDbName = dbName => {
  if (typeof dbName !== 'string') throw new errors.DatabaseNameMustBeString();
  if (dbName.length === 0) throw new errors.DatabaseNameCannotBeBlank();
  if (dbName.length > MAX_DB_NAME_CHAR_LENGTH) throw new errors.DatabaseNameTooLong(MAX_DB_NAME_CHAR_LENGTH);
};

const _validateDbId = dbId => {
  if (typeof dbId !== 'string') throw new errors.DatabaseIdMustBeString();
  if (dbId.length === 0) throw new errors.DatabaseIdCannotBeBlank();
  if (dbId.length !== UUID_CHAR_LENGTH) throw new errors.DatabaseIdInvalidLength(UUID_CHAR_LENGTH);
};

const _validateDbInput = params => {
  if (typeof params !== 'object') throw new errors.ParamsMustBeObject();

  if (objectHasOwnProperty(params, 'databaseName')) {
    _validateDbName(params.databaseName);

    if (objectHasOwnProperty(params, 'databaseId')) throw new errors.DatabaseIdNotAllowed();
    if (objectHasOwnProperty(params, 'shareToken')) throw new errors.ShareTokenNotAllowed(); // try to block usage of verified users database. If user works around this and modifies this database,
    // they could mess up the database for themself.

    if (!params.allowVerifiedUsersDatabase && params.databaseName === VERIFIED_USERS_DATABASE_NAME) {
      throw new errors.DatabaseNameRestricted(VERIFIED_USERS_DATABASE_NAME);
    }
  } else if (objectHasOwnProperty(params, 'databaseId')) {
    _validateDbId(params.databaseId);

    if (objectHasOwnProperty(params, 'shareToken')) throw new errors.ShareTokenNotAllowed();
  } else if (objectHasOwnProperty(params, 'shareToken')) {
    if (typeof params.shareToken !== 'string') throw new errors.ShareTokenInvalid();
  } else {
    throw new errors.DatabaseNameMissing();
  }

  if (objectHasOwnProperty(params, 'encryptionMode') && !ENCRYPTION_MODE_OPTIONS[params.encryptionMode]) {
    throw new errors.EncryptionModeNotValid(ENCRYPTION_MODE_OPTIONS);
  }

  db_checkSignedInState();
};

const openDatabase = async params => {
  try {
    _validateDbInput(params);

    if (!objectHasOwnProperty(params, 'changeHandler')) throw new errors.ChangeHandlerMissing();
    const {
      databaseName,
      databaseId,
      shareToken,
      changeHandler,
      encryptionMode = src_ws.encryptionMode
    } = params;
    if (typeof changeHandler !== 'function') throw new errors.ChangeHandlerMustBeFunction();

    _validateEncryptionMode(encryptionMode);

    if (databaseName) {
      const dbNameHash = encryptionMode === 'server-side' ? databaseName // Hashing is meant to keep it secret, no need to hash if encryption mode is server-side
      : src_ws.state.dbNameToHash[databaseName] || (await Crypto.hmac.signString(src_ws.keys.hmacKey, databaseName));
      if (encryptionMode === 'end-to-end') src_ws.state.dbNameToHash[databaseName] = dbNameHash; // eslint-disable-line require-atomic-updates

      const newDatabaseParams = await _createDatabase(databaseName, encryptionMode);
      const openByDbNameHashParams = {
        dbNameHash,
        newDatabaseParams
      };
      await _openDatabase(changeHandler, openByDbNameHashParams);
    } else if (databaseId) {
      const openByDbIdParams = {
        databaseId
      };
      await _openDatabase(changeHandler, openByDbIdParams);
    } else {
      const openByShareToken = {
        shareToken
      };
      await _openDatabase(changeHandler, openByShareToken);
    }
  } catch (e) {
    switch (e.name) {
      case 'ParamsMustBeObject':
      case 'DatabaseAlreadyOpening':
      case 'DatabaseNameMustBeString':
      case 'DatabaseNameMissing':
      case 'DatabaseNameCannotBeBlank':
      case 'DatabaseNameTooLong':
      case 'DatabaseNameRestricted':
      case 'DatabaseIdMustBeString':
      case 'DatabaseIdCannotBeBlank':
      case 'DatabaseIdInvalidLength':
      case 'DatabaseIdNotAllowed':
      case 'DatabaseIdNotAllowedForOwnDatabase':
      case 'ShareTokenNotAllowed':
      case 'ShareTokenInvalid':
      case 'ShareTokenNotFound':
      case 'ShareTokenNotAllowedForOwnDatabase':
      case 'DatabaseNotFound':
      case 'ChangeHandlerMissing':
      case 'ChangeHandlerMustBeFunction':
      case 'EncryptionModeNotValid':
      case 'ServerSideEncryptionNotEnabledInClient':
      case 'UserMustChangePassword':
      case 'UserNotSignedIn':
      case 'UserNotFound':
      case 'SubscriptionNotFound':
      case 'SubscriptionInactive':
      case 'TrialExpired':
      case 'TooManyRequests':
      case 'ServiceUnavailable':
        throw e;

      default:
        throw new errors.UnknownServiceUnavailable(e);
    }
  }
};

const getOpenDb = (dbName, databaseId, shareToken, encryptionMode = 'end-to-end') => {
  _validateEncryptionMode(encryptionMode);

  const shareTokenId = shareToken && _getShareTokenIdFromShareToken(external_base64_arraybuffer_default.a.decode(shareToken));

  const dbNameHash = encryptionMode === 'server-side' ? dbName : src_ws.state.dbNameToHash[dbName];
  const database = dbName ? src_ws.state.databases[dbNameHash] : src_ws.state.databasesByDbId[databaseId || src_ws.state.shareTokenIdToDbId[shareTokenId]];
  if (!database || !database.init) throw new errors.DatabaseNotOpen();
  return database;
};

const insertItem = async params => {
  try {
    _validateDbInput(params);

    const database = getOpenDb(params.databaseName, params.databaseId, params.shareToken, params.encryptionMode || src_ws.encryptionMode);
    const action = 'Insert';
    const insertParams = await _buildInsertParams(database, params);
    await postTransaction(database, action, insertParams);
  } catch (e) {
    switch (e.name) {
      case 'ParamsMustBeObject':
      case 'DatabaseNotOpen':
      case 'DatabaseNameMissing':
      case 'DatabaseNameMustBeString':
      case 'DatabaseNameCannotBeBlank':
      case 'DatabaseNameTooLong':
      case 'DatabaseNameRestricted':
      case 'DatabaseIdMustBeString':
      case 'DatabaseIdCannotBeBlank':
      case 'DatabaseIdInvalidLength':
      case 'DatabaseIdNotAllowed':
      case 'ShareTokenNotAllowed':
      case 'ShareTokenInvalid':
      case 'DatabaseIsReadOnly':
      case 'EncryptionModeNotValid':
      case 'ServerSideEncryptionNotEnabledInClient':
      case 'ItemIdMustBeString':
      case 'ItemIdCannotBeBlank':
      case 'ItemIdTooLong':
      case 'ItemMissing':
      case 'ItemInvalid':
      case 'ItemTooLarge':
      case 'ItemAlreadyExists':
      case 'UserMustChangePassword':
      case 'UserNotSignedIn':
      case 'UserNotFound':
      case 'TooManyRequests':
      case 'ServiceUnavailable':
        throw e;

      default:
        throw new errors.UnknownServiceUnavailable(e);
    }
  }
};

const _buildInsertParams = async (database, params) => {
  if (!objectHasOwnProperty(params, 'item')) throw new errors.ItemMissing();
  const {
    item,
    itemId,
    writeAccess
  } = params;

  if (objectHasOwnProperty(params, 'itemId')) {
    if (typeof itemId !== 'string') throw new errors.ItemIdMustBeString();
    if (itemId.length === 0) throw new errors.ItemIdCannotBeBlank();
    if (itemId.length > MAX_ITEM_ID_CHAR_LENGTH) throw new errors.ItemIdTooLong(MAX_ITEM_ID_CHAR_LENGTH);
  }

  const itemString = JSON.stringify(item);
  if (!itemString) throw new errors.ItemInvalid();
  if (byteSizeOfString(itemString) > MAX_ITEM_BYTES) throw new errors.ItemTooLarge(MAX_ITEM_KB);
  const id = itemId || v4_default()();
  const itemKey = await Crypto.hmac.signString(src_ws.keys.hmacKey, id);
  const itemRecord = {
    id,
    item
  };
  const encryptedItem = await Crypto.aesGcm.encryptJson(database.dbKey, itemRecord);
  return {
    itemKey,
    encryptedItem,
    writeAccess
  };
};

const updateItem = async params => {
  try {
    _validateDbInput(params);

    const database = getOpenDb(params.databaseName, params.databaseId, params.shareToken, params.encryptionMode || src_ws.encryptionMode);
    const action = 'Update';
    const updateParams = await _buildUpdateParams(database, params);
    await postTransaction(database, action, updateParams);
  } catch (e) {
    switch (e.name) {
      case 'ParamsMustBeObject':
      case 'DatabaseNotOpen':
      case 'DatabaseNameMissing':
      case 'DatabaseNameMustBeString':
      case 'DatabaseNameCannotBeBlank':
      case 'DatabaseNameTooLong':
      case 'DatabaseNameRestricted':
      case 'DatabaseIdMustBeString':
      case 'DatabaseIdCannotBeBlank':
      case 'DatabaseIdInvalidLength':
      case 'DatabaseIdNotAllowed':
      case 'ShareTokenNotAllowed':
      case 'ShareTokenInvalid':
      case 'DatabaseIsReadOnly':
      case 'EncryptionModeNotValid':
      case 'ServerSideEncryptionNotEnabledInClient':
      case 'ItemIdMissing':
      case 'ItemIdMustBeString':
      case 'ItemIdCannotBeBlank':
      case 'ItemIdTooLong':
      case 'ItemMissing':
      case 'ItemInvalid':
      case 'ItemTooLarge':
      case 'ItemDoesNotExist':
      case 'ItemUpdateConflict':
      case 'WriteAccessParamNotAllowed':
      case 'TransactionUnauthorized':
      case 'UserMustChangePassword':
      case 'UserNotSignedIn':
      case 'UserNotFound':
      case 'TooManyRequests':
      case 'ServiceUnavailable':
        throw e;

      default:
        throw new errors.UnknownServiceUnavailable(e);
    }
  }
};

const _buildUpdateParams = async (database, params) => {
  if (!objectHasOwnProperty(params, 'item')) throw new errors.ItemMissing();
  if (!objectHasOwnProperty(params, 'itemId')) throw new errors.ItemIdMissing();
  if (!params.writeAccess && objectHasOwnProperty(params, 'writeAccess')) params.writeAccess = false; // marks writeAccess for deletion

  const {
    item,
    itemId,
    writeAccess
  } = params;
  if (typeof itemId !== 'string') throw new errors.ItemIdMustBeString();
  if (itemId.length === 0) throw new errors.ItemIdCannotBeBlank();
  if (itemId.length > MAX_ITEM_ID_CHAR_LENGTH) throw new errors.ItemIdTooLong(MAX_ITEM_ID_CHAR_LENGTH);
  if (!database.itemExists(itemId)) throw new errors.ItemDoesNotExist();
  const itemString = JSON.stringify(item);
  if (!itemString) throw new errors.ItemInvalid();
  if (byteSizeOfString(itemString) > MAX_ITEM_BYTES) throw new errors.ItemTooLarge(MAX_ITEM_KB);
  const currentVersion = database.getItemVersionNumber(itemId);
  const itemKey = await Crypto.hmac.signString(src_ws.keys.hmacKey, itemId);
  const itemRecord = {
    id: itemId,
    item,
    __v: currentVersion + 1
  };
  const encryptedItem = await Crypto.aesGcm.encryptJson(database.dbKey, itemRecord);
  return {
    itemKey,
    encryptedItem,
    writeAccess
  };
};

const deleteItem = async params => {
  try {
    _validateDbInput(params);

    const database = getOpenDb(params.databaseName, params.databaseId, params.shareToken, params.encryptionMode || src_ws.encryptionMode);
    const action = 'Delete';
    const deleteParams = await _buildDeleteParams(database, params);
    await postTransaction(database, action, deleteParams);
  } catch (e) {
    switch (e.name) {
      case 'ParamsMustBeObject':
      case 'DatabaseNotOpen':
      case 'DatabaseNameMissing':
      case 'DatabaseNameMustBeString':
      case 'DatabaseNameCannotBeBlank':
      case 'DatabaseNameTooLong':
      case 'DatabaseNameRestricted':
      case 'DatabaseIdMustBeString':
      case 'DatabaseIdCannotBeBlank':
      case 'DatabaseIdInvalidLength':
      case 'DatabaseIdNotAllowed':
      case 'ShareTokenNotAllowed':
      case 'ShareTokenInvalid':
      case 'DatabaseIsReadOnly':
      case 'EncryptionModeNotValid':
      case 'ServerSideEncryptionNotEnabledInClient':
      case 'ItemIdMissing':
      case 'ItemIdMustBeString':
      case 'ItemIdCannotBeBlank':
      case 'ItemIdTooLong':
      case 'ItemDoesNotExist':
      case 'ItemUpdateConflict':
      case 'TransactionUnauthorized':
      case 'UserMustChangePassword':
      case 'UserNotSignedIn':
      case 'UserNotFound':
      case 'TooManyRequests':
      case 'ServiceUnavailable':
        throw e;

      default:
        throw new errors.UnknownServiceUnavailable(e);
    }
  }
};

const _buildDeleteParams = async (database, params) => {
  if (!objectHasOwnProperty(params, 'itemId')) throw new errors.ItemIdMissing();
  const {
    itemId
  } = params;
  if (typeof itemId !== 'string') throw new errors.ItemIdMustBeString();
  if (itemId.length === 0) throw new errors.ItemIdCannotBeBlank();
  if (itemId.length > MAX_ITEM_ID_CHAR_LENGTH) throw new errors.ItemIdTooLong(MAX_ITEM_ID_CHAR_LENGTH);
  if (!database.itemExists(itemId)) throw new errors.ItemDoesNotExist();
  const currentVersion = database.getItemVersionNumber(itemId);
  const itemKey = await Crypto.hmac.signString(src_ws.keys.hmacKey, itemId);
  const itemRecord = {
    id: itemId,
    __v: currentVersion + 1
  };
  const encryptedItem = await Crypto.aesGcm.encryptJson(database.dbKey, itemRecord);
  return {
    itemKey,
    encryptedItem
  };
};

const putTransaction = async params => {
  try {
    _validateDbInput(params);

    if (!objectHasOwnProperty(params, 'operations')) throw new errors.OperationsMissing();
    const {
      databaseName,
      databaseId,
      shareToken,
      operations,
      encryptionMode = src_ws.encryptionMode
    } = params;
    if (!Array.isArray(operations)) throw new errors.OperationsMustBeArray();
    const database = getOpenDb(databaseName, databaseId, shareToken, encryptionMode);
    const action = 'BatchTransaction';
    const operationParamsPromises = await Promise.all(operations.map(operation => {
      const command = operation.command;

      switch (command) {
        case 'Insert':
          {
            return _buildInsertParams(database, operation);
          }

        case 'Update':
          {
            return _buildUpdateParams(database, operation);
          }

        case 'Delete':
          {
            return _buildDeleteParams(database, operation);
          }

        default:
          throw new errors.CommandNotRecognized(command);
      }
    }));
    const operationParamsPromiseResults = await Promise.all(operationParamsPromises);
    const operationParams = {
      operations: operations.map((operation, i) => db_objectSpread({
        command: operation.command
      }, operationParamsPromiseResults[i]))
    };

    try {
      await postTransaction(database, action, operationParams);
    } catch (e) {
      if (e.response && e.response.data.error === 'OperationsExceedLimit') {
        throw new errors.OperationsExceedLimit(e.response.data.limit);
      }

      throw e;
    }
  } catch (e) {
    switch (e.name) {
      case 'ParamsMustBeObject':
      case 'DatabaseNotOpen':
      case 'DatabaseNameMissing':
      case 'DatabaseNameMustBeString':
      case 'DatabaseNameCannotBeBlank':
      case 'DatabaseNameTooLong':
      case 'DatabaseNameRestricted':
      case 'DatabaseIdMustBeString':
      case 'DatabaseIdCannotBeBlank':
      case 'DatabaseIdInvalidLength':
      case 'DatabaseIdNotAllowed':
      case 'ShareTokenNotAllowed':
      case 'ShareTokenInvalid':
      case 'DatabaseIsReadOnly':
      case 'EncryptionModeNotValid':
      case 'ServerSideEncryptionNotEnabledInClient':
      case 'OperationsMissing':
      case 'OperationsMustBeArray':
      case 'OperationsConflict':
      case 'OperationsExceedLimit':
      case 'CommandNotRecognized':
      case 'ItemIdMissing':
      case 'ItemIdMustBeString':
      case 'ItemIdCannotBeBlank':
      case 'ItemIdTooLong':
      case 'ItemMissing':
      case 'ItemInvalid':
      case 'ItemTooLarge':
      case 'ItemAlreadyExists':
      case 'ItemDoesNotExist':
      case 'ItemUpdateConflict':
      case 'WriteAccessParamNotAllowed':
      case 'TransactionUnauthorized':
      case 'UserMustChangePassword':
      case 'UserNotSignedIn':
      case 'UserNotFound':
      case 'TooManyRequests':
      case 'ServiceUnavailable':
        throw e;

      default:
        throw new errors.UnknownServiceUnavailable(e);
    }
  }
};

const postTransaction = async (database, action, params) => {
  try {
    const pendingTx = database.registerUnverifiedTransaction();

    const paramsWithDbData = db_objectSpread(db_objectSpread({}, params), {}, {
      dbId: database.dbId,
      dbNameHash: database.dbNameHash
    });

    const response = await src_ws.request(action, paramsWithDbData);
    const seqNo = response.data.sequenceNo;
    await pendingTx.getResult(seqNo);
    database.unregisterUnverifiedTransaction(pendingTx);
    return seqNo;
  } catch (e) {
    db_parseGenericErrors(e);

    if (e.response) {
      if (e.response.data.name === 'DatabaseIsReadOnly') {
        throw new errors.DatabaseIsReadOnly();
      } else if (e.response.data.message === 'UserNotFound') {
        throw new errors.UserNotFound(e.response.data.username);
      }
    }

    throw e;
  }
};

const _completeFileUpload = async (database, fileId, itemKey, encryptedFileMetadata, encryptedFileEncryptionKey) => {
  const params = {
    dbId: database.dbId,
    fileId,
    itemKey,
    fileMetadata: encryptedFileMetadata,
    fileEncryptionKey: external_base64_arraybuffer_default.a.encode(encryptedFileEncryptionKey)
  };
  const action = 'CompleteFileUpload';
  await postTransaction(database, action, params);
};

const _readBlob = async blob => {
  const reader = new FileReader();
  return new Promise((resolve, reject) => {
    reader.onload = e => {
      if (!e.target.error) {
        resolve(e.target.result);
      } else {
        reject(e.target.error);
      }
    };

    reader.readAsArrayBuffer(blob);
  });
};

const _uploadChunkRequest = async (request, bytesTransferredObject, progressHandler, chunkSize) => {
  await request;
  bytesTransferredObject.bytesTransferred += chunkSize;
  if (progressHandler) progressHandler(db_objectSpread({}, bytesTransferredObject));
};

const _uploadChunk = async (batch, chunk, dbId, fileId, fileEncryptionKey, chunkNumber, bytesTransferredObject, progressHandler) => {
  const plaintextChunk = await _readBlob(chunk); // encrypt each chunk with new encryption key to maintain lower usage of file encryption key

  const [chunkEncryptionKey, encryptedChunkEncryptionKey] = await Crypto.aesGcm.generateAndEncryptKeyEncryptionKey(fileEncryptionKey);
  const encryptedChunk = await Crypto.aesGcm.encrypt(chunkEncryptionKey, plaintextChunk);
  const uploadChunkParams = {
    dbId,
    chunkNumber,
    fileId,
    // arrayBufferToString takes up less space than base64 encoding. Uint8Array format required so that encrypted
    // chunks that are odd number sized get converted to string properly
    chunk: arrayBufferToString(new Uint8Array(encryptedChunk)),
    chunkEncryptionKey: arrayBufferToString(new Uint8Array(encryptedChunkEncryptionKey))
  }; // queue UploadFileChunk request into batch of requests

  const action = 'UploadFileChunk';

  const uploadChunkRequest = _uploadChunkRequest(src_ws.request(action, uploadChunkParams), bytesTransferredObject, progressHandler, chunk.size);

  batch.push(uploadChunkRequest); // wait for batch of UploadFileChunk requests to finish before moving on to upload the next batch of chunks

  if (batch.length === FILE_CHUNKS_PER_BATCH) {
    await Promise.all(batch);
    batch.length = 0;
  }
};

const _buildFileMetadata = async (params, database) => {
  if (!objectHasOwnProperty(params, 'itemId')) throw new errors.ItemIdMissing();
  if (!objectHasOwnProperty(params, 'file')) throw new errors.FileMissing();
  const {
    itemId,
    file
  } = params;
  if (typeof itemId !== 'string') throw new errors.ItemIdMustBeString();
  if (itemId.length === 0) throw new errors.ItemIdCannotBeBlank();
  if (itemId.length > MAX_ITEM_ID_CHAR_LENGTH) throw new errors.ItemIdTooLong(MAX_ITEM_ID_CHAR_LENGTH);
  if (!database.itemExists(itemId)) throw new errors.ItemDoesNotExist();
  if (!(file instanceof File)) throw new errors.FileMustBeFile();
  if (file.size === 0) throw new errors.FileCannotBeEmpty();
  const itemKey = await Crypto.hmac.signString(src_ws.keys.hmacKey, itemId);
  const currentVersion = database.getFileVersionNumber(itemId);
  const fileMetadata = {
    itemId,
    __v: currentVersion === undefined ? 0 : currentVersion + 1,
    fileName: file.name,
    fileSize: file.size,
    fileType: file.type
  };
  return {
    itemKey,
    fileMetadata
  };
};

const _validateUploadFile = params => {
  _validateDbInput(params);

  if (objectHasOwnProperty(params, 'progressHandler') && typeof params.progressHandler !== 'function') {
    throw new errors.ProgressHandlerMustBeFunction();
  }
};

const uploadFile = async params => {
  try {
    _validateUploadFile(params);

    const database = getOpenDb(params.databaseName, params.databaseId, params.shareToken, params.encryptionMode || src_ws.encryptionMode);
    const {
      dbId
    } = database;

    try {
      const {
        itemKey,
        fileMetadata
      } = await _buildFileMetadata(params, database); // generate a new key particular to this file to maintain lower usage of dbKey

      const [fileEncryptionKey, encryptedFileEncryptionKey] = await Crypto.aesGcm.generateAndEncryptKeyEncryptionKey(database.dbKey);
      const encryptedFileMetadata = await Crypto.aesGcm.encryptJson(fileEncryptionKey, fileMetadata); // server generates unique file identifier

      const {
        data: {
          fileId
        }
      } = await src_ws.request('GenerateFileId', {
        dbId: database.dbId
      }); // upload file in chunks of size FILE_CHUNK_SIZE

      const file = params.file;
      let position = 0;
      let chunkNumber = 0;
      let batch = []; // will use this to send chunks to server in batches of FILE_CHUNKS_PER_BATCH

      const bytesTransferredObject = {
        bytesTransferred: 0
      };

      while (position < file.size) {
        // read a chunk at a time to keep memory overhead low
        const chunk = file.slice(position, position + FILE_CHUNK_SIZE);
        await _uploadChunk(batch, chunk, dbId, fileId, fileEncryptionKey, chunkNumber, bytesTransferredObject, params.progressHandler);
        chunkNumber += 1;
        position += FILE_CHUNK_SIZE;
      }

      await Promise.all(batch);
      await _completeFileUpload(database, fileId, itemKey, encryptedFileMetadata, encryptedFileEncryptionKey);
    } catch (e) {
      db_parseGenericErrors(e);

      if (e.response && e.response.data === 'DatabaseIsReadOnly') {
        throw new errors.DatabaseIsReadOnly();
      }

      throw e;
    }
  } catch (e) {
    switch (e.name) {
      case 'ParamsMustBeObject':
      case 'DatabaseNotOpen':
      case 'DatabaseNameMissing':
      case 'DatabaseNameMustBeString':
      case 'DatabaseNameCannotBeBlank':
      case 'DatabaseNameTooLong':
      case 'DatabaseNameRestricted':
      case 'DatabaseIdMustBeString':
      case 'DatabaseIdCannotBeBlank':
      case 'DatabaseIdInvalidLength':
      case 'DatabaseIdNotAllowed':
      case 'ShareTokenNotAllowed':
      case 'ShareTokenInvalid':
      case 'DatabaseIsReadOnly':
      case 'EncryptionModeNotValid':
      case 'ServerSideEncryptionNotEnabledInClient':
      case 'ItemIdMissing':
      case 'ItemIdMustBeString':
      case 'ItemIdCannotBeBlank':
      case 'ItemIdTooLong':
      case 'ItemDoesNotExist':
      case 'TransactionUnauthorized':
      case 'FileMustBeFile':
      case 'FileCannotBeEmpty':
      case 'FileMissing':
      case 'FileUploadConflict':
      case 'ProgressHandlerMustBeFunction':
      case 'UserMustChangePassword':
      case 'UserNotSignedIn':
      case 'TooManyRequests':
      case 'ServiceUnavailable':
        throw e;

      default:
        throw new errors.UnknownServiceUnavailable(e);
    }
  }
};

const _getChunk = async (dbId, fileId, chunkNumber, fileEncryptionKey) => {
  try {
    const action = 'GetChunk';
    const params = {
      dbId,
      fileId,
      chunkNumber
    };
    const response = await src_ws.request(action, params);
    const data = response.data;
    const chunkRawBuffer = new Uint8Array(new Uint16Array(stringToArrayBuffer(data.chunk))).buffer;
    const chunkEncryptionKeyRawBuffer = new Uint8Array(new Uint16Array(stringToArrayBuffer(data.chunkEncryptionKey))).buffer;
    const chunkEncryptionKeyRaw = await Crypto.aesGcm.decrypt(fileEncryptionKey, chunkEncryptionKeyRawBuffer);
    const chunkEncryptionKey = await Crypto.aesGcm.getKeyFromRawKey(chunkEncryptionKeyRaw);
    const chunk = await Crypto.aesGcm.decrypt(chunkEncryptionKey, chunkRawBuffer);
    return chunk;
  } catch (e) {
    db_parseGenericErrors(e);

    throw e;
  }
};

const _getByteRange = async (dbId, fileId, fileEncryptionKey, range) => {
  const {
    start,
    end
  } = range;
  const chunks = [];
  const startChunkNumber = Math.floor(start / FILE_CHUNK_SIZE);
  const endChunkNumber = Math.floor(end / FILE_CHUNK_SIZE) - (end % FILE_CHUNK_SIZE === 0 ? 1 : 0);
  let chunkNumber = startChunkNumber;

  while (chunkNumber <= endChunkNumber) {
    let chunk = await _getChunk(dbId, fileId, chunkNumber, fileEncryptionKey);

    if (chunkNumber === startChunkNumber && chunkNumber === endChunkNumber && end % FILE_CHUNK_SIZE) {
      chunk = chunk.slice(start % FILE_CHUNK_SIZE, end % FILE_CHUNK_SIZE);
    } else if (chunkNumber === startChunkNumber) {
      chunk = chunk.slice(start % FILE_CHUNK_SIZE);
    } else if (chunkNumber === endChunkNumber && end % FILE_CHUNK_SIZE) {
      chunk = chunk.slice(0, end % FILE_CHUNK_SIZE);
    }

    chunks.push(chunk);
    chunkNumber += 1;
  }

  return chunks;
};

const _getFile = async (dbId, fileId, fileEncryptionKey, fileSize) => {
  const chunks = [];
  let chunkNumber = 0;
  const finalChunkNumber = fileSize < FILE_CHUNK_SIZE ? 0 : Math.floor(fileSize / FILE_CHUNK_SIZE) - (fileSize % FILE_CHUNK_SIZE === 0 ? 1 : 0);

  while (chunkNumber <= finalChunkNumber) {
    const chunk = await _getChunk(dbId, fileId, chunkNumber, fileEncryptionKey);
    chunks.push(chunk);
    chunkNumber += 1;
  }

  return chunks;
};

const _validateGetFileParams = params => {
  _validateDbInput(params);

  if (!objectHasOwnProperty(params, 'fileId')) throw new errors.FileIdMissing();
  const {
    fileId,
    range
  } = params;
  if (typeof fileId !== 'string') throw new errors.FileIdMustBeString();
  if (fileId.length === 0) throw new errors.FileIdCannotBeBlank();
  if (fileId.length > MAX_ITEM_ID_CHAR_LENGTH) throw new errors.FileIdTooLong(MAX_ITEM_ID_CHAR_LENGTH);

  if (objectHasOwnProperty(params, 'range')) {
    if (typeof range !== 'object') throw new errors.RangeMustBeObject();
    if (!objectHasOwnProperty(range, 'start')) throw new errors.RangeMissingStart();
    if (!objectHasOwnProperty(range, 'end')) throw new errors.RangeMissingEnd();
    const {
      start,
      end
    } = range;
    if (typeof start !== 'number') throw new errors.RangeStartMustBeNumber();
    if (typeof end !== 'number') throw new errors.RangeEndMustBeNumber();
    if (start < 0) throw new errors.RangeStartMustBeGreaterThanZero();
    if (end <= start) throw new errors.RangeEndMustBeGreaterThanRangeStart();
  }
};

const getFile = async params => {
  try {
    _validateGetFileParams(params);

    const database = getOpenDb(params.databaseName, params.databaseId, params.shareToken, params.encryptionMode || src_ws.encryptionMode);
    const {
      dbId
    } = database;
    const {
      fileId,
      range
    } = params;
    const itemId = database.fileIds[fileId];
    const item = database.items[itemId];
    if (!item || !item.file) throw new errors.FileNotFound();
    const {
      file: {
        fileName,
        fileSize,
        fileType,
        fileEncryptionKey
      }
    } = item;
    if (range && range.end > fileSize) throw new errors.RangeEndMustBeLessThanFileSize();
    const chunks = range ? await _getByteRange(dbId, fileId, fileEncryptionKey, range) : await _getFile(dbId, fileId, fileEncryptionKey, fileSize);
    return {
      file: new File(chunks, fileName, {
        type: fileType
      })
    };
  } catch (e) {
    switch (e.name) {
      case 'ParamsMustBeObject':
      case 'DatabaseNotOpen':
      case 'DatabaseNameMissing':
      case 'DatabaseNameMustBeString':
      case 'DatabaseNameCannotBeBlank':
      case 'DatabaseNameTooLong':
      case 'DatabaseNameRestricted':
      case 'DatabaseIdMustBeString':
      case 'DatabaseIdCannotBeBlank':
      case 'DatabaseIdInvalidLength':
      case 'DatabaseIdNotAllowed':
      case 'ShareTokenNotAllowed':
      case 'ShareTokenInvalid':
      case 'DatabaseIsReadOnly':
      case 'EncryptionModeNotValid':
      case 'ServerSideEncryptionNotEnabledInClient':
      case 'FileIdMissing':
      case 'FileIdMustBeString':
      case 'FileIdCannotBeBlank':
      case 'FileIdTooLong':
      case 'FileNotFound':
      case 'RangeMustBeObject':
      case 'RangeMissingStart':
      case 'RangeMissingEnd':
      case 'RangeStartMustBeNumber':
      case 'RangeEndMustBeNumber':
      case 'RangeStartMustBeGreaterThanZero':
      case 'RangeEndMustBeGreaterThanRangeStart':
      case 'RangeEndMustBeLessThanFileSize':
      case 'UserMustChangePassword':
      case 'UserNotSignedIn':
      case 'UserNotFound':
      case 'TooManyRequests':
      case 'ServiceUnavailable':
        throw e;

      default:
        throw new errors.UnknownServiceUnavailable(e);
    }
  }
};

const _verifyUsersParent = async (dbKey, verifiedUsers, databaseUser) => {
  const {
    username,
    senderUsername,
    verificationValues
  } = databaseUser;
  const {
    sentSignature,
    receivedSignature,
    senderEcdsaPublicKey
  } = verificationValues;
  const verifiedFingerprint = verifiedUsers[username] && verifiedUsers[username].record.fingerprint;
  const parentRawEcdsaPublicKey = external_base64_arraybuffer_default.a.decode(senderEcdsaPublicKey);
  const parentFingerprint = verifiedUsers[senderUsername] && verifiedUsers[senderUsername].record.fingerprint || (await _getFingerprint(parentRawEcdsaPublicKey));
  const parentEcdsaPublicKey = await Crypto.ecdsa.getPublicKeyFromRawPublicKey(parentRawEcdsaPublicKey); // verify parent's claim that sent the dbKey to user

  const expectedSentSignature = await _signFingerprintWithDbKey(dbKey, verifiedFingerprint);
  const verifiedParentSent = await Crypto.ecdsa.verifyString(parentEcdsaPublicKey, sentSignature, expectedSentSignature); // verify user's claim that received the dbKey from parent

  const recipientEcdsaPublicKey = await Crypto.ecdsa.getPublicKeyFromRawPublicKey(external_base64_arraybuffer_default.a.decode(verificationValues.recipientEcdsaPublicKey));
  const expectedReceivedSignature = await _signFingerprintWithDbKey(dbKey, parentFingerprint);
  const verifiedReceivedFromParent = await Crypto.ecdsa.verifyString(recipientEcdsaPublicKey, receivedSignature, expectedReceivedSignature);
  return verifiedParentSent && verifiedReceivedFromParent;
};

const _verifyReceivedDatabaseFromUser = async (dbKey, verifiedFingerprint, myFingerprint, myEcdsaPublicKey, verificationValues) => {
  const {
    mySentSignature,
    myReceivedSignature
  } = verificationValues; // verify my claim that I received dbKey from this user

  const expectedReceivedSignature = await _signFingerprintWithDbKey(dbKey, verifiedFingerprint);
  const verifiedReceived = await Crypto.ecdsa.verifyString(myEcdsaPublicKey, myReceivedSignature, expectedReceivedSignature);
  if (!verifiedReceived) return verifiedReceived; // verify user's claim that sent dbKey to me

  const expectedSentSignature = await _signFingerprintWithDbKey(dbKey, myFingerprint);
  const senderEcdsaPublicKey = await Crypto.ecdsa.getPublicKeyFromRawPublicKey(external_base64_arraybuffer_default.a.decode(verificationValues.mySenderEcdsaPublicKey));
  const verifiedSent = await Crypto.ecdsa.verifyString(senderEcdsaPublicKey, mySentSignature, expectedSentSignature);
  return verifiedSent && verifiedReceived;
};

const _verifySentDatabaseToUser = async (dbKey, verifiedFingerprint, myFingerprint, myEcdsaPublicKey, verificationValues) => {
  const {
    sentSignature,
    receivedSignature
  } = verificationValues; // verify my claim that I sent dbKey to this user

  const expectedSentSignature = await _signFingerprintWithDbKey(dbKey, verifiedFingerprint);
  const verifiedSent = await Crypto.ecdsa.verifyString(myEcdsaPublicKey, sentSignature, expectedSentSignature);
  if (!verifiedSent) return verifiedSent; // verify user's claim that received dbKey from me

  const expectedReceivedSignature = await _signFingerprintWithDbKey(dbKey, myFingerprint);
  const recipientEcdsaPublicKey = await Crypto.ecdsa.getPublicKeyFromRawPublicKey(external_base64_arraybuffer_default.a.decode(verificationValues.recipientEcdsaPublicKey));
  const verifiedReceived = await Crypto.ecdsa.verifyString(recipientEcdsaPublicKey, receivedSignature, expectedReceivedSignature);
  return verifiedSent && verifiedReceived;
};

const _buildDatabaseUserResult = async (dbKey, databaseUsers, verifiedUsers, myUsername, mySenderUsername) => {
  const myEcdsaPublicKey = await Crypto.ecdsa.getPublicKeyFromPrivateKey(src_ws.keys.ecdsaPrivateKey);
  const myFingerprint = await _getMyFingerprint(); // iterate over all database users to verify each user individually

  for (let i = 0; i < databaseUsers.length; i++) {
    const databaseUser = databaseUsers[i];
    const {
      username,
      isOwner,
      senderUsername,
      verificationValues
    } = databaseUser;

    try {
      const verifiedFingerprint = verifiedUsers[username] && verifiedUsers[username].record.fingerprint;
      const sentDatabaseToUser = verificationValues.isChild;
      const receivedDatabaseFromUser = mySenderUsername === username;

      if (verifiedFingerprint) {
        if (sentDatabaseToUser) {
          databaseUsers[i].verified = await _verifySentDatabaseToUser(dbKey, verifiedFingerprint, myFingerprint, myEcdsaPublicKey, verificationValues);
        } else if (receivedDatabaseFromUser) {
          const verifiedReceivedDatabaseFromUser = await _verifyReceivedDatabaseFromUser(dbKey, verifiedFingerprint, myFingerprint, myEcdsaPublicKey, verificationValues); // verify user's relationship to parent if has a parent

          if (verifiedReceivedDatabaseFromUser && senderUsername) {
            const verifiedGrandparent = await _verifyUsersParent(dbKey, verifiedUsers, databaseUser);
            databaseUsers[i].verified = verifiedGrandparent;
          } else {
            databaseUsers[i].verified = verifiedReceivedDatabaseFromUser;
          }
        } else if (!isOwner) {
          // verify unrelated user's parent sent dbKey to user and user received dbKey from their parent
          const verifiedUsersParent = await _verifyUsersParent(dbKey, verifiedUsers, databaseUser);
          databaseUsers[i].verified = verifiedUsersParent;
        } else {
          // must be an owner that is not my child or parent, and owner is automatically verified
          databaseUsers[i].verified = isOwner;
        }
      }
    } catch (_unused2) {// continue without setting verified boolean
    } // "receivedFromUsername" is easier to understand to end developer


    delete databaseUsers[i].senderUsername;

    if (!isOwner) {
      if (verificationValues && verificationValues.isChild) databaseUsers[i].receivedFromUsername = myUsername;else if (senderUsername) databaseUsers[i].receivedFromUsername = senderUsername;
    } // these values are not useful to user


    delete databaseUsers[i].verificationValues;
  }

  return databaseUsers;
};

const _databaseHasOwner = databaseUsers => {
  for (let i = 0; i < databaseUsers.length; i++) {
    const user = databaseUsers[i];
    if (user.isOwner) return true;
  }

  return false;
};

const _getDatabaseUsers = async (databaseId, databaseNameHash, dbKey, verifiedUsers, username, senderUsername) => {
  const users = [];
  const action = 'GetDatabaseUsers';
  const params = {
    databaseId,
    databaseNameHash
  };
  let databaseUsersResponse = await src_ws.request(action, params);
  users.push(...(await _buildDatabaseUserResult(dbKey, databaseUsersResponse.data.users, verifiedUsers, username, senderUsername)));

  while (databaseUsersResponse.data.nextPageTokenLessThanUserId || databaseUsersResponse.data.nextPageTokenMoreThanUserId) {
    params.nextPageTokenLessThanUserId = databaseUsersResponse.data.nextPageTokenLessThanUserId;
    params.nextPageTokenMoreThanUserId = databaseUsersResponse.data.nextPageTokenMoreThanUserId;
    databaseUsersResponse = await src_ws.request(action, params);
    users.push(...(await _buildDatabaseUserResult(dbKey, databaseUsersResponse.data.users, verifiedUsers, username, senderUsername)));
  }

  return users;
};

const _buildDatabaseResult = async (db, encryptionKey, ecdhPrivateKey, verifiedUsers, username) => {
  const {
    databaseId,
    databaseNameHash,
    isOwner,
    readOnly,
    resharingAllowed,
    senderUsername
  } = db;
  let dbKey, databaseName;

  if (db.encryptedDbKey || db.plaintextDbKey) {
    // user must already have access to database
    const dbKeyString = db.plaintextDbKey || (await Crypto.aesGcm.decryptString(encryptionKey, db.encryptedDbKey));
    dbKey = await Crypto.aesGcm.getKeyFromKeyString(dbKeyString);
    databaseName = await Crypto.aesGcm.decryptString(dbKey, db.databaseName); // don't expose the user's own verified users database to user -- it's used internally

    if (isOwner && databaseName === VERIFIED_USERS_DATABASE_NAME) return null;
  } else if (db.wrappedDbKey) {
    // user using userbase-js v2.0.0 shared with user using userbase-js >= v2.0.1. Updated client
    // cannot receive access to databases shared via userbase-js v2.0.0
    return null;
  } else {
    // user is seeing the database for the first time
    let senderRawEcdsaPublicKey;

    try {
      const {
        ephemeralPublicKey,
        signedEphemeralPublicKey,
        sharedEncryptedDbKey
      } = db; // verify sender signed the ephemeral public key

      senderRawEcdsaPublicKey = external_base64_arraybuffer_default.a.decode(db.senderEcdsaPublicKey);
      const senderEcdsaPublicKey = await Crypto.ecdsa.getPublicKeyFromRawPublicKey(senderRawEcdsaPublicKey);
      const senderSignedEphemeralPublicKey = await Crypto.ecdsa.verify(senderEcdsaPublicKey, external_base64_arraybuffer_default.a.decode(signedEphemeralPublicKey), external_base64_arraybuffer_default.a.decode(ephemeralPublicKey));
      if (!senderSignedEphemeralPublicKey) throw new errors.ServiceUnavailable(); // compute shared key encryption key with other user and decrypt database encryption key

      const senderEphemeralEcdhPublicKey = await Crypto.ecdh.getPublicKeyFromRawPublicKey(external_base64_arraybuffer_default.a.decode(ephemeralPublicKey));
      const sharedKeyEncryptionKey = await Crypto.ecdh.computeSharedKeyEncryptionKey(senderEphemeralEcdhPublicKey, ecdhPrivateKey);
      const dbKeyString = await Crypto.aesGcm.decryptString(sharedKeyEncryptionKey, sharedEncryptedDbKey);
      dbKey = await Crypto.aesGcm.getKeyFromKeyString(dbKeyString); // make sure dbKey the sender sent works

      databaseName = await Crypto.aesGcm.decryptString(dbKey, db.databaseName);
    } catch (e) {
      // if for whatever reason the above process fails (e.g. malicious sender or version upgrade breaks the above implementation),
      // simply return a null spot for database
      return null;
    } // compute receivedSignature to maintain record of who received dbKey from


    const senderFingerprint = await _getFingerprint(senderRawEcdsaPublicKey);
    const receivedSignature = await _signDbKeyAndFingerprint(dbKey, senderFingerprint); // tell server to store encrypted db key & delete ephemeral key data

    const dbKeyString = await Crypto.aesGcm.getKeyStringFromKey(dbKey);
    const encryptedDbKey = await Crypto.aesGcm.encryptString(encryptionKey, dbKeyString);
    const action = 'SaveDatabase';
    const params = {
      databaseNameHash,
      encryptedDbKey,
      receivedSignature
    };
    src_ws.request(action, params);
  }

  const result = {
    databaseName,
    databaseId,
    isOwner,
    readOnly,
    resharingAllowed,
    encryptionMode: db.plaintextDbKey ? 'server-side' : 'end-to-end'
  };
  const users = await _getDatabaseUsers(databaseId, databaseNameHash, dbKey, verifiedUsers, username, senderUsername); // if database has no owner, owner must have been deleted and database should not be accessible to user

  if (isOwner || _databaseHasOwner(users)) result.users = users;else return null;
  if (!isOwner && senderUsername) result.receivedFromUsername = senderUsername;
  return result;
};

const getDatabases = async params => {
  try {
    if (params !== undefined) _validateDbInput(params);

    db_checkSignedInState();

    const {
      encryptionKey,
      ecdhPrivateKey
    } = src_ws.keys;
    const username = src_ws.session.username;
    if (params && objectHasOwnProperty(params, 'shareToken')) throw new errors.ShareTokenNotAllowed();
    const encryptionMode = params && params.encryptionMode || src_ws.encryptionMode;

    _validateEncryptionMode(encryptionMode);

    try {
      const databases = [];
      const action = 'GetDatabases';
      const requestParams = params && {
        databaseId: params.databaseId,
        dbNameHash: encryptionMode === 'server-side' ? params.databaseName : params.databaseName && (await Crypto.hmac.signString(src_ws.keys.hmacKey, params.databaseName))
      };
      let [databasesResponse, verifiedUsers] = await Promise.all([src_ws.request(action, requestParams), _openVerifiedUsersDatabase()]);
      let databaseResults = await Promise.all(databasesResponse.data.databases.map(db => _buildDatabaseResult(db, encryptionKey, ecdhPrivateKey, verifiedUsers, username)));
      databases.push(...databaseResults);

      while (databasesResponse.data.nextPageToken) {
        const params = {
          nextPageToken: databasesResponse.data.nextPageToken
        };
        databasesResponse = await src_ws.request(action, params);
        databaseResults = await Promise.all(databasesResponse.data.databases.map(db => _buildDatabaseResult(db, encryptionKey, ecdhPrivateKey, verifiedUsers, username)));
        databases.push(...databaseResults);
      }

      return {
        databases: databases.filter(database => database !== null)
      };
    } catch (e) {
      db_parseGenericErrors(e);

      throw e;
    }
  } catch (e) {
    switch (e.name) {
      case 'ParamsMustBeObject':
      case 'DatabaseNameMustBeString':
      case 'DatabaseNameCannotBeBlank':
      case 'DatabaseNameTooLong':
      case 'DatabaseNameRestricted':
      case 'DatabaseIdMustBeString':
      case 'DatabaseIdCannotBeBlank':
      case 'DatabaseIdInvalidLength':
      case 'DatabaseIdNotAllowed':
      case 'ShareTokenNotAllowed':
      case 'EncryptionModeNotValid':
      case 'ServerSideEncryptionNotEnabledInClient':
      case 'UserMustChangePassword':
      case 'UserNotSignedIn':
      case 'ServiceUnavailable':
        throw e;

      default:
        throw new errors.UnknownServiceUnavailable(e);
    }
  }
};

const _getDatabase = async (databaseName, databaseId, encryptionMode = 'end-to-end') => {
  _validateEncryptionMode(encryptionMode);

  let database;

  try {
    // check if database is already open in memory. shareToken = null because not possible to pass shareToken here
    database = getOpenDb(databaseName, databaseId, null, encryptionMode);
  } catch (_unused3) {
    // if not already open in memory, it's ok. Just get the values we need from backend
    const action = 'GetDatabases';
    const requestParams = databaseName ? {
      dbNameHash: encryptionMode === 'server-side' ? databaseName : await Crypto.hmac.signString(src_ws.keys.hmacKey, databaseName)
    } : {
      databaseId
    };
    const databaseResponse = await src_ws.request(action, requestParams);
    const databases = databaseResponse.data.databases;
    if (!databases || !databases.length) throw new errors.DatabaseNotFound();
    database = databases[0]; // type conversion :/

    database.dbNameHash = database.databaseNameHash;
    database.dbId = database.databaseId;
  }

  return database;
};

const _signFingerprintWithDbKey = async (dbKey, fingerprint) => {
  // convert dbKey into hmacKey
  const rawDbKey = await Crypto.aesGcm.getRawKeyFromKey(dbKey);
  const dbKeyHash = await Crypto.sha256.hash(rawDbKey);
  const hmacKey = await Crypto.hmac.importKeyFromRawBits(dbKeyHash); // sign fingerprint with hmacKey

  const signedFingerprint = await Crypto.hmac.signString(hmacKey, fingerprint);
  return signedFingerprint;
};

const _signDbKeyAndFingerprint = async (dbKey, fingerprint) => {
  const signedFingerprint = await _signFingerprintWithDbKey(dbKey, fingerprint); // digitally sign the signedFingerprint to enable a user to verify that
  // this user has sent/received dbKey to/from intended recipient/sender

  const signedDbKeyAndFingerprint = await Crypto.ecdsa.signString(src_ws.keys.ecdsaPrivateKey, signedFingerprint);
  return signedDbKeyAndFingerprint;
};

const _verifyDatabaseRecipientFingerprint = async (username, recipientFingerprint, verifiedUsers) => {
  // find recipient's fingerprint in verified users database
  let verifiedRecipientFingerprint, foundOldFingerprint;
  const verifiedUsersArray = Object.keys(verifiedUsers);

  for (let i = 0; i < verifiedUsersArray.length; i++) {
    const verifiedUsername = verifiedUsersArray[i];
    const verifiedFingerprint = verifiedUsers[verifiedUsername].record.fingerprint;

    if (username === verifiedUsername && recipientFingerprint === verifiedFingerprint) {
      verifiedRecipientFingerprint = verifiedFingerprint;
      break;
    } else if (verifiedFingerprint === recipientFingerprint) {
      foundOldFingerprint = true;
    }
  } // must have an outdated username stored in verified users database and therefore must reverify recipient


  if (!verifiedRecipientFingerprint && foundOldFingerprint) throw new errors.UserMustBeReverified();
  if (!verifiedRecipientFingerprint) throw new errors.UserNotVerified();
};

const _getDatabaseEncryptionKey = async database => {
  let dbKeyString;

  if (!database.dbKey) {
    dbKeyString = database.plaintextDbKey || (await Crypto.aesGcm.decryptString(src_ws.keys.encryptionKey, database.encryptedDbKey));
    database.dbKey = await Crypto.aesGcm.getKeyFromKeyString(dbKeyString);
  } else {
    dbKeyString = await Crypto.aesGcm.getKeyStringFromKey(database.dbKey);
  }

  return dbKeyString;
};

const _getShareToken = async (params, readOnly, encryptionMode) => {
  try {
    const {
      databaseName,
      databaseId
    } = params;
    if (objectHasOwnProperty(params, 'requireVerified')) throw new errors.RequireVerifiedParamNotNecessary();
    if (objectHasOwnProperty(params, 'resharingAllowed')) throw new errors.ResharingAllowedParamNotAllowed('when retrieving a share token'); // generate share token seed and associated keys

    const shareTokenSeed = Crypto.generateSeed();
    const shareTokenHkdfKey = await Crypto.hkdf.importHkdfKey(shareTokenSeed); // generate share token encryption key

    const shareTokenEncryptionKeySalt = Crypto.hkdf.generateSalt();
    const shareTokenEncryptionKey = await Crypto.aesGcm.importKeyFromMaster(shareTokenHkdfKey, shareTokenEncryptionKeySalt); // encrypt the database key using shareTokenEncryptionKey

    const database = await _getDatabase(databaseName, databaseId, encryptionMode);
    const dbKeyString = await _getDatabaseEncryptionKey(database);
    const shareTokenEncryptedDbKeyString = await Crypto.aesGcm.encryptString(shareTokenEncryptionKey, dbKeyString); // generate share token ECDSA key data

    const {
      ecdsaPublicKey,
      encryptedEcdsaPrivateKey,
      ecdsaKeyEncryptionKeySalt
    } = await Crypto.ecdsa.generateEcdsaKeyData(shareTokenHkdfKey);
    const action = 'ShareDatabaseToken';
    const requestParams = {
      databaseId: database.dbId,
      databaseNameHash: database.dbNameHash,
      readOnly,
      keyData: {
        shareTokenEncryptedDbKey: shareTokenEncryptedDbKeyString,
        shareTokenEncryptionKeySalt: external_base64_arraybuffer_default.a.encode(shareTokenEncryptionKeySalt),
        shareTokenPublicKey: ecdsaPublicKey,
        shareTokenEncryptedEcdsaPrivateKey: encryptedEcdsaPrivateKey,
        shareTokenEcdsaKeyEncryptionKeySalt: ecdsaKeyEncryptionKeySalt
      }
    };
    const shareTokenResponse = await src_ws.request(action, requestParams); // server generates unique ID

    const {
      shareTokenId
    } = shareTokenResponse.data; // prepend shareTokenId to shareTokenSeed to get final shareToken to return to user, all in base64

    const shareTokenIdArrayBuffer = stringToArrayBuffer(shareTokenId, true);
    const shareToken = external_base64_arraybuffer_default.a.encode(appendBuffer(shareTokenIdArrayBuffer, shareTokenSeed));
    return shareToken;
  } catch (e) {
    db_parseGenericErrors(e);

    if (e.response && e.response.data) {
      switch (e.response.data.message) {
        case 'DatabaseNotFound':
          throw new errors.DatabaseNotFound();

        case 'ResharingNotAllowed':
          throw new errors.ResharingNotAllowed('Only the owner can generate a share token');
      }
    }

    throw e;
  }
};

const _shareDatabaseWithUsername = async (params, readOnly, resharingAllowed, requireVerified, encryptionMode) => {
  const {
    databaseName,
    databaseId
  } = params;
  const username = params.username.toLowerCase();

  try {
    // get recipient's public key to use to generate a shared key, and retrieve verified users list if requireVerified set to true
    const [recipientPublicKey, verifiedUsers, database] = await Promise.all([api_auth.getPublicKey(username), requireVerified && _openVerifiedUsersDatabase(), _getDatabase(databaseName, databaseId, encryptionMode)]); // recipient must have required keys so client can share database key

    if (!recipientPublicKey.ecdhPublicKey || !recipientPublicKey.ecdsaPublicKey) throw new errors.UserUnableToReceiveDatabase(); // compute recipient's fingerprint of ECDSA public key stored on server

    const recipientRawEcdsaPublicKey = external_base64_arraybuffer_default.a.decode(recipientPublicKey.ecdsaPublicKey);
    const recipientFingerprint = await _getFingerprint(recipientRawEcdsaPublicKey); // verify that the recipient is in the user's list of verified users

    if (requireVerified) await _verifyDatabaseRecipientFingerprint(username, recipientFingerprint, verifiedUsers); // verify recipient signed the ECDH public key that sender will be using to share database

    const recipientEcdsaPublicKey = await Crypto.ecdsa.getPublicKeyFromRawPublicKey(recipientRawEcdsaPublicKey);
    const {
      signedEcdhPublicKey,
      ecdhPublicKey
    } = recipientPublicKey;
    const isVerified = await Crypto.ecdsa.verify(recipientEcdsaPublicKey, external_base64_arraybuffer_default.a.decode(signedEcdhPublicKey), external_base64_arraybuffer_default.a.decode(ecdhPublicKey)); // this should never happen. If this happens, the server is serving conflicting keys and client should not sign anything

    if (!isVerified) throw new errors.ServiceUnavailable();
    const recipientEcdhPublicKey = await Crypto.ecdh.getPublicKeyFromRawPublicKey(external_base64_arraybuffer_default.a.decode(recipientPublicKey.ecdhPublicKey)); // generate ephemeral ECDH key pair to ensure forward secrecy for future shares between users if shared key is leaked

    const ephemeralEcdhKeyPair = await Crypto.ecdh.generateKeyPair();
    const rawEphemeralEcdhPublicKey = await Crypto.ecdh.getRawPublicKeyFromPublicKey(ephemeralEcdhKeyPair.publicKey);
    const signedEphemeralEcdhPublicKey = await Crypto.ecdsa.sign(src_ws.keys.ecdsaPrivateKey, rawEphemeralEcdhPublicKey); // compute shared key encryption key with recipient so can use it to encrypt database encryption key

    const sharedKeyEncryptionKey = await Crypto.ecdh.computeSharedKeyEncryptionKey(recipientEcdhPublicKey, ephemeralEcdhKeyPair.privateKey); // encrypt the database encryption key using shared ephemeral ECDH key

    const dbKeyString = await _getDatabaseEncryptionKey(database);
    const sharedEncryptedDbKeyString = await Crypto.aesGcm.encryptString(sharedKeyEncryptionKey, dbKeyString);
    const action = 'ShareDatabase';
    const requestParams = {
      databaseId: database.dbId,
      databaseNameHash: database.dbNameHash,
      username,
      readOnly,
      resharingAllowed,
      sharedEncryptedDbKey: sharedEncryptedDbKeyString,
      ephemeralPublicKey: external_base64_arraybuffer_default.a.encode(rawEphemeralEcdhPublicKey),
      signedEphemeralPublicKey: external_base64_arraybuffer_default.a.encode(signedEphemeralEcdhPublicKey),
      sentSignature: await _signDbKeyAndFingerprint(database.dbKey, recipientFingerprint),
      recipientEcdsaPublicKey: recipientPublicKey.ecdsaPublicKey
    };
    await src_ws.request(action, requestParams);
  } catch (e) {
    db_parseGenericErrors(e);

    if (e.response && e.response.data) {
      switch (e.response.data.message) {
        case 'SharingWithSelfNotAllowed':
          throw new errors.SharingWithSelfNotAllowed();

        case 'DatabaseNotFound':
          throw new errors.DatabaseNotFound();

        case 'ResharingNotAllowed':
          throw new errors.ResharingNotAllowed('Must have permission to reshare the database with another user');

        case 'ResharingWithWriteAccessNotAllowed':
          throw new errors.ResharingWithWriteAccessNotAllowed();

        case 'UserNotFound':
          throw new errors.UserNotFound();

        case 'DatabaseAlreadyShared':
          // safe to return
          return;
      }
    }

    throw e;
  }
};

const db_validateUsername = username => {
  if (typeof username !== 'string') throw new errors.UsernameMustBeString();
  if (username.length === 0) throw new errors.UsernameCannotBeBlank();
};

const _validateDbSharingInput = params => {
  if (objectHasOwnProperty(params, 'shareToken')) throw new errors.ShareTokenNotAllowed();
  if (objectHasOwnProperty(params, 'username')) db_validateUsername(params.username);

  if (objectHasOwnProperty(params, 'readOnly') && typeof params.readOnly !== 'boolean') {
    throw new errors.ReadOnlyMustBeBoolean();
  }

  if (objectHasOwnProperty(params, 'resharingAllowed') && typeof params.resharingAllowed !== 'boolean') {
    throw new errors.ResharingAllowedMustBeBoolean();
  }

  if (objectHasOwnProperty(params, 'requireVerified') && typeof params.requireVerified !== 'boolean') {
    throw new errors.RequireVerifiedMustBeBoolean();
  }
};

const shareDatabase = async params => {
  try {
    _validateDbInput(params);

    _validateDbSharingInput(params);

    const readOnly = objectHasOwnProperty(params, 'readOnly') ? params.readOnly : true;
    const resharingAllowed = objectHasOwnProperty(params, 'resharingAllowed') ? params.resharingAllowed : false;
    const requireVerified = objectHasOwnProperty(params, 'requireVerified') ? params.requireVerified : true;
    const encryptionMode = params.encryptionMode || src_ws.encryptionMode;

    _validateEncryptionMode(encryptionMode);

    let result = {};
    if (objectHasOwnProperty(params, 'username')) await _shareDatabaseWithUsername(params, readOnly, resharingAllowed, requireVerified, encryptionMode);else result.shareToken = await _getShareToken(params, readOnly, encryptionMode);
    return result;
  } catch (e) {
    switch (e.name) {
      case 'ParamsMustBeObject':
      case 'DatabaseNameMissing':
      case 'DatabaseNameMustBeString':
      case 'DatabaseNameCannotBeBlank':
      case 'DatabaseNameTooLong':
      case 'DatabaseNameRestricted':
      case 'DatabaseIdMustBeString':
      case 'DatabaseIdCannotBeBlank':
      case 'DatabaseIdInvalidLength':
      case 'DatabaseIdNotAllowed':
      case 'ShareTokenNotAllowed':
      case 'DatabaseNotFound':
      case 'EncryptionModeNotValid':
      case 'ServerSideEncryptionNotEnabledInClient':
      case 'UsernameCannotBeBlank':
      case 'UsernameMustBeString':
      case 'ReadOnlyMustBeBoolean':
      case 'ResharingAllowedMustBeBoolean':
      case 'ResharingNotAllowed':
      case 'ResharingWithWriteAccessNotAllowed':
      case 'ResharingAllowedParamNotAllowed':
      case 'RequireVerifiedMustBeBoolean':
      case 'RequireVerifiedParamNotNecessary':
      case 'SharingWithSelfNotAllowed':
      case 'UserMustChangePassword':
      case 'UserNotSignedIn':
      case 'UserUnableToReceiveDatabase':
      case 'UserNotFound':
      case 'UserNotVerified':
      case 'UserMustBeReverified':
      case 'ServiceUnavailable':
        throw e;

      default:
        throw new errors.UnknownServiceUnavailable(e);
    }
  }
};

const modifyDatabasePermissions = async params => {
  try {
    _validateDbInput(params);

    _validateDbSharingInput(params);

    if (!objectHasOwnProperty(params, 'username')) throw new errors.UsernameMissing();

    if (objectHasOwnProperty(params, 'revoke')) {
      if (typeof params.revoke !== 'boolean') throw new errors.RevokeMustBeBoolean(); // readOnly and resharingAllowed booleans have no use if revoking database from user

      if (params.revoke) {
        if (objectHasOwnProperty(params, 'readOnly')) throw new errors.ReadOnlyParamNotAllowed();
        if (objectHasOwnProperty(params, 'resharingAllowed')) throw new errors.ResharingAllowedParamNotAllowed('when revoking access to a database');
      }
    } else if (!objectHasOwnProperty(params, 'readOnly') && !objectHasOwnProperty(params, 'resharingAllowed')) {
      throw new errors.ParamsMissing();
    }

    const {
      databaseName,
      databaseId,
      readOnly,
      resharingAllowed,
      revoke,
      encryptionMode = src_ws.encryptionMode
    } = params;
    const username = params.username.toLowerCase();

    try {
      const database = await _getDatabase(databaseName, databaseId, encryptionMode);
      const action = 'ModifyDatabasePermissions';
      const requestParams = {
        databaseId: database.dbId,
        databaseNameHash: database.dbNameHash,
        username,
        readOnly,
        resharingAllowed,
        revoke
      };
      await src_ws.request(action, requestParams);
    } catch (e) {
      db_parseGenericErrors(e);

      if (e.response && e.response.data) {
        switch (e.response.data.message) {
          case 'SharingWithSelfNotAllowed':
            throw new errors.ModifyingOwnPermissionsNotAllowed();

          case 'ModifyingOwnerPermissionsNotAllowed':
            throw new errors.ModifyingOwnerPermissionsNotAllowed();

          case 'ResharingNotAllowed':
            throw new errors.ModifyingPermissionsNotAllowed();

          case 'ResharingWithWriteAccessNotAllowed':
            throw new errors.GrantingWriteAccessNotAllowed();

          case 'DatabaseNotFound':
            throw new errors.DatabaseNotFound();

          case 'UserNotFound':
            throw new errors.UserNotFound();
        }
      }

      throw e;
    }
  } catch (e) {
    switch (e.name) {
      case 'ParamsMustBeObject':
      case 'ParamsMissing':
      case 'DatabaseNameMissing':
      case 'DatabaseNameMustBeString':
      case 'DatabaseNameCannotBeBlank':
      case 'DatabaseNameTooLong':
      case 'DatabaseNameRestricted':
      case 'DatabaseIdMustBeString':
      case 'DatabaseIdCannotBeBlank':
      case 'DatabaseIdInvalidLength':
      case 'DatabaseIdNotAllowed':
      case 'ShareTokenNotAllowed':
      case 'DatabaseNotFound':
      case 'EncryptionModeNotValid':
      case 'ServerSideEncryptionNotEnabledInClient':
      case 'UsernameMissing':
      case 'UsernameCannotBeBlank':
      case 'UsernameMustBeString':
      case 'ReadOnlyMustBeBoolean':
      case 'ReadOnlyParamNotAllowed':
      case 'ResharingAllowedMustBeBoolean':
      case 'ResharingAllowedParamNotAllowed':
      case 'RevokeMustBeBoolean':
      case 'ModifyingOwnPermissionsNotAllowed':
      case 'ModifyingOwnerPermissionsNotAllowed':
      case 'ModifyingPermissionsNotAllowed':
      case 'GrantingWriteAccessNotAllowed':
      case 'UserMustChangePassword':
      case 'UserNotSignedIn':
      case 'UserNotFound':
      case 'ServiceUnavailable':
        throw e;

      default:
        throw new errors.UnknownServiceUnavailable(e);
    }
  }
};

const _packVerificationMessage = (username, fingerprint) => {
  return btoa(JSON.stringify({
    username,
    fingerprint
  }));
};

const _unpackVerificationMessage = verificationMessage => {
  try {
    const {
      username,
      fingerprint
    } = JSON.parse(atob(verificationMessage));

    db_validateUsername(username);

    if (!fingerprint) throw new errors.VerificationMessageInvalid();
    return {
      username,
      fingerprint
    };
  } catch (_unused4) {
    throw new errors.VerificationMessageInvalid();
  }
};

const _getFingerprint = async ecdsaRawPublicKey => {
  const ecdsaPublicKeyHash = await Crypto.sha256.hash(ecdsaRawPublicKey);
  const fingerprint = external_base64_arraybuffer_default.a.encode(ecdsaPublicKeyHash);
  return fingerprint;
};

const _getMyFingerprint = async () => {
  const ecdsaPublicKey = await Crypto.ecdsa.getPublicKeyFromPrivateKey(src_ws.keys.ecdsaPrivateKey);
  const ecdsaRawPublicKey = await Crypto.ecdsa.getRawPublicKeyFromPublicKey(ecdsaPublicKey);
  const fingerprint = await _getFingerprint(ecdsaRawPublicKey);
  return fingerprint;
};

const getVerificationMessage = async () => {
  try {
    db_checkSignedInState();

    const username = src_ws.session.username;
    const fingerprint = await _getMyFingerprint();

    const verificationMessage = _packVerificationMessage(username, fingerprint);

    return {
      verificationMessage
    };
  } catch (e) {
    switch (e.name) {
      case 'UserMustChangePassword':
      case 'UserNotSignedIn':
      case 'ServiceUnavailable':
        throw e;

      default:
        throw new errors.UnknownServiceUnavailable(e);
    }
  }
};

const _openVerifiedUsersDatabase = async () => {
  const databaseName = VERIFIED_USERS_DATABASE_NAME;

  const changeHandler = () => {}; // not used


  const allowVerifiedUsersDatabase = true;
  const encryptionMode = 'end-to-end'; // if server has access, opens attack vector because can withold and/or replace verified users

  await openDatabase({
    databaseName,
    changeHandler,
    allowVerifiedUsersDatabase,
    encryptionMode
  });
  const dbNameHash = src_ws.state.dbNameToHash[databaseName];
  const verifiedUsers = src_ws.state.databases[dbNameHash].items;
  return verifiedUsers;
};

const verifyUser = async params => {
  try {
    if (typeof params !== 'object') throw new errors.ParamsMustBeObject();

    db_checkSignedInState();

    if (!objectHasOwnProperty(params, 'verificationMessage')) throw new errors.VerificationMessageMissing();
    const {
      verificationMessage
    } = params;
    if (typeof verificationMessage !== 'string') throw new errors.VerificationMessageMustBeString();
    if (verificationMessage.length === 0) throw new errors.VerificationMessageCannotBeBlank();

    const {
      username,
      fingerprint
    } = _unpackVerificationMessage(verificationMessage);

    if (username === src_ws.session.username || fingerprint === (await _getMyFingerprint())) throw new errors.VerifyingSelfNotAllowed(); // upsert the verification message into the user's encrypted database that stores verified users

    await _openVerifiedUsersDatabase();
    const databaseName = VERIFIED_USERS_DATABASE_NAME;
    const allowVerifiedUsersDatabase = true;
    const itemId = username;
    const item = {
      fingerprint
    };

    try {
      await insertItem({
        databaseName,
        itemId,
        item,
        allowVerifiedUsersDatabase
      });
    } catch (e) {
      if (e.name === 'ItemAlreadyExists') await updateItem({
        databaseName,
        itemId,
        item,
        allowVerifiedUsersDatabase
      });else throw e;
    }
  } catch (e) {
    switch (e.name) {
      case 'ParamsMustBeObject':
      case 'VerificationMessageMissing':
      case 'VerificationMessageMustBeString':
      case 'VerificationMessageCannotBeBlank':
      case 'VerificationMessageInvalid':
      case 'VerifyingSelfNotAllowed':
      case 'UserMustChangePassword':
      case 'UserNotSignedIn':
      case 'ServiceUnavailable':
        throw e;

      default:
        throw new errors.UnknownServiceUnavailable(e);
    }
  }
};

/* harmony default export */ var src_db = ({
  openDatabase,
  getDatabases,
  insertItem,
  updateItem,
  deleteItem,
  putTransaction,
  uploadFile,
  getFile,
  shareDatabase,
  modifyDatabasePermissions,
  getVerificationMessage,
  verifyUser
});
// CONCATENATED MODULE: ./src/payments.js






const payments_checkSignedInState = () => {
  if (src_ws.reconnecting) throw new errors.Reconnecting();
  if (!src_ws.keys.init && src_ws.changePassword) throw new errors.UserMustChangePassword();
  if (!src_ws.keys.init) throw new errors.UserNotSignedIn();
};

const payments_parseGenericErrors = e => {
  if (e.response) {
    if (e.response.status === statusCodes['Internal Server Error']) {
      throw new errors.InternalServerError();
    } else if (e.response.status === statusCodes['Gateway Timeout']) {
      throw new errors.Timeout();
    }
  } else if (e.message && e.message.indexOf('timeout') !== -1) {
    throw new errors.Timeout();
  }
};

const _validatePurchaseOrUpdate = params => {
  payments_checkSignedInState();

  const stripeData = src_ws.userData.stripeData;
  if (!stripeData.stripeAccountId) throw new errors.StripeAccountNotConnected();
  if (stripeData.paymentsMode === 'disabled') throw new errors.PaymentsDisabled();
  if (!objectHasOwnProperty(window, 'Stripe')) throw new errors.StripeJsLibraryMissing();
  if (typeof params !== 'object') throw new errors.ParamsMustBeObject();
  if (!objectHasOwnProperty(params, 'successUrl')) throw new errors.SuccessUrlMissing();
  if (typeof params.successUrl !== 'string') throw new errors.SuccessUrlMustBeString();
  const successUrlProtocol = getProtocolFromEndpoint(params.successUrl);

  if (successUrlProtocol !== 'http' && successUrlProtocol !== 'https') {
    const invalidProtocol = true;
    throw new errors.SuccessUrlInvalid(invalidProtocol);
  }

  if (!objectHasOwnProperty(params, 'cancelUrl')) throw new errors.CancelUrlMissing();
  if (typeof params.cancelUrl !== 'string') throw new errors.CancelUrlMustBeString();
  const cancelUrlProtocol = getProtocolFromEndpoint(params.cancelUrl);

  if (cancelUrlProtocol !== 'http' && cancelUrlProtocol !== 'https') {
    const invalidProtocol = true;
    throw new errors.CancelUrlInvalid(invalidProtocol);
  }
};

const purchaseSubscription = async params => {
  try {
    const stripeData = src_ws.userData.stripeData;

    if (!stripeData.cancelSubscriptionAt && stripeData.subscriptionStatus && stripeData.subscriptionStatus !== 'canceled') {
      throw new errors.SubscriptionPlanAlreadyPurchased();
    }

    _validatePurchaseOrUpdate(params);

    try {
      const action = 'PurchaseSubscription';
      const sessionIdResponse = await src_ws.request(action, params);
      const stripeSessionId = sessionIdResponse.data;
      const stripePk = src_config.getStripePublishableKey(stripeData.paymentsMode === 'prod');
      const result = await window.Stripe(stripePk, {
        stripeAccount: stripeData.stripeAccountId
      }).redirectToCheckout({
        sessionId: stripeSessionId
      });
      if (result.error) throw result.error;
    } catch (e) {
      payments_parseGenericErrors(e);

      if (e.response) {
        switch (e.response.data) {
          case 'PriceIdOrPlanIdAllowed':
            throw new errors.PriceIdOrPlanIdAllowed();

          case 'PriceIdOrPlanIdMissing':
            throw new errors.PriceIdOrPlanIdMissing();

          case 'SubscriptionPlanAlreadyPurchased':
            throw new errors.SubscriptionPlanAlreadyPurchased();

          case 'SuccessUrlInvalid':
            throw new errors.SuccessUrlInvalid();

          case 'CancelUrlInvalid':
            throw new errors.CancelUrlInvalid();

          default:
            {
              if (e.response.data && e.response.data.name === 'StripeError') {
                throw new errors.StripeError(e.response.data);
              }
            }
        }
      }

      throw e;
    }
  } catch (e) {
    switch (e.name) {
      case 'ParamsMustBeObject':
      case 'SuccessUrlMissing':
      case 'SuccessUrlMustBeString':
      case 'SuccessUrlInvalid':
      case 'CancelUrlMissing':
      case 'CancelUrlMustBeString':
      case 'CancelUrlInvalid':
      case 'StripeError':
      case 'StripeJsLibraryMissing':
      case 'PriceIdOrPlanIdAllowed':
      case 'PriceIdOrPlanIdMissing':
      case 'SubscriptionPlanAlreadyPurchased':
      case 'StripeAccountNotConnected':
      case 'PaymentsDisabled':
      case 'UserMustChangePassword':
      case 'UserNotSignedIn':
      case 'TooManyRequests':
      case 'ServiceUnavailable':
        throw e;

      default:
        throw new errors.UnknownServiceUnavailable(e);
    }
  }
};

const _validateModifySubscriptionConditions = () => {
  payments_checkSignedInState();

  const stripeData = src_ws.userData.stripeData;
  if (!stripeData.stripeAccountId) throw new errors.StripeAccountNotConnected();
  if (stripeData.paymentsMode === 'disabled') throw new errors.PaymentsDisabled();
  if (stripeData.subscriptionStatus === 'canceled') throw new errors.SubscriptionAlreadyCanceled();
};

const cancelSubscription = async () => {
  try {
    _validateModifySubscriptionConditions();

    try {
      const action = 'CancelSubscription';
      const cancelResponse = await src_ws.request(action);
      const cancelSubscriptionAt = cancelResponse.data;
      src_ws.userData.stripeData.cancelSubscriptionAt = cancelSubscriptionAt;
      return {
        cancelSubscriptionAt
      };
    } catch (e) {
      payments_parseGenericErrors(e);

      if (e.response && e.response.data === 'SubscriptionNotFound') {
        throw new errors.SubscriptionNotFound();
      }

      throw e;
    }
  } catch (e) {
    switch (e.name) {
      case 'SubscriptionNotFound':
      case 'StripeAccountNotConnected':
      case 'PaymentsDisabled':
      case 'SubscriptionAlreadyCanceled':
      case 'UserMustChangePassword':
      case 'UserNotSignedIn':
      case 'TooManyRequests':
      case 'ServiceUnavailable':
        throw e;

      default:
        throw new errors.UnknownServiceUnavailable(e);
    }
  }
};

const resumeSubscription = async () => {
  try {
    _validateModifySubscriptionConditions();

    try {
      const action = 'ResumeSubscription';
      await src_ws.request(action);
      delete src_ws.userData.stripeData.cancelSubscriptionAt;
    } catch (e) {
      payments_parseGenericErrors(e);

      if (e.response && e.response.data === 'SubscriptionNotFound') {
        throw new errors.SubscriptionNotFound();
      }

      throw e;
    }
  } catch (e) {
    switch (e.name) {
      case 'SubscriptionNotFound':
      case 'StripeAccountNotConnected':
      case 'PaymentsDisabled':
      case 'SubscriptionAlreadyCanceled':
      case 'UserMustChangePassword':
      case 'UserNotSignedIn':
      case 'TooManyRequests':
      case 'ServiceUnavailable':
        throw e;

      default:
        throw new errors.UnknownServiceUnavailable(e);
    }
  }
};

const updatePaymentMethod = async params => {
  try {
    _validatePurchaseOrUpdate(params);

    const stripeData = src_ws.userData.stripeData;
    if (!stripeData.subscriptionStatus) throw new errors.SubscriptionNotPurchased();

    try {
      const action = 'UpdatePaymentMethod';
      const sessionIdResponse = await src_ws.request(action, params);
      const stripeSessionId = sessionIdResponse.data;
      const stripePk = src_config.getStripePublishableKey(stripeData.paymentsMode === 'prod');
      const result = await window.Stripe(stripePk, {
        stripeAccount: stripeData.stripeAccountId
      }).redirectToCheckout({
        sessionId: stripeSessionId
      });
      if (result.error) throw result.error;
    } catch (e) {
      payments_parseGenericErrors(e);

      if (e.response) {
        if (e.response.data === 'SuccessUrlInvalid') {
          throw new errors.SuccessUrlInvalid();
        } else if (e.response.data === 'CancelUrlInvalid') {
          throw new errors.CancelUrlInvalid();
        }
      }

      throw e;
    }
  } catch (e) {
    switch (e.name) {
      case 'ParamsMustBeObject':
      case 'SuccessUrlMissing':
      case 'SuccessUrlMustBeString':
      case 'SuccessUrlInvalid':
      case 'CancelUrlMissing':
      case 'CancelUrlMustBeString':
      case 'CancelUrlInvalid':
      case 'StripeJsLibraryMissing':
      case 'SubscriptionNotPurchased':
      case 'StripeAccountNotConnected':
      case 'PaymentsDisabled':
      case 'UserMustChangePassword':
      case 'UserNotSignedIn':
      case 'TooManyRequests':
      case 'ServiceUnavailable':
        throw e;

      default:
        throw new errors.UnknownServiceUnavailable(e);
    }
  }
};

/* harmony default export */ var src_payments = ({
  purchaseSubscription,
  cancelSubscription,
  resumeSubscription,
  updatePaymentMethod
});
// CONCATENATED MODULE: ./src/index.js



/* harmony default export */ var src = __webpack_exports__["default"] = ({
  init: src_auth.init,
  signUp: src_auth.signUp,
  signIn: src_auth.signIn,
  signOut: src_auth.signOut,
  updateUser: src_auth.updateUser,
  deleteUser: src_auth.deleteUser,
  forgotPassword: src_auth.forgotPassword,
  openDatabase: src_db.openDatabase,
  insertItem: src_db.insertItem,
  updateItem: src_db.updateItem,
  deleteItem: src_db.deleteItem,
  putTransaction: src_db.putTransaction,
  uploadFile: src_db.uploadFile,
  getFile: src_db.getFile,
  getDatabases: src_db.getDatabases,
  shareDatabase: src_db.shareDatabase,
  modifyDatabasePermissions: src_db.modifyDatabasePermissions,
  getVerificationMessage: src_db.getVerificationMessage,
  verifyUser: src_db.verifyUser,
  purchaseSubscription: src_payments.purchaseSubscription,
  cancelSubscription: src_payments.cancelSubscription,
  resumeSubscription: src_payments.resumeSubscription,
  updatePaymentMethod: src_payments.updatePaymentMethod
});

/***/ })
/******/ ])["default"]));
//# sourceMappingURL=userbase.cjs.js.map