import _defineProperty from "@babel/runtime/helpers/esm/defineProperty";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

import base64 from 'base64-arraybuffer';
import uuidv4 from 'uuid/v4';
import localData from './localData';
import crypto from './Crypto';
import { getWsUrl } from './utils';
import statusCodes from './statusCodes';
import config from './config';
import errors from './errors';
import { appendBuffers, arrayBufferToString, stringToArrayBuffer } from './Crypto/utils';
import { compress, decompress } from './worker';
import { uploadBundleChunk } from './api/db';
const wsAlreadyConnected = 'Web Socket already connected';
const BACKOFF_RETRY_DELAY = 1000;
const MAX_RETRY_DELAY = 1000 * 30;
const BUNDLE_CHUNK_SIZE = 1024 * 512; // 512kb

const BUNDLE_CHUNKS_PER_BATCH = 10;
const WS_REQUEST_TIMEOUT = 30 * 1000;
const clientId = uuidv4(); // only 1 client ID per browser tab (assumes code does not reload)

class RequestFailed extends Error {
  constructor(action, e, ...params) {
    super(...params);
    this.name = "RequestFailed: ".concat(action);
    this.message = e.message;
    this.status = e.status || e.message === 'timeout' && statusCodes['Gateway Timeout'];
    this.response = e.status && e;
  }

}

class WebSocketError extends Error {
  constructor(message, username, e, ...params) {
    super(...params);
    this.name = 'WebSocket error';
    this.message = message;
    this.username = username;
    this.e = e;
  }

}

class Connection {
  constructor() {
    this.init();
  }

  init(resolveConnection, rejectConnection, session, seedString, rememberMe, changePassword, state, encryptionMode) {
    if (this.pingTimeout) clearTimeout(this.pingTimeout);

    for (const property of Object.keys(this)) {
      delete this[property];
    }

    this.ws = null;
    this.connected = false;
    this.resolveConnection = resolveConnection;
    this.rejectConnection = rejectConnection;
    this.connectionResolved = false;
    this.session = {
      username: session && session.username,
      sessionId: session && session.sessionId,
      creationDate: session && session.creationDate,
      expirationDate: session && session.expirationDate,
      userId: session && session.userId,
      authToken: session && session.authToken
    };
    this.seedString = seedString;
    this.changePassword = changePassword;
    this.keys = {
      init: false,
      salts: {}
    };
    this.userData = {
      stripeData: {}
    };
    this.rememberMe = rememberMe;
    this.requests = {};
    this.state = state || {
      dbNameToHash: {},
      databases: {},
      // used when openDatabase is called with databaseName
      databasesByDbId: {},
      // used when openDatabase is called with databaseId
      shareTokenIdToDbId: {} // used when openDatabase is called with shareToken

    };
    this.encryptionMode = encryptionMode;
  }

  connect(session, seedString = null, rememberMe, changePassword, reconnectDelay, state) {
    if (this.connected) throw new WebSocketError(wsAlreadyConnected, this.session.username);
    return new Promise((resolve, reject) => {
      let timeout = false;
      const timeoutToOpenWebSocket = setTimeout(() => {
        if (!this.connected && !this.reconnecting) {
          timeout = true;
          reject(new WebSocketError('timeout'));
        }
      }, 10000);
      const url = "".concat(getWsUrl(config.getEndpoint()), "/api?appId=").concat(config.getAppId(), "&sessionId=").concat(session.sessionId, "&clientId=").concat(clientId, "&userbaseJsVersion=").concat(config.USERBASE_JS_VERSION);
      const ws = new WebSocket(url);

      ws.onopen = async () => {
        if (timeout) return;
        clearTimeout(timeoutToOpenWebSocket);
      };

      ws.onmessage = async e => {
        if (timeout) return;

        try {
          const message = JSON.parse(e.data);
          const route = message.route;

          switch (route) {
            case 'Ping':
              {
                this.heartbeat();
                const action = 'Pong';
                this.ws.send(JSON.stringify({
                  action
                }));
                break;
              }

            case 'Connection':
              {
                const {
                  encryptionMode
                } = message;
                this.init(resolve, reject, session, seedString, rememberMe, changePassword, state, encryptionMode);
                this.ws = ws;
                this.heartbeat();
                this.connected = true; // seedString not present on initial connection when still need to change password

                if (seedString) {
                  const {
                    keySalts,
                    validationMessage,
                    ecKeyData,
                    encryptedValidationMessage
                  } = message;
                  this.keys.salts = keySalts;
                  this.validationMessage = validationMessage;
                  this.ecKeyData = ecKeyData; // provided by userbase-server for users who have not yet generated their ECDSA key and
                  // still only have a DH key

                  if (encryptedValidationMessage) this.encryptedValidationMessage = new Uint8Array(encryptedValidationMessage.data);

                  try {
                    await this.setKeys(this.seedString);
                    const userData = await this.validateKey();
                    this.userData = userData;
                  } catch (e) {
                    if (e && e.name === 'OperationError' || e instanceof DOMException) throw new Error('Invalid seed');else throw e;
                  }

                  this.keys.init = true;
                }

                this.resolveConnection();
                this.connectionResolved = true;
                break;
              }

            case 'ApplyTransactions':
              {
                const dbId = message.dbId;
                const dbNameHash = message.dbNameHash; // if owner, must have opened the database via databaseName

                const database = message.isOwner ? this.state.databases[dbNameHash] : this.state.databasesByDbId[dbId];
                if (!database) throw new Error('Missing database'); // queue guarantees transactions will be applied in the order they are received from the server

                if (database.applyTransactionsQueue.isEmpty()) {
                  // take a spot in the queue and proceed applying so the next caller knows queue is not empty
                  database.applyTransactionsQueue.enqueue(null);
                } else {
                  // wait until prior batch in queue finishes applying successfully
                  await new Promise(resolve => {
                    const startApplyingThisBatchOfTransactions = resolve;
                    database.applyTransactionsQueue.enqueue(startApplyingThisBatchOfTransactions);
                  });
                }

                const openingDatabase = message.dbNameHash && (message.dbKey || message.plaintextDbKey) || message.shareTokenEncryptedDbKey;

                if (openingDatabase && (!database.dbKeyString || !database.dbKey)) {
                  const dbKeyString = message.plaintextDbKey || (message.dbKey ? await crypto.aesGcm.decryptString(this.keys.encryptionKey, message.dbKey) : await database.decryptShareTokenEncryptedDbKey(message.shareTokenEncryptedDbKey, message.shareTokenEncryptionKeySalt));
                  database.dbKeyString = dbKeyString;
                  database.dbKey = await crypto.aesGcm.getKeyFromKeyString(dbKeyString);
                }

                if (!database.dbKey) throw new Error('Missing db key');

                if (message.writers) {
                  database.attributionEnabled = true;

                  for (const {
                    userId,
                    username
                  } of message.writers) {
                    database.usernamesByUserId.set(userId, username);
                  }
                } // server is sending bundle in chunks, wait until it sends the entire bundle and client applies it


                if (message.waitForFullBundle) {
                  if (!database.finishedWaitingForBundle) {
                    await new Promise(resolve => database.finishedWaitingForBundle = resolve);
                  } // rebuild bundle from the chunks


                  try {
                    const bundle = await this.rebuildBundle(database, message.bundleSeqNo, message.encryptedBundleEncryptionKey);
                    await database.applyBundle(bundle, message.bundleSeqNo);
                  } catch (e) {
                    window.alert("Oops! Something went wrong. Please contact the site administrator with this issue (".concat(dbId, ").\n\n") + e);
                    throw e;
                  }
                }

                const newTransactions = message.transactionLog;
                await database.applyTransactions(newTransactions, message.ownerId, dbId, dbNameHash);

                if (message.buildBundle) {
                  this.buildBundle(database);
                } // start applying next batch in queue when this one is finished applying successfully


                database.applyTransactionsQueue.dequeue();

                if (!database.applyTransactionsQueue.isEmpty()) {
                  const startApplyingNextBatchInQueue = database.applyTransactionsQueue.peek();
                  startApplyingNextBatchInQueue();
                }

                break;
              }

            case 'DownloadBundleChunk':
              {
                const {
                  dbId,
                  dbNameHash,
                  isOwner,
                  bundleSeqNo,
                  isFirstChunk,
                  isLastChunk,
                  chunk
                } = message; // if owner, must have opened the database via databaseName

                const database = isOwner ? this.state.databases[dbNameHash] : this.state.databasesByDbId[dbId];
                if (!database) throw new Error('Missing database'); // assumes server will always send first chunk first, and last chunk last

                if (isFirstChunk) database.bundleChunks[bundleSeqNo] = [];
                database.bundleChunks[bundleSeqNo].push(chunk);

                if (isLastChunk) {
                  if (database.finishedWaitingForBundle) database.finishedWaitingForBundle();else database.finishedWaitingForBundle = true;
                }

                break;
              }

            case 'UpdatedUser':
              {
                this.handleUpdateUser(message.updatedUser);
                break;
              }

            case 'SignOut':
            case 'UpdateUser':
            case 'DeleteUser':
            case 'CreateDatabase':
            case 'OpenDatabase':
            case 'OpenDatabaseByDatabaseId':
            case 'GetDatabases':
            case 'GetDatabaseUsers':
            case 'Insert':
            case 'Update':
            case 'Delete':
            case 'BatchTransaction':
            case 'InitBundleUpload':
            case 'CompleteBundleUpload':
            case 'GenerateFileId':
            case 'UploadFileChunk':
            case 'CompleteFileUpload':
            case 'GetChunk':
            case 'ValidateKey':
            case 'GetPasswordSalts':
            case 'PurchaseSubscription':
            case 'CancelSubscription':
            case 'ResumeSubscription':
            case 'UpdatePaymentMethod':
            case 'ShareDatabase':
            case 'ShareDatabaseToken':
            case 'AuthenticateShareToken':
            case 'SaveDatabase':
            case 'ModifyDatabasePermissions':
            case 'VerifyUser':
              {
                const requestId = message.requestId;
                if (!requestId) return console.warn('Missing request id');
                const request = this.requests[requestId];
                if (!request) return console.warn("Request ".concat(requestId, " no longer exists!"));else if (!request.promiseResolve || !request.promiseReject) return;
                const response = message.response;
                const successfulResponse = response && response.status === statusCodes['Success'];
                if (!successfulResponse) return request.promiseReject(response);else return request.promiseResolve(response);
              }

            default:
              {
                console.log('Received unknown message from backend:' + JSON.stringify(message));
                break;
              }
          }
        } catch (e) {
          if (!this.connectionResolved) {
            this.close();
            reject(new WebSocketError(e.message, session.username, e));
          } else {
            console.warn('Error handling message: ', e);
          }
        }
      };

      ws.onclose = async e => {
        if (timeout) return;
        const serviceRestart = e.code === statusCodes['Service Restart'];
        const clientDisconnected = e.code === statusCodes['No Pong Received'];
        const attemptToReconnect = serviceRestart || clientDisconnected || !e.wasClean; // closed without explicit call to ws.close()

        if (attemptToReconnect) {
          const delay = serviceRestart && !reconnectDelay ? 0 : reconnectDelay ? reconnectDelay + BACKOFF_RETRY_DELAY : 1000;
          this.reconnecting = true;
          await this.reconnect(resolve, reject, session, this.seedString || seedString, rememberMe, changePassword, delay, !this.reconnected && state);
        } else if (e.code === statusCodes['Client Already Connected']) {
          reject(new WebSocketError(wsAlreadyConnected, session.username, e));
        } else {
          this.init();
        }
      };

      ws.onerror = () => {}; // no-op so node WS implementation doesn't throw not found

    });
  }

  async reconnect(resolveConnection, rejectConnection, session, seedString, rememberMe, changePassword, reconnectDelay, currentState) {
    try {
      const retryDelay = Math.min(reconnectDelay, MAX_RETRY_DELAY);
      console.log("Connection to server lost. Attempting to reconnect in ".concat(retryDelay / 1000, " second").concat(retryDelay !== 1000 ? 's' : '', "..."));
      const dbsToReopen = [];
      const dbsToReopenById = []; // as soon as one reconnect succeeds, resolves all the way up the stack and all reconnects succeed

      resolveConnection(await new Promise((resolve, reject) => setTimeout(async () => {
        try {
          // get copy of currently opened databases' memory references to reopen WebSocket with same databases
          const state = currentState || {
            dbNameToHash: _objectSpread({}, this.state.dbNameToHash),
            databases: _objectSpread({}, this.state.databases),
            databasesByDbId: _objectSpread({}, this.state.databasesByDbId),
            shareTokenIdToDbId: _objectSpread({}, this.state.shareTokenIdToDbId)
          }; // mark databases as uninitialized to prevent client from using them until they are reopened

          for (const dbNameHash in state.databases) {
            state.databases[dbNameHash].init = false;
            state.databases[dbNameHash].finishedWaitingForBundle = false;
            dbsToReopen.push(dbNameHash);
          }

          for (const dbId in state.databasesByDbId) {
            state.databasesByDbId[dbId].init = false;
            state.databasesByDbId[dbId].finishedWaitingForBundle = false;
            dbsToReopenById.push(dbId);
          }

          this.init();
          this.reconnecting = true;
          const result = await this.connect(session, seedString, rememberMe, changePassword, reconnectDelay, state);
          this.reconnected = true; // only reopen databases on the first call to reconnect()

          if (!currentState) {
            await this.reopenDatabases(dbsToReopen, dbsToReopenById, 1000);
            console.log('Reconnected!');
          }

          resolve(result);
        } catch (e) {
          reject(e);
        }
      }, retryDelay)));
    } catch (e) {
      rejectConnection(e);
    }
  }

  async reopenDatabases(dbsToReopen, dbsToReopenById, retryDelay) {
    try {
      const openDatabasePromises = []; // open databases by database name hash

      for (const dbNameHash of dbsToReopen) {
        const database = this.state.databases[dbNameHash];

        if (!database.init) {
          const action = 'OpenDatabase';
          const params = {
            dbNameHash,
            reopenAtSeqNo: database.lastSeqNo
          };
          openDatabasePromises.push(this.request(action, params));
        }
      } // open databases by database ID


      for (const databaseId of dbsToReopenById) {
        const database = this.state.databasesByDbId[databaseId];

        if (!database.init) {
          const shareTokenHkdfKey = database.shareTokenHkdfKey; // if opened with shareToken, need to reauthenticate it

          const shareTokenAuthData = shareTokenHkdfKey ? await this.authenticateShareToken(database.shareTokenId, shareTokenHkdfKey) : {};
          const action = 'OpenDatabaseByDatabaseId';

          const params = _objectSpread({
            databaseId,
            reopenAtSeqNo: database.lastSeqNo
          }, shareTokenAuthData);

          openDatabasePromises.push(this.request(action, params));
        }
      }

      await Promise.all(openDatabasePromises);
    } catch (e) {
      // keep attempting to reopen on failure
      await new Promise(resolve => setTimeout(async () => {
        await this.reopenDatabases(dbsToReopen, dbsToReopenById, retryDelay + BACKOFF_RETRY_DELAY);
        resolve();
      }, Math.min(retryDelay, MAX_RETRY_DELAY)));
    }
  }

  heartbeat() {
    clearTimeout(this.pingTimeout);
    const LATENCY_BUFFER = 3000;
    this.pingTimeout = setTimeout(() => {
      if (this.ws) this.ws.close(statusCodes['No Pong Received']);
    }, 30000 + LATENCY_BUFFER);
  }

  close(code) {
    this.ws ? this.ws.close(code) : this.init();
  }

  async signOut() {
    const username = this.session.username;
    const connectionResolved = this.connectionResolved;
    const rejectConnection = this.rejectConnection;

    try {
      localData.signOutSession(this.rememberMe, username);
      const sessionId = this.session.sessionId;
      if (this.reconnecting) throw new errors.Reconnecting();
      const action = 'SignOut';
      const params = {
        sessionId
      };
      await this.request(action, params);
      this.close();

      if (!connectionResolved && rejectConnection) {
        rejectConnection(new WebSocketError('Canceled', username));
      }
    } catch (e) {
      if (!connectionResolved && rejectConnection) {
        rejectConnection(new WebSocketError('Canceled', username));
      }

      throw e;
    }
  }

  async setKeys(seedString) {
    if (this.keys.init) return;
    if (!seedString) throw new WebSocketError('Missing seed', this.session.username);
    if (!this.keys.salts) throw new WebSocketError('Missing salts', this.session.username);
    if (!this.seedString) this.seedString = seedString;
    const seed = base64.decode(seedString);
    const masterKey = await crypto.hkdf.importHkdfKey(seed);
    const salts = this.keys.salts;
    this.keys.encryptionKey = await crypto.aesGcm.importKeyFromMaster(masterKey, base64.decode(salts.encryptionKeySalt));
    this.keys.hmacKey = await crypto.hmac.importKeyFromMaster(masterKey, base64.decode(salts.hmacKeySalt));

    if (salts.ecdsaKeyEncryptionKeySalt) {
      const ecdsaKeyEncryptionKey = await crypto.ecdsa.importEcdsaKeyEncryptionKeyFromMaster(masterKey, base64.decode(salts.ecdsaKeyEncryptionKeySalt));
      const encryptedEcdsaPrivateKey = base64.decode(this.ecKeyData.encryptedEcdsaPrivateKey);
      const rawEcdsaPrivateKey = await crypto.aesGcm.decrypt(ecdsaKeyEncryptionKey, encryptedEcdsaPrivateKey);
      this.keys.ecdsaPrivateKey = await crypto.ecdsa.getPrivateKeyFromRawPrivateKey(rawEcdsaPrivateKey);
      const ecdhKeyEncryptionKey = await crypto.ecdh.importEcdhKeyEncryptionKeyFromMaster(masterKey, base64.decode(salts.ecdhKeyEncryptionKeySalt));
      const encryptedEcdhPrivateKey = base64.decode(this.ecKeyData.encryptedEcdhPrivateKey);
      const rawEcdhPrivateKey = await crypto.aesGcm.decrypt(ecdhKeyEncryptionKey, encryptedEcdhPrivateKey);
      this.keys.ecdhPrivateKey = await crypto.ecdh.getPrivateKeyFromRawPrivateKey(rawEcdhPrivateKey);
    } else if (salts.dhKeySalt) {
      // must be an old user created with userbase-js < v2.0.0. Need to prove access to DH key to server
      this.keys.dhPrivateKey = await crypto.diffieHellman.importKeyFromMaster(masterKey, base64.decode(salts.dhKeySalt));
    }

    if (salts.dhKeySalt || salts.ecdsaKeyWrapperSalt) {
      // must be an old user created with userbase-js <= v2.0.0. Update EC key data for future logins
      const ecdsaKeyData = await crypto.ecdsa.generateEcdsaKeyData(masterKey);
      const ecdhKeyData = await crypto.ecdh.generateEcdhKeyData(masterKey, ecdsaKeyData.ecdsaPrivateKey);
      this.keys.ecdsaPrivateKey = ecdsaKeyData.ecdsaPrivateKey;
      this.keys.ecdhPrivateKey = ecdhKeyData.ecdhPrivateKey;
      delete ecdsaKeyData.ecdsaPrivateKey;
      delete ecdhKeyData.ecdhPrivateKey;
      this.newEcKeyData = {
        ecdsaKeyData,
        ecdhKeyData
      };
    }
  }

  async validateKey() {
    let validationMessage;

    if (this.keys.ecdsaPrivateKey && !this.keys.dhPrivateKey) {
      // need to sign the validation message with ECDSA private key
      validationMessage = await crypto.ecdsa.sign(this.keys.ecdsaPrivateKey, base64.decode(this.validationMessage));
    } else if (this.keys.dhPrivateKey) {
      // need to decrypt the encrypted validation emssage with DH shared key
      const sharedKey = await crypto.diffieHellman.getSharedKeyWithServer(this.keys.dhPrivateKey);
      validationMessage = await crypto.aesGcm.decrypt(sharedKey, this.encryptedValidationMessage);
      delete this.keys.dhPrivateKey;
    }

    const action = 'ValidateKey';
    const params = {
      validationMessage: base64.encode(validationMessage),
      ecKeyData: this.newEcKeyData
    };
    const response = await this.request(action, params);
    const userData = response.data;
    return userData;
  }

  async request(action, params) {
    // generate a new requestId
    const requestId = uuidv4();
    this.requests[requestId] = {}; // get a promise that is resolved when the WebSocket
    // receives a response for this requestId — the promise
    // would time out of x seconds

    const responseWatcher = this.watch(requestId); // send the request on the WebSocket

    this.ws.send(JSON.stringify({
      requestId,
      action,
      params
    })); // wait for the response to arrive

    try {
      const response = await responseWatcher;
      return response;
    } catch (e) {
      // process any errors and re-throw them
      if (e.status === statusCodes['Too Many Requests']) throw new errors.TooManyRequests(e.data.retryDelay);else throw new RequestFailed(action, e);
    }
  }

  async watch(requestId) {
    const response = await new Promise((resolve, reject) => {
      this.requests[requestId].promiseResolve = resolve;
      this.requests[requestId].promiseReject = reject;
      setTimeout(() => {
        reject(new Error('timeout'));
      }, WS_REQUEST_TIMEOUT);
    });
    delete this.requests[requestId];
    return response;
  }

  async rebuildBundle(database, bundleSeqNo, encryptedBundleEncryptionKey) {
    const bundleChunks = [];

    for (let i = 0; i < database.bundleChunks[bundleSeqNo].length; i++) {
      const chunk = database.bundleChunks[bundleSeqNo][i];
      const chunkArrayBuffer = stringToArrayBuffer(chunk);
      bundleChunks.push(chunkArrayBuffer);
    }

    const bundleArrayBuffer = appendBuffers(bundleChunks).buffer;
    const {
      encrypted,
      plaintextMetadata
    } = JSON.parse(arrayBufferToString(bundleArrayBuffer));
    const bundleEncryptionKeyRaw = await crypto.aesGcm.decrypt(database.dbKey, base64.decode(encryptedBundleEncryptionKey));
    const bundleEncryptionKey = await crypto.aesGcm.getKeyFromRawKey(bundleEncryptionKeyRaw);
    const decrypted = await crypto.aesGcm.decrypt(bundleEncryptionKey, stringToArrayBuffer(encrypted));
    const decryptedString = arrayBufferToString(decrypted);
    const [decompressedEncrypted, decompressedPlaintextMetdata] = await Promise.all([decompress(decryptedString), decompress(plaintextMetadata)]);

    const bundle = _objectSpread(_objectSpread({}, JSON.parse(decompressedEncrypted)), JSON.parse(decompressedPlaintextMetdata));

    delete database.bundleChunks[bundleSeqNo];
    return bundle;
  }

  async uploadBundle(userId, dbId, seqNo, bundleId, bundleArrayBuffer) {
    let position = 0;
    let chunkNumber = 0;
    let batch = []; // will use this to send chunks to server in batches of BUNDLE_CHUNKS_PER_BATCH

    while (position < bundleArrayBuffer.byteLength) {
      const chunk = bundleArrayBuffer.slice(position, position + BUNDLE_CHUNK_SIZE); // using XHR to send binary data because Safari has trouble with string encoding over WebSocket

      batch.push(uploadBundleChunk(userId, dbId, seqNo, bundleId, chunkNumber, chunk));

      if (batch.length === BUNDLE_CHUNKS_PER_BATCH) {
        try {
          await Promise.all(batch);
        } catch (_unused) {
          // ok to fail - bundling is just an optimization
          return 0;
        }

        batch = [];
      }

      chunkNumber += 1;
      position += BUNDLE_CHUNK_SIZE;
    }

    try {
      await Promise.all(batch);
    } catch (_unused2) {
      // ok to fail - bundling is just an optimization
      return 0;
    }

    return chunkNumber;
  }

  async initBundleUpload(dbId, seqNo, dbKey) {
    const action = 'InitBundleUpload';
    const params = {
      dbId,
      seqNo
    };
    let initResponse;

    try {
      initResponse = await this.request(action, params);
    } catch (_unused3) {
      // ok to fail - bundling is just an optimization
      return {};
    }

    const {
      bundleId
    } = initResponse.data;
    const [bundleEncryptionKey, encryptedBundleEncryptionKey] = await crypto.aesGcm.generateAndEncryptKeyEncryptionKey(dbKey);
    return {
      bundleId,
      bundleEncryptionKey,
      encryptedBundleEncryptionKey: base64.encode(encryptedBundleEncryptionKey)
    };
  }

  orderedItems(items, itemsIndex) {
    const orderedItemsArray = [];

    for (let i = 0; i < itemsIndex.array.length; i++) {
      const itemId = itemsIndex.array[i].itemId;
      orderedItemsArray.push(items[itemId]);
    }

    return orderedItemsArray;
  }

  prepareBundle(database) {
    const {
      items,
      itemsIndex,
      itemsPlaintextMetadata
    } = database;
    const bundle = {
      // these values are all provided as input values to SDK, or generated by SDK - will compress, then encrypt
      encrypted: JSON.stringify({
        items: this.orderedItems(items, itemsIndex),
        itemsIndex: itemsIndex.array
      }),
      // these are values the server has access to and can modify - will compress, but no need to encrypt and risk CRIME
      plaintextMetadata: JSON.stringify({
        itemsPlaintextMetadata: this.orderedItems(itemsPlaintextMetadata, itemsIndex)
      })
    };
    return bundle;
  }

  async buildBundle(database) {
    const dbId = database.dbId;
    const lastSeqNo = database.lastSeqNo;
    const dbKey = database.dbKey;
    const userId = this.session.userId; // Client will only attempt to bundle at a particular seqNo a single time. This prevents server from spamming
    // client with buildBundle to maliciously get the client to re-use an IV in AES-GCM and reveal the dbKey

    if (database.bundledAtSeqNo && database.bundledAtSeqNo >= lastSeqNo) return;else database.bundledAtSeqNo = lastSeqNo;
    const bundle = this.prepareBundle(database);
    const writers = database.attributionEnabled ? [...database.usernamesByUserId.keys()].join(',') : undefined;
    const {
      bundleId,
      bundleEncryptionKey,
      encryptedBundleEncryptionKey
    } = await this.initBundleUpload(dbId, lastSeqNo, dbKey);
    if (!bundleId) return;
    const [compressedBeforeEncryption, compressedPlaintextMetadataString] = await Promise.all([compress(bundle.encrypted), compress(bundle.plaintextMetadata)]);
    const compressedArrayBufferBeforeEncryption = stringToArrayBuffer(compressedBeforeEncryption);
    const encryptedItems = await crypto.aesGcm.encrypt(bundleEncryptionKey, compressedArrayBufferBeforeEncryption);
    bundle.encrypted = arrayBufferToString(encryptedItems);
    bundle.plaintextMetadata = compressedPlaintextMetadataString;
    const bundleArrayBuffer = stringToArrayBuffer(JSON.stringify(bundle));
    const numChunks = await this.uploadBundle(userId, dbId, lastSeqNo, bundleId, bundleArrayBuffer);
    if (!numChunks) return;
    const action = 'CompleteBundleUpload';
    const params = {
      dbId,
      seqNo: lastSeqNo,
      bundleId,
      writers,
      numChunks,
      encryptedBundleEncryptionKey
    };

    try {
      await this.request(action, params);
    } catch (_unused4) {
      // ok to fail - bundling is just an optimization
      return;
    }
  }

  buildUserResult({
    username,
    userId,
    authToken,
    email,
    profile,
    protectedProfile,
    usedTempPassword,
    changePassword,
    passwordChanged,
    userData
  }) {
    const result = {
      username,
      userId,
      authToken
    };
    if (email) result.email = email;
    if (profile) result.profile = profile;
    if (protectedProfile) result.protectedProfile = protectedProfile;
    if (usedTempPassword) result.usedTempPassword = usedTempPassword;
    if (changePassword) result.changePassword = changePassword;
    if (passwordChanged) result.passwordChanged = passwordChanged;

    if (userData) {
      const {
        creationDate,
        stripeData
      } = userData;
      if (creationDate) result.creationDate = creationDate;

      if (stripeData) {
        const {
          paymentsMode,
          subscriptionStatus,
          cancelSubscriptionAt,
          subscriptionPlanId,
          trialExpirationDate
        } = stripeData;
        if (paymentsMode) result.paymentsMode = paymentsMode;
        if (subscriptionStatus) result.subscriptionStatus = subscriptionStatus;
        if (cancelSubscriptionAt) result.cancelSubscriptionAt = cancelSubscriptionAt;
        if (subscriptionPlanId) result.subscriptionPlanId = subscriptionPlanId;
        if (trialExpirationDate) result.trialExpirationDate = trialExpirationDate;
      }
    }

    return result;
  }

  handleUpdateUser(updatedUser) {
    // make sure WebSocket session matches provided user
    if (this.session && this.session.userId === updatedUser['userId']) {
      this.session.username = updatedUser['username'];
      this.userData = updatedUser.userData;
      const updateUserHandler = config.getUpdateUserHandler();

      if (updateUserHandler) {
        updateUserHandler({
          user: this.buildUserResult(_objectSpread({
            authToken: this.session.authToken
          }, updatedUser))
        });
      }
    }
  }

  async rotateKeys(newSeedString, newKeyData) {
    // re-arrange object to fit expected structure for setKeys() function
    const {
      keySalts,
      ecKeyData
    } = newKeyData;
    const {
      ecdsaKeyData,
      ecdhKeyData
    } = ecKeyData;
    keySalts.ecdsaKeyEncryptionKeySalt = ecdsaKeyData.ecdsaKeyEncryptionKeySalt;
    keySalts.ecdhKeyEncryptionKeySalt = ecdhKeyData.ecdhKeyEncryptionKeySalt;
    this.keys.salts = keySalts;
    this.ecKeyData = _objectSpread(_objectSpread({}, ecdsaKeyData), ecdhKeyData);
    await this.setKeys(newSeedString);
    this.keys.init = true;
  }

  async authenticateShareToken(shareTokenId, shareTokenHkdfKey) {
    // retrieve shareToken auth key data in order to prove access to shareToken to server
    const action = 'AuthenticateShareToken';
    const params = {
      shareTokenId
    };
    let response;

    try {
      response = await this.request(action, params);
    } catch (e) {
      if (e.response && e.response.data === 'ShareTokenNotFound') throw new errors.ShareTokenNotFound();
      throw e;
    }

    const {
      databaseId,
      shareTokenAuthKeyData,
      validationMessage
    } = response.data; // decrypt ECDSA private key. if it fails, not using the correct shareToken

    let shareTokenEcdsaPrivateKey;

    try {
      const shareTokenEcdsaKeyEncryptionKeySalt = base64.decode(shareTokenAuthKeyData.shareTokenEcdsaKeyEncryptionKeySalt);
      const shareTokenEcdsaKeyEncryptionKey = await crypto.ecdsa.importEcdsaKeyEncryptionKeyFromMaster(shareTokenHkdfKey, shareTokenEcdsaKeyEncryptionKeySalt);
      const shareTokenEncryptedEcdsaPrivateKey = base64.decode(shareTokenAuthKeyData.shareTokenEncryptedEcdsaPrivateKey);
      const shareTokenEcdsaPrivateKeyRaw = await crypto.aesGcm.decrypt(shareTokenEcdsaKeyEncryptionKey, shareTokenEncryptedEcdsaPrivateKey);
      shareTokenEcdsaPrivateKey = await crypto.ecdsa.getPrivateKeyFromRawPrivateKey(shareTokenEcdsaPrivateKeyRaw);
    } catch (_unused5) {
      throw new errors.ShareTokenInvalid();
    } // sign validation message sent by the server


    const signedValidationMessage = await crypto.ecdsa.sign(shareTokenEcdsaPrivateKey, base64.decode(validationMessage));
    return {
      databaseId,
      validationMessage,
      signedValidationMessage: base64.encode(signedValidationMessage)
    };
  }

}

export default new Connection();